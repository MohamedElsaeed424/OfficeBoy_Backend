
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type TokensTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "TokensTBL"
  objects: {
    reftoken: UsersTBLPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    tokenid: number
    refreshtoken: string
    userid: number
  }, ExtArgs["result"]["tokensTBL"]>
  composites: {}
}

/**
 * Model TokensTBL
 * 
 */
export type TokensTBL = runtime.Types.DefaultSelection<TokensTBLPayload>
export type BlacklistedTokenPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "BlacklistedToken"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    token: string
    createdat: Date
  }, ExtArgs["result"]["blacklistedToken"]>
  composites: {}
}

/**
 * Model BlacklistedToken
 * 
 */
export type BlacklistedToken = runtime.Types.DefaultSelection<BlacklistedTokenPayload>
export type UsersTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "UsersTBL"
  objects: {
    Employee: EmployeeTBLPayload<ExtArgs>[]
    Items: ItemsTBLPayload<ExtArgs>[]
    Tokens: TokensTBLPayload<ExtArgs>[]
    Officeboy: OfficeBoyTBLPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    userid: number
    firstname: string
    lastname: string
    email: string
    password: string
    role: string
  }, ExtArgs["result"]["usersTBL"]>
  composites: {}
}

/**
 * Model UsersTBL
 * 
 */
export type UsersTBL = runtime.Types.DefaultSelection<UsersTBLPayload>
export type EmployeeTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "EmployeeTBL"
  objects: {
    emp: UsersTBLPayload<ExtArgs>
    romid: RoomTBLPayload<ExtArgs>
    offid: OfficeTBLPayload<ExtArgs>
    sitid: SiteTBLPayload<ExtArgs>
    bulidingref: BuildingTBLPayload<ExtArgs>
    departmentref: DepartmentTBLPayload<ExtArgs>
    Cart: CartTBLPayload<ExtArgs>[]
    OrdersTBL: OrdersTBLPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    empid: number
    roomid: number
    officeid: number
    siteid: number
    buildingid: number
    departmentid: number
  }, ExtArgs["result"]["employeeTBL"]>
  composites: {}
}

/**
 * Model EmployeeTBL
 * 
 */
export type EmployeeTBL = runtime.Types.DefaultSelection<EmployeeTBLPayload>
export type OfficeBoyTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OfficeBoyTBL"
  objects: {
    officeboy: UsersTBLPayload<ExtArgs>
    offid: OfficeTBLPayload<ExtArgs>
    siteref: SiteTBLPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    officeboyid: number
    officeid: number
    siteid: number
  }, ExtArgs["result"]["officeBoyTBL"]>
  composites: {}
}

/**
 * Model OfficeBoyTBL
 * 
 */
export type OfficeBoyTBL = runtime.Types.DefaultSelection<OfficeBoyTBLPayload>
export type SiteTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "SiteTBL"
  objects: {
    Employee: EmployeeTBLPayload<ExtArgs>[]
    Building: BuildingTBLPayload<ExtArgs>[]
    Officeboy: OfficeBoyTBLPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    siteid: number
    sitename: string
  }, ExtArgs["result"]["siteTBL"]>
  composites: {}
}

/**
 * Model SiteTBL
 * 
 */
export type SiteTBL = runtime.Types.DefaultSelection<SiteTBLPayload>
export type BuildingTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "BuildingTBL"
  objects: {
    siteref: SiteTBLPayload<ExtArgs>
    Department: DepartmentTBLPayload<ExtArgs>[]
    Office: OfficeTBLPayload<ExtArgs>[]
    Employee: EmployeeTBLPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    buildingid: number
    buildingname: string
    siteid: number
  }, ExtArgs["result"]["buildingTBL"]>
  composites: {}
}

/**
 * Model BuildingTBL
 * 
 */
export type BuildingTBL = runtime.Types.DefaultSelection<BuildingTBLPayload>
export type OfficeTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OfficeTBL"
  objects: {
    Employee: EmployeeTBLPayload<ExtArgs>[]
    Officeboy: OfficeBoyTBLPayload<ExtArgs>[]
    bulidingref: BuildingTBLPayload<ExtArgs>
    Room: RoomTBLPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    officeid: number
    officeno: number
    buildingid: number
  }, ExtArgs["result"]["officeTBL"]>
  composites: {}
}

/**
 * Model OfficeTBL
 * 
 */
export type OfficeTBL = runtime.Types.DefaultSelection<OfficeTBLPayload>
export type DepartmentTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "DepartmentTBL"
  objects: {
    Room: RoomTBLPayload<ExtArgs>[]
    Employee: EmployeeTBLPayload<ExtArgs>[]
    bulidingref: BuildingTBLPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    departmentid: number
    departmentname: string
    buildingid: number
  }, ExtArgs["result"]["departmentTBL"]>
  composites: {}
}

/**
 * Model DepartmentTBL
 * 
 */
export type DepartmentTBL = runtime.Types.DefaultSelection<DepartmentTBLPayload>
export type RoomTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "RoomTBL"
  objects: {
    officeref: OfficeTBLPayload<ExtArgs>
    roomdepref: DepartmentTBLPayload<ExtArgs>
    Employee: EmployeeTBLPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    roomid: number
    roomno: number
    roomname: string
    officeid: number
    departmentid: number
  }, ExtArgs["result"]["roomTBL"]>
  composites: {}
}

/**
 * Model RoomTBL
 * 
 */
export type RoomTBL = runtime.Types.DefaultSelection<RoomTBLPayload>
export type CategoriesTblPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "CategoriesTbl"
  objects: {
    Item: ItemsTBLPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    categoryid: number
    categoryname: string
  }, ExtArgs["result"]["categoriesTbl"]>
  composites: {}
}

/**
 * Model CategoriesTbl
 * 
 */
export type CategoriesTbl = runtime.Types.DefaultSelection<CategoriesTblPayload>
export type ItemsTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ItemsTBL"
  objects: {
    creator: UsersTBLPayload<ExtArgs>
    catid: CategoriesTblPayload<ExtArgs>
    CartItems: CartItemsTBLPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    userid: number
    itemid: number
    categoryid: number
    itemname: string
    itemimagurl: string
    itemidescription: string
  }, ExtArgs["result"]["itemsTBL"]>
  composites: {}
}

/**
 * Model ItemsTBL
 * 
 */
export type ItemsTBL = runtime.Types.DefaultSelection<ItemsTBLPayload>
export type OrdersTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OrdersTBL"
  objects: {
    empref: EmployeeTBLPayload<ExtArgs>
    orderItems: OrderItemsTBLPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    orderid: number
    empid: number
  }, ExtArgs["result"]["ordersTBL"]>
  composites: {}
}

/**
 * Model OrdersTBL
 * 
 */
export type OrdersTBL = runtime.Types.DefaultSelection<OrdersTBLPayload>
export type OrderItemsTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OrderItemsTBL"
  objects: {
    ordersid: OrdersTBLPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    orderitemid: number
    itemname: string
    itemquantity: number
    itemsize: string
    orderid: number
  }, ExtArgs["result"]["orderItemsTBL"]>
  composites: {}
}

/**
 * Model OrderItemsTBL
 * 
 */
export type OrderItemsTBL = runtime.Types.DefaultSelection<OrderItemsTBLPayload>
export type CartTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "CartTBL"
  objects: {
    employeeid: EmployeeTBLPayload<ExtArgs>
    CartItems: CartItemsTBLPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    cartid: number
    empid: number
  }, ExtArgs["result"]["cartTBL"]>
  composites: {}
}

/**
 * Model CartTBL
 * 
 */
export type CartTBL = runtime.Types.DefaultSelection<CartTBLPayload>
export type CartItemsTBLPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "CartItemsTBL"
  objects: {
    carttid: CartTBLPayload<ExtArgs> | null
    itemids: ItemsTBLPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    cartitemid: number
    quanity: number
    cartid: number
    itemsize: string
    notes: string | null
    itemid: number
  }, ExtArgs["result"]["cartItemsTBL"]>
  composites: {}
}

/**
 * Model CartItemsTBL
 * 
 */
export type CartItemsTBL = runtime.Types.DefaultSelection<CartItemsTBLPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more TokensTBLS
 * const tokensTBLS = await prisma.tokensTBL.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more TokensTBLS
   * const tokensTBLS = await prisma.tokensTBL.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tokensTBL`: Exposes CRUD operations for the **TokensTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokensTBLS
    * const tokensTBLS = await prisma.tokensTBL.findMany()
    * ```
    */
  get tokensTBL(): Prisma.TokensTBLDelegate<ExtArgs>;

  /**
   * `prisma.blacklistedToken`: Exposes CRUD operations for the **BlacklistedToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlacklistedTokens
    * const blacklistedTokens = await prisma.blacklistedToken.findMany()
    * ```
    */
  get blacklistedToken(): Prisma.BlacklistedTokenDelegate<ExtArgs>;

  /**
   * `prisma.usersTBL`: Exposes CRUD operations for the **UsersTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersTBLS
    * const usersTBLS = await prisma.usersTBL.findMany()
    * ```
    */
  get usersTBL(): Prisma.UsersTBLDelegate<ExtArgs>;

  /**
   * `prisma.employeeTBL`: Exposes CRUD operations for the **EmployeeTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeTBLS
    * const employeeTBLS = await prisma.employeeTBL.findMany()
    * ```
    */
  get employeeTBL(): Prisma.EmployeeTBLDelegate<ExtArgs>;

  /**
   * `prisma.officeBoyTBL`: Exposes CRUD operations for the **OfficeBoyTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfficeBoyTBLS
    * const officeBoyTBLS = await prisma.officeBoyTBL.findMany()
    * ```
    */
  get officeBoyTBL(): Prisma.OfficeBoyTBLDelegate<ExtArgs>;

  /**
   * `prisma.siteTBL`: Exposes CRUD operations for the **SiteTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteTBLS
    * const siteTBLS = await prisma.siteTBL.findMany()
    * ```
    */
  get siteTBL(): Prisma.SiteTBLDelegate<ExtArgs>;

  /**
   * `prisma.buildingTBL`: Exposes CRUD operations for the **BuildingTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuildingTBLS
    * const buildingTBLS = await prisma.buildingTBL.findMany()
    * ```
    */
  get buildingTBL(): Prisma.BuildingTBLDelegate<ExtArgs>;

  /**
   * `prisma.officeTBL`: Exposes CRUD operations for the **OfficeTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfficeTBLS
    * const officeTBLS = await prisma.officeTBL.findMany()
    * ```
    */
  get officeTBL(): Prisma.OfficeTBLDelegate<ExtArgs>;

  /**
   * `prisma.departmentTBL`: Exposes CRUD operations for the **DepartmentTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentTBLS
    * const departmentTBLS = await prisma.departmentTBL.findMany()
    * ```
    */
  get departmentTBL(): Prisma.DepartmentTBLDelegate<ExtArgs>;

  /**
   * `prisma.roomTBL`: Exposes CRUD operations for the **RoomTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomTBLS
    * const roomTBLS = await prisma.roomTBL.findMany()
    * ```
    */
  get roomTBL(): Prisma.RoomTBLDelegate<ExtArgs>;

  /**
   * `prisma.categoriesTbl`: Exposes CRUD operations for the **CategoriesTbl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoriesTbls
    * const categoriesTbls = await prisma.categoriesTbl.findMany()
    * ```
    */
  get categoriesTbl(): Prisma.CategoriesTblDelegate<ExtArgs>;

  /**
   * `prisma.itemsTBL`: Exposes CRUD operations for the **ItemsTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemsTBLS
    * const itemsTBLS = await prisma.itemsTBL.findMany()
    * ```
    */
  get itemsTBL(): Prisma.ItemsTBLDelegate<ExtArgs>;

  /**
   * `prisma.ordersTBL`: Exposes CRUD operations for the **OrdersTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrdersTBLS
    * const ordersTBLS = await prisma.ordersTBL.findMany()
    * ```
    */
  get ordersTBL(): Prisma.OrdersTBLDelegate<ExtArgs>;

  /**
   * `prisma.orderItemsTBL`: Exposes CRUD operations for the **OrderItemsTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItemsTBLS
    * const orderItemsTBLS = await prisma.orderItemsTBL.findMany()
    * ```
    */
  get orderItemsTBL(): Prisma.OrderItemsTBLDelegate<ExtArgs>;

  /**
   * `prisma.cartTBL`: Exposes CRUD operations for the **CartTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartTBLS
    * const cartTBLS = await prisma.cartTBL.findMany()
    * ```
    */
  get cartTBL(): Prisma.CartTBLDelegate<ExtArgs>;

  /**
   * `prisma.cartItemsTBL`: Exposes CRUD operations for the **CartItemsTBL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItemsTBLS
    * const cartItemsTBLS = await prisma.cartItemsTBL.findMany()
    * ```
    */
  get cartItemsTBL(): Prisma.CartItemsTBLDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 5.0.0
   * Query Engine version: 6b0aef69b7cdfc787f822ecd7cdc76d5f1991584
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    TokensTBL: 'TokensTBL',
    BlacklistedToken: 'BlacklistedToken',
    UsersTBL: 'UsersTBL',
    EmployeeTBL: 'EmployeeTBL',
    OfficeBoyTBL: 'OfficeBoyTBL',
    SiteTBL: 'SiteTBL',
    BuildingTBL: 'BuildingTBL',
    OfficeTBL: 'OfficeTBL',
    DepartmentTBL: 'DepartmentTBL',
    RoomTBL: 'RoomTBL',
    CategoriesTbl: 'CategoriesTbl',
    ItemsTBL: 'ItemsTBL',
    OrdersTBL: 'OrdersTBL',
    OrderItemsTBL: 'OrderItemsTBL',
    CartTBL: 'CartTBL',
    CartItemsTBL: 'CartItemsTBL'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'tokensTBL' | 'blacklistedToken' | 'usersTBL' | 'employeeTBL' | 'officeBoyTBL' | 'siteTBL' | 'buildingTBL' | 'officeTBL' | 'departmentTBL' | 'roomTBL' | 'categoriesTbl' | 'itemsTBL' | 'ordersTBL' | 'orderItemsTBL' | 'cartTBL' | 'cartItemsTBL'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      TokensTBL: {
        payload: TokensTBLPayload<ExtArgs>
        fields: Prisma.TokensTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokensTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TokensTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokensTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TokensTBLPayload>
          }
          findFirst: {
            args: Prisma.TokensTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TokensTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokensTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TokensTBLPayload>
          }
          findMany: {
            args: Prisma.TokensTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TokensTBLPayload>[]
          }
          create: {
            args: Prisma.TokensTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TokensTBLPayload>
          }
          createMany: {
            args: Prisma.TokensTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TokensTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TokensTBLPayload>
          }
          update: {
            args: Prisma.TokensTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TokensTBLPayload>
          }
          deleteMany: {
            args: Prisma.TokensTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TokensTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TokensTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TokensTBLPayload>
          }
          aggregate: {
            args: Prisma.TokensTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTokensTBL>
          }
          groupBy: {
            args: Prisma.TokensTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TokensTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokensTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<TokensTBLCountAggregateOutputType> | number
          }
        }
      }
      BlacklistedToken: {
        payload: BlacklistedTokenPayload<ExtArgs>
        fields: Prisma.BlacklistedTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlacklistedTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlacklistedTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlacklistedTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlacklistedTokenPayload>
          }
          findFirst: {
            args: Prisma.BlacklistedTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlacklistedTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlacklistedTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlacklistedTokenPayload>
          }
          findMany: {
            args: Prisma.BlacklistedTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlacklistedTokenPayload>[]
          }
          create: {
            args: Prisma.BlacklistedTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlacklistedTokenPayload>
          }
          createMany: {
            args: Prisma.BlacklistedTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BlacklistedTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlacklistedTokenPayload>
          }
          update: {
            args: Prisma.BlacklistedTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlacklistedTokenPayload>
          }
          deleteMany: {
            args: Prisma.BlacklistedTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BlacklistedTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BlacklistedTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlacklistedTokenPayload>
          }
          aggregate: {
            args: Prisma.BlacklistedTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBlacklistedToken>
          }
          groupBy: {
            args: Prisma.BlacklistedTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BlacklistedTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlacklistedTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<BlacklistedTokenCountAggregateOutputType> | number
          }
        }
      }
      UsersTBL: {
        payload: UsersTBLPayload<ExtArgs>
        fields: Prisma.UsersTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersTBLPayload>
          }
          findFirst: {
            args: Prisma.UsersTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersTBLPayload>
          }
          findMany: {
            args: Prisma.UsersTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersTBLPayload>[]
          }
          create: {
            args: Prisma.UsersTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersTBLPayload>
          }
          createMany: {
            args: Prisma.UsersTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsersTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersTBLPayload>
          }
          update: {
            args: Prisma.UsersTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersTBLPayload>
          }
          deleteMany: {
            args: Prisma.UsersTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsersTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsersTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersTBLPayload>
          }
          aggregate: {
            args: Prisma.UsersTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsersTBL>
          }
          groupBy: {
            args: Prisma.UsersTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersTBLCountAggregateOutputType> | number
          }
        }
      }
      EmployeeTBL: {
        payload: EmployeeTBLPayload<ExtArgs>
        fields: Prisma.EmployeeTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmployeeTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmployeeTBLPayload>
          }
          findFirst: {
            args: Prisma.EmployeeTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmployeeTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmployeeTBLPayload>
          }
          findMany: {
            args: Prisma.EmployeeTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmployeeTBLPayload>[]
          }
          create: {
            args: Prisma.EmployeeTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmployeeTBLPayload>
          }
          createMany: {
            args: Prisma.EmployeeTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmployeeTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmployeeTBLPayload>
          }
          update: {
            args: Prisma.EmployeeTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmployeeTBLPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmployeeTBLPayload>
          }
          aggregate: {
            args: Prisma.EmployeeTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmployeeTBL>
          }
          groupBy: {
            args: Prisma.EmployeeTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmployeeTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<EmployeeTBLCountAggregateOutputType> | number
          }
        }
      }
      OfficeBoyTBL: {
        payload: OfficeBoyTBLPayload<ExtArgs>
        fields: Prisma.OfficeBoyTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfficeBoyTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeBoyTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfficeBoyTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeBoyTBLPayload>
          }
          findFirst: {
            args: Prisma.OfficeBoyTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeBoyTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfficeBoyTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeBoyTBLPayload>
          }
          findMany: {
            args: Prisma.OfficeBoyTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeBoyTBLPayload>[]
          }
          create: {
            args: Prisma.OfficeBoyTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeBoyTBLPayload>
          }
          createMany: {
            args: Prisma.OfficeBoyTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OfficeBoyTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeBoyTBLPayload>
          }
          update: {
            args: Prisma.OfficeBoyTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeBoyTBLPayload>
          }
          deleteMany: {
            args: Prisma.OfficeBoyTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OfficeBoyTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OfficeBoyTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeBoyTBLPayload>
          }
          aggregate: {
            args: Prisma.OfficeBoyTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOfficeBoyTBL>
          }
          groupBy: {
            args: Prisma.OfficeBoyTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OfficeBoyTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfficeBoyTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<OfficeBoyTBLCountAggregateOutputType> | number
          }
        }
      }
      SiteTBL: {
        payload: SiteTBLPayload<ExtArgs>
        fields: Prisma.SiteTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SiteTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SiteTBLPayload>
          }
          findFirst: {
            args: Prisma.SiteTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SiteTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SiteTBLPayload>
          }
          findMany: {
            args: Prisma.SiteTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SiteTBLPayload>[]
          }
          create: {
            args: Prisma.SiteTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SiteTBLPayload>
          }
          createMany: {
            args: Prisma.SiteTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SiteTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SiteTBLPayload>
          }
          update: {
            args: Prisma.SiteTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SiteTBLPayload>
          }
          deleteMany: {
            args: Prisma.SiteTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SiteTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SiteTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SiteTBLPayload>
          }
          aggregate: {
            args: Prisma.SiteTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSiteTBL>
          }
          groupBy: {
            args: Prisma.SiteTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SiteTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<SiteTBLCountAggregateOutputType> | number
          }
        }
      }
      BuildingTBL: {
        payload: BuildingTBLPayload<ExtArgs>
        fields: Prisma.BuildingTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildingTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BuildingTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildingTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BuildingTBLPayload>
          }
          findFirst: {
            args: Prisma.BuildingTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BuildingTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildingTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BuildingTBLPayload>
          }
          findMany: {
            args: Prisma.BuildingTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BuildingTBLPayload>[]
          }
          create: {
            args: Prisma.BuildingTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BuildingTBLPayload>
          }
          createMany: {
            args: Prisma.BuildingTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BuildingTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BuildingTBLPayload>
          }
          update: {
            args: Prisma.BuildingTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BuildingTBLPayload>
          }
          deleteMany: {
            args: Prisma.BuildingTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BuildingTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BuildingTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BuildingTBLPayload>
          }
          aggregate: {
            args: Prisma.BuildingTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBuildingTBL>
          }
          groupBy: {
            args: Prisma.BuildingTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BuildingTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildingTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<BuildingTBLCountAggregateOutputType> | number
          }
        }
      }
      OfficeTBL: {
        payload: OfficeTBLPayload<ExtArgs>
        fields: Prisma.OfficeTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfficeTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfficeTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeTBLPayload>
          }
          findFirst: {
            args: Prisma.OfficeTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfficeTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeTBLPayload>
          }
          findMany: {
            args: Prisma.OfficeTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeTBLPayload>[]
          }
          create: {
            args: Prisma.OfficeTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeTBLPayload>
          }
          createMany: {
            args: Prisma.OfficeTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OfficeTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeTBLPayload>
          }
          update: {
            args: Prisma.OfficeTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeTBLPayload>
          }
          deleteMany: {
            args: Prisma.OfficeTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OfficeTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OfficeTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfficeTBLPayload>
          }
          aggregate: {
            args: Prisma.OfficeTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOfficeTBL>
          }
          groupBy: {
            args: Prisma.OfficeTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OfficeTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfficeTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<OfficeTBLCountAggregateOutputType> | number
          }
        }
      }
      DepartmentTBL: {
        payload: DepartmentTBLPayload<ExtArgs>
        fields: Prisma.DepartmentTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DepartmentTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DepartmentTBLPayload>
          }
          findFirst: {
            args: Prisma.DepartmentTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DepartmentTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DepartmentTBLPayload>
          }
          findMany: {
            args: Prisma.DepartmentTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DepartmentTBLPayload>[]
          }
          create: {
            args: Prisma.DepartmentTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DepartmentTBLPayload>
          }
          createMany: {
            args: Prisma.DepartmentTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DepartmentTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DepartmentTBLPayload>
          }
          update: {
            args: Prisma.DepartmentTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DepartmentTBLPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DepartmentTBLPayload>
          }
          aggregate: {
            args: Prisma.DepartmentTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDepartmentTBL>
          }
          groupBy: {
            args: Prisma.DepartmentTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DepartmentTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<DepartmentTBLCountAggregateOutputType> | number
          }
        }
      }
      RoomTBL: {
        payload: RoomTBLPayload<ExtArgs>
        fields: Prisma.RoomTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoomTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoomTBLPayload>
          }
          findFirst: {
            args: Prisma.RoomTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoomTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoomTBLPayload>
          }
          findMany: {
            args: Prisma.RoomTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoomTBLPayload>[]
          }
          create: {
            args: Prisma.RoomTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoomTBLPayload>
          }
          createMany: {
            args: Prisma.RoomTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoomTBLPayload>
          }
          update: {
            args: Prisma.RoomTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoomTBLPayload>
          }
          deleteMany: {
            args: Prisma.RoomTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoomTBLPayload>
          }
          aggregate: {
            args: Prisma.RoomTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoomTBL>
          }
          groupBy: {
            args: Prisma.RoomTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomTBLCountAggregateOutputType> | number
          }
        }
      }
      CategoriesTbl: {
        payload: CategoriesTblPayload<ExtArgs>
        fields: Prisma.CategoriesTblFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriesTblFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoriesTblPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriesTblFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoriesTblPayload>
          }
          findFirst: {
            args: Prisma.CategoriesTblFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoriesTblPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriesTblFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoriesTblPayload>
          }
          findMany: {
            args: Prisma.CategoriesTblFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoriesTblPayload>[]
          }
          create: {
            args: Prisma.CategoriesTblCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoriesTblPayload>
          }
          createMany: {
            args: Prisma.CategoriesTblCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoriesTblDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoriesTblPayload>
          }
          update: {
            args: Prisma.CategoriesTblUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoriesTblPayload>
          }
          deleteMany: {
            args: Prisma.CategoriesTblDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriesTblUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoriesTblUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CategoriesTblPayload>
          }
          aggregate: {
            args: Prisma.CategoriesTblAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategoriesTbl>
          }
          groupBy: {
            args: Prisma.CategoriesTblGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoriesTblGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriesTblCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoriesTblCountAggregateOutputType> | number
          }
        }
      }
      ItemsTBL: {
        payload: ItemsTBLPayload<ExtArgs>
        fields: Prisma.ItemsTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemsTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemsTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemsTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemsTBLPayload>
          }
          findFirst: {
            args: Prisma.ItemsTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemsTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemsTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemsTBLPayload>
          }
          findMany: {
            args: Prisma.ItemsTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemsTBLPayload>[]
          }
          create: {
            args: Prisma.ItemsTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemsTBLPayload>
          }
          createMany: {
            args: Prisma.ItemsTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemsTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemsTBLPayload>
          }
          update: {
            args: Prisma.ItemsTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemsTBLPayload>
          }
          deleteMany: {
            args: Prisma.ItemsTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemsTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemsTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItemsTBLPayload>
          }
          aggregate: {
            args: Prisma.ItemsTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemsTBL>
          }
          groupBy: {
            args: Prisma.ItemsTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemsTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemsTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemsTBLCountAggregateOutputType> | number
          }
        }
      }
      OrdersTBL: {
        payload: OrdersTBLPayload<ExtArgs>
        fields: Prisma.OrdersTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrdersTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrdersTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrdersTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrdersTBLPayload>
          }
          findFirst: {
            args: Prisma.OrdersTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrdersTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrdersTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrdersTBLPayload>
          }
          findMany: {
            args: Prisma.OrdersTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrdersTBLPayload>[]
          }
          create: {
            args: Prisma.OrdersTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrdersTBLPayload>
          }
          createMany: {
            args: Prisma.OrdersTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrdersTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrdersTBLPayload>
          }
          update: {
            args: Prisma.OrdersTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrdersTBLPayload>
          }
          deleteMany: {
            args: Prisma.OrdersTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrdersTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrdersTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrdersTBLPayload>
          }
          aggregate: {
            args: Prisma.OrdersTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrdersTBL>
          }
          groupBy: {
            args: Prisma.OrdersTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrdersTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrdersTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<OrdersTBLCountAggregateOutputType> | number
          }
        }
      }
      OrderItemsTBL: {
        payload: OrderItemsTBLPayload<ExtArgs>
        fields: Prisma.OrderItemsTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemsTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderItemsTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemsTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderItemsTBLPayload>
          }
          findFirst: {
            args: Prisma.OrderItemsTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderItemsTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemsTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderItemsTBLPayload>
          }
          findMany: {
            args: Prisma.OrderItemsTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderItemsTBLPayload>[]
          }
          create: {
            args: Prisma.OrderItemsTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderItemsTBLPayload>
          }
          createMany: {
            args: Prisma.OrderItemsTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderItemsTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderItemsTBLPayload>
          }
          update: {
            args: Prisma.OrderItemsTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderItemsTBLPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemsTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemsTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemsTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderItemsTBLPayload>
          }
          aggregate: {
            args: Prisma.OrderItemsTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderItemsTBL>
          }
          groupBy: {
            args: Prisma.OrderItemsTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderItemsTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemsTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderItemsTBLCountAggregateOutputType> | number
          }
        }
      }
      CartTBL: {
        payload: CartTBLPayload<ExtArgs>
        fields: Prisma.CartTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartTBLPayload>
          }
          findFirst: {
            args: Prisma.CartTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartTBLPayload>
          }
          findMany: {
            args: Prisma.CartTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartTBLPayload>[]
          }
          create: {
            args: Prisma.CartTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartTBLPayload>
          }
          createMany: {
            args: Prisma.CartTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CartTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartTBLPayload>
          }
          update: {
            args: Prisma.CartTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartTBLPayload>
          }
          deleteMany: {
            args: Prisma.CartTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CartTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CartTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartTBLPayload>
          }
          aggregate: {
            args: Prisma.CartTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCartTBL>
          }
          groupBy: {
            args: Prisma.CartTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CartTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<CartTBLCountAggregateOutputType> | number
          }
        }
      }
      CartItemsTBL: {
        payload: CartItemsTBLPayload<ExtArgs>
        fields: Prisma.CartItemsTBLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemsTBLFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartItemsTBLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemsTBLFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartItemsTBLPayload>
          }
          findFirst: {
            args: Prisma.CartItemsTBLFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartItemsTBLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemsTBLFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartItemsTBLPayload>
          }
          findMany: {
            args: Prisma.CartItemsTBLFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartItemsTBLPayload>[]
          }
          create: {
            args: Prisma.CartItemsTBLCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartItemsTBLPayload>
          }
          createMany: {
            args: Prisma.CartItemsTBLCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CartItemsTBLDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartItemsTBLPayload>
          }
          update: {
            args: Prisma.CartItemsTBLUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartItemsTBLPayload>
          }
          deleteMany: {
            args: Prisma.CartItemsTBLDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemsTBLUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CartItemsTBLUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartItemsTBLPayload>
          }
          aggregate: {
            args: Prisma.CartItemsTBLAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCartItemsTBL>
          }
          groupBy: {
            args: Prisma.CartItemsTBLGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CartItemsTBLGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemsTBLCountArgs<ExtArgs>,
            result: $Utils.Optional<CartItemsTBLCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersTBLCountOutputType
   */


  export type UsersTBLCountOutputType = {
    Employee: number
    Items: number
    Tokens: number
    Officeboy: number
  }

  export type UsersTBLCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Employee?: boolean | UsersTBLCountOutputTypeCountEmployeeArgs
    Items?: boolean | UsersTBLCountOutputTypeCountItemsArgs
    Tokens?: boolean | UsersTBLCountOutputTypeCountTokensArgs
    Officeboy?: boolean | UsersTBLCountOutputTypeCountOfficeboyArgs
  }

  // Custom InputTypes

  /**
   * UsersTBLCountOutputType without action
   */
  export type UsersTBLCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersTBLCountOutputType
     */
    select?: UsersTBLCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UsersTBLCountOutputType without action
   */
  export type UsersTBLCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EmployeeTBLWhereInput
  }


  /**
   * UsersTBLCountOutputType without action
   */
  export type UsersTBLCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ItemsTBLWhereInput
  }


  /**
   * UsersTBLCountOutputType without action
   */
  export type UsersTBLCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TokensTBLWhereInput
  }


  /**
   * UsersTBLCountOutputType without action
   */
  export type UsersTBLCountOutputTypeCountOfficeboyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfficeBoyTBLWhereInput
  }



  /**
   * Count Type EmployeeTBLCountOutputType
   */


  export type EmployeeTBLCountOutputType = {
    Cart: number
    OrdersTBL: number
  }

  export type EmployeeTBLCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Cart?: boolean | EmployeeTBLCountOutputTypeCountCartArgs
    OrdersTBL?: boolean | EmployeeTBLCountOutputTypeCountOrdersTBLArgs
  }

  // Custom InputTypes

  /**
   * EmployeeTBLCountOutputType without action
   */
  export type EmployeeTBLCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBLCountOutputType
     */
    select?: EmployeeTBLCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EmployeeTBLCountOutputType without action
   */
  export type EmployeeTBLCountOutputTypeCountCartArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CartTBLWhereInput
  }


  /**
   * EmployeeTBLCountOutputType without action
   */
  export type EmployeeTBLCountOutputTypeCountOrdersTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrdersTBLWhereInput
  }



  /**
   * Count Type SiteTBLCountOutputType
   */


  export type SiteTBLCountOutputType = {
    Employee: number
    Building: number
    Officeboy: number
  }

  export type SiteTBLCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Employee?: boolean | SiteTBLCountOutputTypeCountEmployeeArgs
    Building?: boolean | SiteTBLCountOutputTypeCountBuildingArgs
    Officeboy?: boolean | SiteTBLCountOutputTypeCountOfficeboyArgs
  }

  // Custom InputTypes

  /**
   * SiteTBLCountOutputType without action
   */
  export type SiteTBLCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteTBLCountOutputType
     */
    select?: SiteTBLCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SiteTBLCountOutputType without action
   */
  export type SiteTBLCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EmployeeTBLWhereInput
  }


  /**
   * SiteTBLCountOutputType without action
   */
  export type SiteTBLCountOutputTypeCountBuildingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BuildingTBLWhereInput
  }


  /**
   * SiteTBLCountOutputType without action
   */
  export type SiteTBLCountOutputTypeCountOfficeboyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfficeBoyTBLWhereInput
  }



  /**
   * Count Type BuildingTBLCountOutputType
   */


  export type BuildingTBLCountOutputType = {
    Department: number
    Office: number
    Employee: number
  }

  export type BuildingTBLCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Department?: boolean | BuildingTBLCountOutputTypeCountDepartmentArgs
    Office?: boolean | BuildingTBLCountOutputTypeCountOfficeArgs
    Employee?: boolean | BuildingTBLCountOutputTypeCountEmployeeArgs
  }

  // Custom InputTypes

  /**
   * BuildingTBLCountOutputType without action
   */
  export type BuildingTBLCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingTBLCountOutputType
     */
    select?: BuildingTBLCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BuildingTBLCountOutputType without action
   */
  export type BuildingTBLCountOutputTypeCountDepartmentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DepartmentTBLWhereInput
  }


  /**
   * BuildingTBLCountOutputType without action
   */
  export type BuildingTBLCountOutputTypeCountOfficeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfficeTBLWhereInput
  }


  /**
   * BuildingTBLCountOutputType without action
   */
  export type BuildingTBLCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EmployeeTBLWhereInput
  }



  /**
   * Count Type OfficeTBLCountOutputType
   */


  export type OfficeTBLCountOutputType = {
    Employee: number
    Officeboy: number
    Room: number
  }

  export type OfficeTBLCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Employee?: boolean | OfficeTBLCountOutputTypeCountEmployeeArgs
    Officeboy?: boolean | OfficeTBLCountOutputTypeCountOfficeboyArgs
    Room?: boolean | OfficeTBLCountOutputTypeCountRoomArgs
  }

  // Custom InputTypes

  /**
   * OfficeTBLCountOutputType without action
   */
  export type OfficeTBLCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeTBLCountOutputType
     */
    select?: OfficeTBLCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OfficeTBLCountOutputType without action
   */
  export type OfficeTBLCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EmployeeTBLWhereInput
  }


  /**
   * OfficeTBLCountOutputType without action
   */
  export type OfficeTBLCountOutputTypeCountOfficeboyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfficeBoyTBLWhereInput
  }


  /**
   * OfficeTBLCountOutputType without action
   */
  export type OfficeTBLCountOutputTypeCountRoomArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RoomTBLWhereInput
  }



  /**
   * Count Type DepartmentTBLCountOutputType
   */


  export type DepartmentTBLCountOutputType = {
    Room: number
    Employee: number
  }

  export type DepartmentTBLCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Room?: boolean | DepartmentTBLCountOutputTypeCountRoomArgs
    Employee?: boolean | DepartmentTBLCountOutputTypeCountEmployeeArgs
  }

  // Custom InputTypes

  /**
   * DepartmentTBLCountOutputType without action
   */
  export type DepartmentTBLCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentTBLCountOutputType
     */
    select?: DepartmentTBLCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DepartmentTBLCountOutputType without action
   */
  export type DepartmentTBLCountOutputTypeCountRoomArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RoomTBLWhereInput
  }


  /**
   * DepartmentTBLCountOutputType without action
   */
  export type DepartmentTBLCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EmployeeTBLWhereInput
  }



  /**
   * Count Type RoomTBLCountOutputType
   */


  export type RoomTBLCountOutputType = {
    Employee: number
  }

  export type RoomTBLCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Employee?: boolean | RoomTBLCountOutputTypeCountEmployeeArgs
  }

  // Custom InputTypes

  /**
   * RoomTBLCountOutputType without action
   */
  export type RoomTBLCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTBLCountOutputType
     */
    select?: RoomTBLCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RoomTBLCountOutputType without action
   */
  export type RoomTBLCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EmployeeTBLWhereInput
  }



  /**
   * Count Type CategoriesTblCountOutputType
   */


  export type CategoriesTblCountOutputType = {
    Item: number
  }

  export type CategoriesTblCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Item?: boolean | CategoriesTblCountOutputTypeCountItemArgs
  }

  // Custom InputTypes

  /**
   * CategoriesTblCountOutputType without action
   */
  export type CategoriesTblCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesTblCountOutputType
     */
    select?: CategoriesTblCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoriesTblCountOutputType without action
   */
  export type CategoriesTblCountOutputTypeCountItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ItemsTBLWhereInput
  }



  /**
   * Count Type ItemsTBLCountOutputType
   */


  export type ItemsTBLCountOutputType = {
    CartItems: number
  }

  export type ItemsTBLCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    CartItems?: boolean | ItemsTBLCountOutputTypeCountCartItemsArgs
  }

  // Custom InputTypes

  /**
   * ItemsTBLCountOutputType without action
   */
  export type ItemsTBLCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsTBLCountOutputType
     */
    select?: ItemsTBLCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ItemsTBLCountOutputType without action
   */
  export type ItemsTBLCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CartItemsTBLWhereInput
  }



  /**
   * Count Type OrdersTBLCountOutputType
   */


  export type OrdersTBLCountOutputType = {
    orderItems: number
  }

  export type OrdersTBLCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    orderItems?: boolean | OrdersTBLCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes

  /**
   * OrdersTBLCountOutputType without action
   */
  export type OrdersTBLCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersTBLCountOutputType
     */
    select?: OrdersTBLCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OrdersTBLCountOutputType without action
   */
  export type OrdersTBLCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderItemsTBLWhereInput
  }



  /**
   * Count Type CartTBLCountOutputType
   */


  export type CartTBLCountOutputType = {
    CartItems: number
  }

  export type CartTBLCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    CartItems?: boolean | CartTBLCountOutputTypeCountCartItemsArgs
  }

  // Custom InputTypes

  /**
   * CartTBLCountOutputType without action
   */
  export type CartTBLCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartTBLCountOutputType
     */
    select?: CartTBLCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CartTBLCountOutputType without action
   */
  export type CartTBLCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CartItemsTBLWhereInput
  }



  /**
   * Models
   */

  /**
   * Model TokensTBL
   */


  export type AggregateTokensTBL = {
    _count: TokensTBLCountAggregateOutputType | null
    _avg: TokensTBLAvgAggregateOutputType | null
    _sum: TokensTBLSumAggregateOutputType | null
    _min: TokensTBLMinAggregateOutputType | null
    _max: TokensTBLMaxAggregateOutputType | null
  }

  export type TokensTBLAvgAggregateOutputType = {
    tokenid: number | null
    userid: number | null
  }

  export type TokensTBLSumAggregateOutputType = {
    tokenid: number | null
    userid: number | null
  }

  export type TokensTBLMinAggregateOutputType = {
    tokenid: number | null
    refreshtoken: string | null
    userid: number | null
  }

  export type TokensTBLMaxAggregateOutputType = {
    tokenid: number | null
    refreshtoken: string | null
    userid: number | null
  }

  export type TokensTBLCountAggregateOutputType = {
    tokenid: number
    refreshtoken: number
    userid: number
    _all: number
  }


  export type TokensTBLAvgAggregateInputType = {
    tokenid?: true
    userid?: true
  }

  export type TokensTBLSumAggregateInputType = {
    tokenid?: true
    userid?: true
  }

  export type TokensTBLMinAggregateInputType = {
    tokenid?: true
    refreshtoken?: true
    userid?: true
  }

  export type TokensTBLMaxAggregateInputType = {
    tokenid?: true
    refreshtoken?: true
    userid?: true
  }

  export type TokensTBLCountAggregateInputType = {
    tokenid?: true
    refreshtoken?: true
    userid?: true
    _all?: true
  }

  export type TokensTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokensTBL to aggregate.
     */
    where?: TokensTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokensTBLS to fetch.
     */
    orderBy?: TokensTBLOrderByWithRelationInput | TokensTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokensTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokensTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokensTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokensTBLS
    **/
    _count?: true | TokensTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokensTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokensTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokensTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokensTBLMaxAggregateInputType
  }

  export type GetTokensTBLAggregateType<T extends TokensTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateTokensTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokensTBL[P]>
      : GetScalarType<T[P], AggregateTokensTBL[P]>
  }




  export type TokensTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TokensTBLWhereInput
    orderBy?: TokensTBLOrderByWithAggregationInput | TokensTBLOrderByWithAggregationInput[]
    by: TokensTBLScalarFieldEnum[] | TokensTBLScalarFieldEnum
    having?: TokensTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokensTBLCountAggregateInputType | true
    _avg?: TokensTBLAvgAggregateInputType
    _sum?: TokensTBLSumAggregateInputType
    _min?: TokensTBLMinAggregateInputType
    _max?: TokensTBLMaxAggregateInputType
  }


  export type TokensTBLGroupByOutputType = {
    tokenid: number
    refreshtoken: string
    userid: number
    _count: TokensTBLCountAggregateOutputType | null
    _avg: TokensTBLAvgAggregateOutputType | null
    _sum: TokensTBLSumAggregateOutputType | null
    _min: TokensTBLMinAggregateOutputType | null
    _max: TokensTBLMaxAggregateOutputType | null
  }

  type GetTokensTBLGroupByPayload<T extends TokensTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokensTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokensTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokensTBLGroupByOutputType[P]>
            : GetScalarType<T[P], TokensTBLGroupByOutputType[P]>
        }
      >
    >


  export type TokensTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tokenid?: boolean
    refreshtoken?: boolean
    userid?: boolean
    reftoken?: boolean | UsersTBLArgs<ExtArgs>
  }, ExtArgs["result"]["tokensTBL"]>

  export type TokensTBLSelectScalar = {
    tokenid?: boolean
    refreshtoken?: boolean
    userid?: boolean
  }

  export type TokensTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    reftoken?: boolean | UsersTBLArgs<ExtArgs>
  }


  type TokensTBLGetPayload<S extends boolean | null | undefined | TokensTBLArgs> = $Types.GetResult<TokensTBLPayload, S>

  type TokensTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TokensTBLFindManyArgs, 'select' | 'include'> & {
      select?: TokensTBLCountAggregateInputType | true
    }

  export interface TokensTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TokensTBL'], meta: { name: 'TokensTBL' } }
    /**
     * Find zero or one TokensTBL that matches the filter.
     * @param {TokensTBLFindUniqueArgs} args - Arguments to find a TokensTBL
     * @example
     * // Get one TokensTBL
     * const tokensTBL = await prisma.tokensTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TokensTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TokensTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__TokensTBLClient<$Types.GetResult<TokensTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TokensTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TokensTBLFindUniqueOrThrowArgs} args - Arguments to find a TokensTBL
     * @example
     * // Get one TokensTBL
     * const tokensTBL = await prisma.tokensTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TokensTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TokensTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TokensTBLClient<$Types.GetResult<TokensTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TokensTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensTBLFindFirstArgs} args - Arguments to find a TokensTBL
     * @example
     * // Get one TokensTBL
     * const tokensTBL = await prisma.tokensTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TokensTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TokensTBLFindFirstArgs<ExtArgs>>
    ): Prisma__TokensTBLClient<$Types.GetResult<TokensTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TokensTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensTBLFindFirstOrThrowArgs} args - Arguments to find a TokensTBL
     * @example
     * // Get one TokensTBL
     * const tokensTBL = await prisma.tokensTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TokensTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TokensTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TokensTBLClient<$Types.GetResult<TokensTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TokensTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokensTBLS
     * const tokensTBLS = await prisma.tokensTBL.findMany()
     * 
     * // Get first 10 TokensTBLS
     * const tokensTBLS = await prisma.tokensTBL.findMany({ take: 10 })
     * 
     * // Only select the `tokenid`
     * const tokensTBLWithTokenidOnly = await prisma.tokensTBL.findMany({ select: { tokenid: true } })
     * 
    **/
    findMany<T extends TokensTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TokensTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TokensTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TokensTBL.
     * @param {TokensTBLCreateArgs} args - Arguments to create a TokensTBL.
     * @example
     * // Create one TokensTBL
     * const TokensTBL = await prisma.tokensTBL.create({
     *   data: {
     *     // ... data to create a TokensTBL
     *   }
     * })
     * 
    **/
    create<T extends TokensTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TokensTBLCreateArgs<ExtArgs>>
    ): Prisma__TokensTBLClient<$Types.GetResult<TokensTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TokensTBLS.
     *     @param {TokensTBLCreateManyArgs} args - Arguments to create many TokensTBLS.
     *     @example
     *     // Create many TokensTBLS
     *     const tokensTBL = await prisma.tokensTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TokensTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TokensTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TokensTBL.
     * @param {TokensTBLDeleteArgs} args - Arguments to delete one TokensTBL.
     * @example
     * // Delete one TokensTBL
     * const TokensTBL = await prisma.tokensTBL.delete({
     *   where: {
     *     // ... filter to delete one TokensTBL
     *   }
     * })
     * 
    **/
    delete<T extends TokensTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TokensTBLDeleteArgs<ExtArgs>>
    ): Prisma__TokensTBLClient<$Types.GetResult<TokensTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TokensTBL.
     * @param {TokensTBLUpdateArgs} args - Arguments to update one TokensTBL.
     * @example
     * // Update one TokensTBL
     * const tokensTBL = await prisma.tokensTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TokensTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TokensTBLUpdateArgs<ExtArgs>>
    ): Prisma__TokensTBLClient<$Types.GetResult<TokensTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TokensTBLS.
     * @param {TokensTBLDeleteManyArgs} args - Arguments to filter TokensTBLS to delete.
     * @example
     * // Delete a few TokensTBLS
     * const { count } = await prisma.tokensTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TokensTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TokensTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokensTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokensTBLS
     * const tokensTBL = await prisma.tokensTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TokensTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TokensTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TokensTBL.
     * @param {TokensTBLUpsertArgs} args - Arguments to update or create a TokensTBL.
     * @example
     * // Update or create a TokensTBL
     * const tokensTBL = await prisma.tokensTBL.upsert({
     *   create: {
     *     // ... data to create a TokensTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokensTBL we want to update
     *   }
     * })
    **/
    upsert<T extends TokensTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TokensTBLUpsertArgs<ExtArgs>>
    ): Prisma__TokensTBLClient<$Types.GetResult<TokensTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TokensTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensTBLCountArgs} args - Arguments to filter TokensTBLS to count.
     * @example
     * // Count the number of TokensTBLS
     * const count = await prisma.tokensTBL.count({
     *   where: {
     *     // ... the filter for the TokensTBLS we want to count
     *   }
     * })
    **/
    count<T extends TokensTBLCountArgs>(
      args?: Subset<T, TokensTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokensTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokensTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokensTBLAggregateArgs>(args: Subset<T, TokensTBLAggregateArgs>): Prisma.PrismaPromise<GetTokensTBLAggregateType<T>>

    /**
     * Group by TokensTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokensTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokensTBLGroupByArgs['orderBy'] }
        : { orderBy?: TokensTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokensTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokensTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TokensTBL model
   */
  readonly fields: TokensTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TokensTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TokensTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reftoken<T extends UsersTBLArgs<ExtArgs> = {}>(args?: Subset<T, UsersTBLArgs<ExtArgs>>): Prisma__UsersTBLClient<$Types.GetResult<UsersTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the TokensTBL model
   */ 
  interface TokensTBLFieldRefs {
    readonly tokenid: FieldRef<"TokensTBL", 'Int'>
    readonly refreshtoken: FieldRef<"TokensTBL", 'String'>
    readonly userid: FieldRef<"TokensTBL", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * TokensTBL findUnique
   */
  export type TokensTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokensTBL
     */
    select?: TokensTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokensTBLInclude<ExtArgs> | null
    /**
     * Filter, which TokensTBL to fetch.
     */
    where: TokensTBLWhereUniqueInput
  }


  /**
   * TokensTBL findUniqueOrThrow
   */
  export type TokensTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokensTBL
     */
    select?: TokensTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokensTBLInclude<ExtArgs> | null
    /**
     * Filter, which TokensTBL to fetch.
     */
    where: TokensTBLWhereUniqueInput
  }


  /**
   * TokensTBL findFirst
   */
  export type TokensTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokensTBL
     */
    select?: TokensTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokensTBLInclude<ExtArgs> | null
    /**
     * Filter, which TokensTBL to fetch.
     */
    where?: TokensTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokensTBLS to fetch.
     */
    orderBy?: TokensTBLOrderByWithRelationInput | TokensTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokensTBLS.
     */
    cursor?: TokensTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokensTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokensTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokensTBLS.
     */
    distinct?: TokensTBLScalarFieldEnum | TokensTBLScalarFieldEnum[]
  }


  /**
   * TokensTBL findFirstOrThrow
   */
  export type TokensTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokensTBL
     */
    select?: TokensTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokensTBLInclude<ExtArgs> | null
    /**
     * Filter, which TokensTBL to fetch.
     */
    where?: TokensTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokensTBLS to fetch.
     */
    orderBy?: TokensTBLOrderByWithRelationInput | TokensTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokensTBLS.
     */
    cursor?: TokensTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokensTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokensTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokensTBLS.
     */
    distinct?: TokensTBLScalarFieldEnum | TokensTBLScalarFieldEnum[]
  }


  /**
   * TokensTBL findMany
   */
  export type TokensTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokensTBL
     */
    select?: TokensTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokensTBLInclude<ExtArgs> | null
    /**
     * Filter, which TokensTBLS to fetch.
     */
    where?: TokensTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokensTBLS to fetch.
     */
    orderBy?: TokensTBLOrderByWithRelationInput | TokensTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokensTBLS.
     */
    cursor?: TokensTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokensTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokensTBLS.
     */
    skip?: number
    distinct?: TokensTBLScalarFieldEnum | TokensTBLScalarFieldEnum[]
  }


  /**
   * TokensTBL create
   */
  export type TokensTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokensTBL
     */
    select?: TokensTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokensTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a TokensTBL.
     */
    data: XOR<TokensTBLCreateInput, TokensTBLUncheckedCreateInput>
  }


  /**
   * TokensTBL createMany
   */
  export type TokensTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TokensTBLS.
     */
    data: TokensTBLCreateManyInput | TokensTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TokensTBL update
   */
  export type TokensTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokensTBL
     */
    select?: TokensTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokensTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a TokensTBL.
     */
    data: XOR<TokensTBLUpdateInput, TokensTBLUncheckedUpdateInput>
    /**
     * Choose, which TokensTBL to update.
     */
    where: TokensTBLWhereUniqueInput
  }


  /**
   * TokensTBL updateMany
   */
  export type TokensTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TokensTBLS.
     */
    data: XOR<TokensTBLUpdateManyMutationInput, TokensTBLUncheckedUpdateManyInput>
    /**
     * Filter which TokensTBLS to update
     */
    where?: TokensTBLWhereInput
  }


  /**
   * TokensTBL upsert
   */
  export type TokensTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokensTBL
     */
    select?: TokensTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokensTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the TokensTBL to update in case it exists.
     */
    where: TokensTBLWhereUniqueInput
    /**
     * In case the TokensTBL found by the `where` argument doesn't exist, create a new TokensTBL with this data.
     */
    create: XOR<TokensTBLCreateInput, TokensTBLUncheckedCreateInput>
    /**
     * In case the TokensTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokensTBLUpdateInput, TokensTBLUncheckedUpdateInput>
  }


  /**
   * TokensTBL delete
   */
  export type TokensTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokensTBL
     */
    select?: TokensTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokensTBLInclude<ExtArgs> | null
    /**
     * Filter which TokensTBL to delete.
     */
    where: TokensTBLWhereUniqueInput
  }


  /**
   * TokensTBL deleteMany
   */
  export type TokensTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokensTBLS to delete
     */
    where?: TokensTBLWhereInput
  }


  /**
   * TokensTBL without action
   */
  export type TokensTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokensTBL
     */
    select?: TokensTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokensTBLInclude<ExtArgs> | null
  }



  /**
   * Model BlacklistedToken
   */


  export type AggregateBlacklistedToken = {
    _count: BlacklistedTokenCountAggregateOutputType | null
    _avg: BlacklistedTokenAvgAggregateOutputType | null
    _sum: BlacklistedTokenSumAggregateOutputType | null
    _min: BlacklistedTokenMinAggregateOutputType | null
    _max: BlacklistedTokenMaxAggregateOutputType | null
  }

  export type BlacklistedTokenAvgAggregateOutputType = {
    id: number | null
  }

  export type BlacklistedTokenSumAggregateOutputType = {
    id: number | null
  }

  export type BlacklistedTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    createdat: Date | null
  }

  export type BlacklistedTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    createdat: Date | null
  }

  export type BlacklistedTokenCountAggregateOutputType = {
    id: number
    token: number
    createdat: number
    _all: number
  }


  export type BlacklistedTokenAvgAggregateInputType = {
    id?: true
  }

  export type BlacklistedTokenSumAggregateInputType = {
    id?: true
  }

  export type BlacklistedTokenMinAggregateInputType = {
    id?: true
    token?: true
    createdat?: true
  }

  export type BlacklistedTokenMaxAggregateInputType = {
    id?: true
    token?: true
    createdat?: true
  }

  export type BlacklistedTokenCountAggregateInputType = {
    id?: true
    token?: true
    createdat?: true
    _all?: true
  }

  export type BlacklistedTokenAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlacklistedToken to aggregate.
     */
    where?: BlacklistedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistedTokens to fetch.
     */
    orderBy?: BlacklistedTokenOrderByWithRelationInput | BlacklistedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlacklistedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlacklistedTokens
    **/
    _count?: true | BlacklistedTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlacklistedTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlacklistedTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlacklistedTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlacklistedTokenMaxAggregateInputType
  }

  export type GetBlacklistedTokenAggregateType<T extends BlacklistedTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateBlacklistedToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlacklistedToken[P]>
      : GetScalarType<T[P], AggregateBlacklistedToken[P]>
  }




  export type BlacklistedTokenGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BlacklistedTokenWhereInput
    orderBy?: BlacklistedTokenOrderByWithAggregationInput | BlacklistedTokenOrderByWithAggregationInput[]
    by: BlacklistedTokenScalarFieldEnum[] | BlacklistedTokenScalarFieldEnum
    having?: BlacklistedTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlacklistedTokenCountAggregateInputType | true
    _avg?: BlacklistedTokenAvgAggregateInputType
    _sum?: BlacklistedTokenSumAggregateInputType
    _min?: BlacklistedTokenMinAggregateInputType
    _max?: BlacklistedTokenMaxAggregateInputType
  }


  export type BlacklistedTokenGroupByOutputType = {
    id: number
    token: string
    createdat: Date
    _count: BlacklistedTokenCountAggregateOutputType | null
    _avg: BlacklistedTokenAvgAggregateOutputType | null
    _sum: BlacklistedTokenSumAggregateOutputType | null
    _min: BlacklistedTokenMinAggregateOutputType | null
    _max: BlacklistedTokenMaxAggregateOutputType | null
  }

  type GetBlacklistedTokenGroupByPayload<T extends BlacklistedTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlacklistedTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlacklistedTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlacklistedTokenGroupByOutputType[P]>
            : GetScalarType<T[P], BlacklistedTokenGroupByOutputType[P]>
        }
      >
    >


  export type BlacklistedTokenSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    createdat?: boolean
  }, ExtArgs["result"]["blacklistedToken"]>

  export type BlacklistedTokenSelectScalar = {
    id?: boolean
    token?: boolean
    createdat?: boolean
  }


  type BlacklistedTokenGetPayload<S extends boolean | null | undefined | BlacklistedTokenArgs> = $Types.GetResult<BlacklistedTokenPayload, S>

  type BlacklistedTokenCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BlacklistedTokenFindManyArgs, 'select' | 'include'> & {
      select?: BlacklistedTokenCountAggregateInputType | true
    }

  export interface BlacklistedTokenDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlacklistedToken'], meta: { name: 'BlacklistedToken' } }
    /**
     * Find zero or one BlacklistedToken that matches the filter.
     * @param {BlacklistedTokenFindUniqueArgs} args - Arguments to find a BlacklistedToken
     * @example
     * // Get one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlacklistedTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BlacklistedTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__BlacklistedTokenClient<$Types.GetResult<BlacklistedTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BlacklistedToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BlacklistedTokenFindUniqueOrThrowArgs} args - Arguments to find a BlacklistedToken
     * @example
     * // Get one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BlacklistedTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlacklistedTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BlacklistedTokenClient<$Types.GetResult<BlacklistedTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BlacklistedToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenFindFirstArgs} args - Arguments to find a BlacklistedToken
     * @example
     * // Get one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlacklistedTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BlacklistedTokenFindFirstArgs<ExtArgs>>
    ): Prisma__BlacklistedTokenClient<$Types.GetResult<BlacklistedTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BlacklistedToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenFindFirstOrThrowArgs} args - Arguments to find a BlacklistedToken
     * @example
     * // Get one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BlacklistedTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlacklistedTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BlacklistedTokenClient<$Types.GetResult<BlacklistedTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BlacklistedTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlacklistedTokens
     * const blacklistedTokens = await prisma.blacklistedToken.findMany()
     * 
     * // Get first 10 BlacklistedTokens
     * const blacklistedTokens = await prisma.blacklistedToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blacklistedTokenWithIdOnly = await prisma.blacklistedToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BlacklistedTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlacklistedTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BlacklistedTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BlacklistedToken.
     * @param {BlacklistedTokenCreateArgs} args - Arguments to create a BlacklistedToken.
     * @example
     * // Create one BlacklistedToken
     * const BlacklistedToken = await prisma.blacklistedToken.create({
     *   data: {
     *     // ... data to create a BlacklistedToken
     *   }
     * })
     * 
    **/
    create<T extends BlacklistedTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BlacklistedTokenCreateArgs<ExtArgs>>
    ): Prisma__BlacklistedTokenClient<$Types.GetResult<BlacklistedTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BlacklistedTokens.
     *     @param {BlacklistedTokenCreateManyArgs} args - Arguments to create many BlacklistedTokens.
     *     @example
     *     // Create many BlacklistedTokens
     *     const blacklistedToken = await prisma.blacklistedToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlacklistedTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlacklistedTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BlacklistedToken.
     * @param {BlacklistedTokenDeleteArgs} args - Arguments to delete one BlacklistedToken.
     * @example
     * // Delete one BlacklistedToken
     * const BlacklistedToken = await prisma.blacklistedToken.delete({
     *   where: {
     *     // ... filter to delete one BlacklistedToken
     *   }
     * })
     * 
    **/
    delete<T extends BlacklistedTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BlacklistedTokenDeleteArgs<ExtArgs>>
    ): Prisma__BlacklistedTokenClient<$Types.GetResult<BlacklistedTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BlacklistedToken.
     * @param {BlacklistedTokenUpdateArgs} args - Arguments to update one BlacklistedToken.
     * @example
     * // Update one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlacklistedTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BlacklistedTokenUpdateArgs<ExtArgs>>
    ): Prisma__BlacklistedTokenClient<$Types.GetResult<BlacklistedTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BlacklistedTokens.
     * @param {BlacklistedTokenDeleteManyArgs} args - Arguments to filter BlacklistedTokens to delete.
     * @example
     * // Delete a few BlacklistedTokens
     * const { count } = await prisma.blacklistedToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlacklistedTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlacklistedTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlacklistedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlacklistedTokens
     * const blacklistedToken = await prisma.blacklistedToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlacklistedTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BlacklistedTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlacklistedToken.
     * @param {BlacklistedTokenUpsertArgs} args - Arguments to update or create a BlacklistedToken.
     * @example
     * // Update or create a BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.upsert({
     *   create: {
     *     // ... data to create a BlacklistedToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlacklistedToken we want to update
     *   }
     * })
    **/
    upsert<T extends BlacklistedTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BlacklistedTokenUpsertArgs<ExtArgs>>
    ): Prisma__BlacklistedTokenClient<$Types.GetResult<BlacklistedTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BlacklistedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenCountArgs} args - Arguments to filter BlacklistedTokens to count.
     * @example
     * // Count the number of BlacklistedTokens
     * const count = await prisma.blacklistedToken.count({
     *   where: {
     *     // ... the filter for the BlacklistedTokens we want to count
     *   }
     * })
    **/
    count<T extends BlacklistedTokenCountArgs>(
      args?: Subset<T, BlacklistedTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlacklistedTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlacklistedToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlacklistedTokenAggregateArgs>(args: Subset<T, BlacklistedTokenAggregateArgs>): Prisma.PrismaPromise<GetBlacklistedTokenAggregateType<T>>

    /**
     * Group by BlacklistedToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlacklistedTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlacklistedTokenGroupByArgs['orderBy'] }
        : { orderBy?: BlacklistedTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlacklistedTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlacklistedTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlacklistedToken model
   */
  readonly fields: BlacklistedTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlacklistedToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BlacklistedTokenClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the BlacklistedToken model
   */ 
  interface BlacklistedTokenFieldRefs {
    readonly id: FieldRef<"BlacklistedToken", 'Int'>
    readonly token: FieldRef<"BlacklistedToken", 'String'>
    readonly createdat: FieldRef<"BlacklistedToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * BlacklistedToken findUnique
   */
  export type BlacklistedTokenFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Filter, which BlacklistedToken to fetch.
     */
    where: BlacklistedTokenWhereUniqueInput
  }


  /**
   * BlacklistedToken findUniqueOrThrow
   */
  export type BlacklistedTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Filter, which BlacklistedToken to fetch.
     */
    where: BlacklistedTokenWhereUniqueInput
  }


  /**
   * BlacklistedToken findFirst
   */
  export type BlacklistedTokenFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Filter, which BlacklistedToken to fetch.
     */
    where?: BlacklistedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistedTokens to fetch.
     */
    orderBy?: BlacklistedTokenOrderByWithRelationInput | BlacklistedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlacklistedTokens.
     */
    cursor?: BlacklistedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlacklistedTokens.
     */
    distinct?: BlacklistedTokenScalarFieldEnum | BlacklistedTokenScalarFieldEnum[]
  }


  /**
   * BlacklistedToken findFirstOrThrow
   */
  export type BlacklistedTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Filter, which BlacklistedToken to fetch.
     */
    where?: BlacklistedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistedTokens to fetch.
     */
    orderBy?: BlacklistedTokenOrderByWithRelationInput | BlacklistedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlacklistedTokens.
     */
    cursor?: BlacklistedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlacklistedTokens.
     */
    distinct?: BlacklistedTokenScalarFieldEnum | BlacklistedTokenScalarFieldEnum[]
  }


  /**
   * BlacklistedToken findMany
   */
  export type BlacklistedTokenFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Filter, which BlacklistedTokens to fetch.
     */
    where?: BlacklistedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistedTokens to fetch.
     */
    orderBy?: BlacklistedTokenOrderByWithRelationInput | BlacklistedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlacklistedTokens.
     */
    cursor?: BlacklistedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistedTokens.
     */
    skip?: number
    distinct?: BlacklistedTokenScalarFieldEnum | BlacklistedTokenScalarFieldEnum[]
  }


  /**
   * BlacklistedToken create
   */
  export type BlacklistedTokenCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a BlacklistedToken.
     */
    data: XOR<BlacklistedTokenCreateInput, BlacklistedTokenUncheckedCreateInput>
  }


  /**
   * BlacklistedToken createMany
   */
  export type BlacklistedTokenCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlacklistedTokens.
     */
    data: BlacklistedTokenCreateManyInput | BlacklistedTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BlacklistedToken update
   */
  export type BlacklistedTokenUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a BlacklistedToken.
     */
    data: XOR<BlacklistedTokenUpdateInput, BlacklistedTokenUncheckedUpdateInput>
    /**
     * Choose, which BlacklistedToken to update.
     */
    where: BlacklistedTokenWhereUniqueInput
  }


  /**
   * BlacklistedToken updateMany
   */
  export type BlacklistedTokenUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlacklistedTokens.
     */
    data: XOR<BlacklistedTokenUpdateManyMutationInput, BlacklistedTokenUncheckedUpdateManyInput>
    /**
     * Filter which BlacklistedTokens to update
     */
    where?: BlacklistedTokenWhereInput
  }


  /**
   * BlacklistedToken upsert
   */
  export type BlacklistedTokenUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the BlacklistedToken to update in case it exists.
     */
    where: BlacklistedTokenWhereUniqueInput
    /**
     * In case the BlacklistedToken found by the `where` argument doesn't exist, create a new BlacklistedToken with this data.
     */
    create: XOR<BlacklistedTokenCreateInput, BlacklistedTokenUncheckedCreateInput>
    /**
     * In case the BlacklistedToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlacklistedTokenUpdateInput, BlacklistedTokenUncheckedUpdateInput>
  }


  /**
   * BlacklistedToken delete
   */
  export type BlacklistedTokenDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Filter which BlacklistedToken to delete.
     */
    where: BlacklistedTokenWhereUniqueInput
  }


  /**
   * BlacklistedToken deleteMany
   */
  export type BlacklistedTokenDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlacklistedTokens to delete
     */
    where?: BlacklistedTokenWhereInput
  }


  /**
   * BlacklistedToken without action
   */
  export type BlacklistedTokenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
  }



  /**
   * Model UsersTBL
   */


  export type AggregateUsersTBL = {
    _count: UsersTBLCountAggregateOutputType | null
    _avg: UsersTBLAvgAggregateOutputType | null
    _sum: UsersTBLSumAggregateOutputType | null
    _min: UsersTBLMinAggregateOutputType | null
    _max: UsersTBLMaxAggregateOutputType | null
  }

  export type UsersTBLAvgAggregateOutputType = {
    userid: number | null
  }

  export type UsersTBLSumAggregateOutputType = {
    userid: number | null
  }

  export type UsersTBLMinAggregateOutputType = {
    userid: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    role: string | null
  }

  export type UsersTBLMaxAggregateOutputType = {
    userid: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    role: string | null
  }

  export type UsersTBLCountAggregateOutputType = {
    userid: number
    firstname: number
    lastname: number
    email: number
    password: number
    role: number
    _all: number
  }


  export type UsersTBLAvgAggregateInputType = {
    userid?: true
  }

  export type UsersTBLSumAggregateInputType = {
    userid?: true
  }

  export type UsersTBLMinAggregateInputType = {
    userid?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    role?: true
  }

  export type UsersTBLMaxAggregateInputType = {
    userid?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    role?: true
  }

  export type UsersTBLCountAggregateInputType = {
    userid?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    role?: true
    _all?: true
  }

  export type UsersTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersTBL to aggregate.
     */
    where?: UsersTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersTBLS to fetch.
     */
    orderBy?: UsersTBLOrderByWithRelationInput | UsersTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersTBLS
    **/
    _count?: true | UsersTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersTBLMaxAggregateInputType
  }

  export type GetUsersTBLAggregateType<T extends UsersTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersTBL[P]>
      : GetScalarType<T[P], AggregateUsersTBL[P]>
  }




  export type UsersTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UsersTBLWhereInput
    orderBy?: UsersTBLOrderByWithAggregationInput | UsersTBLOrderByWithAggregationInput[]
    by: UsersTBLScalarFieldEnum[] | UsersTBLScalarFieldEnum
    having?: UsersTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersTBLCountAggregateInputType | true
    _avg?: UsersTBLAvgAggregateInputType
    _sum?: UsersTBLSumAggregateInputType
    _min?: UsersTBLMinAggregateInputType
    _max?: UsersTBLMaxAggregateInputType
  }


  export type UsersTBLGroupByOutputType = {
    userid: number
    firstname: string
    lastname: string
    email: string
    password: string
    role: string
    _count: UsersTBLCountAggregateOutputType | null
    _avg: UsersTBLAvgAggregateOutputType | null
    _sum: UsersTBLSumAggregateOutputType | null
    _min: UsersTBLMinAggregateOutputType | null
    _max: UsersTBLMaxAggregateOutputType | null
  }

  type GetUsersTBLGroupByPayload<T extends UsersTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersTBLGroupByOutputType[P]>
            : GetScalarType<T[P], UsersTBLGroupByOutputType[P]>
        }
      >
    >


  export type UsersTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    Employee?: boolean | UsersTBL$EmployeeArgs<ExtArgs>
    Items?: boolean | UsersTBL$ItemsArgs<ExtArgs>
    Tokens?: boolean | UsersTBL$TokensArgs<ExtArgs>
    Officeboy?: boolean | UsersTBL$OfficeboyArgs<ExtArgs>
    _count?: boolean | UsersTBLCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["usersTBL"]>

  export type UsersTBLSelectScalar = {
    userid?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
  }

  export type UsersTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Employee?: boolean | UsersTBL$EmployeeArgs<ExtArgs>
    Items?: boolean | UsersTBL$ItemsArgs<ExtArgs>
    Tokens?: boolean | UsersTBL$TokensArgs<ExtArgs>
    Officeboy?: boolean | UsersTBL$OfficeboyArgs<ExtArgs>
    _count?: boolean | UsersTBLCountOutputTypeArgs<ExtArgs>
  }


  type UsersTBLGetPayload<S extends boolean | null | undefined | UsersTBLArgs> = $Types.GetResult<UsersTBLPayload, S>

  type UsersTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UsersTBLFindManyArgs, 'select' | 'include'> & {
      select?: UsersTBLCountAggregateInputType | true
    }

  export interface UsersTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsersTBL'], meta: { name: 'UsersTBL' } }
    /**
     * Find zero or one UsersTBL that matches the filter.
     * @param {UsersTBLFindUniqueArgs} args - Arguments to find a UsersTBL
     * @example
     * // Get one UsersTBL
     * const usersTBL = await prisma.usersTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsersTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsersTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__UsersTBLClient<$Types.GetResult<UsersTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UsersTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsersTBLFindUniqueOrThrowArgs} args - Arguments to find a UsersTBL
     * @example
     * // Get one UsersTBL
     * const usersTBL = await prisma.usersTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsersTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsersTBLClient<$Types.GetResult<UsersTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UsersTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersTBLFindFirstArgs} args - Arguments to find a UsersTBL
     * @example
     * // Get one UsersTBL
     * const usersTBL = await prisma.usersTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsersTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersTBLFindFirstArgs<ExtArgs>>
    ): Prisma__UsersTBLClient<$Types.GetResult<UsersTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UsersTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersTBLFindFirstOrThrowArgs} args - Arguments to find a UsersTBL
     * @example
     * // Get one UsersTBL
     * const usersTBL = await prisma.usersTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsersTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsersTBLClient<$Types.GetResult<UsersTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UsersTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersTBLS
     * const usersTBLS = await prisma.usersTBL.findMany()
     * 
     * // Get first 10 UsersTBLS
     * const usersTBLS = await prisma.usersTBL.findMany({ take: 10 })
     * 
     * // Only select the `userid`
     * const usersTBLWithUseridOnly = await prisma.usersTBL.findMany({ select: { userid: true } })
     * 
    **/
    findMany<T extends UsersTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UsersTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UsersTBL.
     * @param {UsersTBLCreateArgs} args - Arguments to create a UsersTBL.
     * @example
     * // Create one UsersTBL
     * const UsersTBL = await prisma.usersTBL.create({
     *   data: {
     *     // ... data to create a UsersTBL
     *   }
     * })
     * 
    **/
    create<T extends UsersTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersTBLCreateArgs<ExtArgs>>
    ): Prisma__UsersTBLClient<$Types.GetResult<UsersTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UsersTBLS.
     *     @param {UsersTBLCreateManyArgs} args - Arguments to create many UsersTBLS.
     *     @example
     *     // Create many UsersTBLS
     *     const usersTBL = await prisma.usersTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsersTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsersTBL.
     * @param {UsersTBLDeleteArgs} args - Arguments to delete one UsersTBL.
     * @example
     * // Delete one UsersTBL
     * const UsersTBL = await prisma.usersTBL.delete({
     *   where: {
     *     // ... filter to delete one UsersTBL
     *   }
     * })
     * 
    **/
    delete<T extends UsersTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsersTBLDeleteArgs<ExtArgs>>
    ): Prisma__UsersTBLClient<$Types.GetResult<UsersTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UsersTBL.
     * @param {UsersTBLUpdateArgs} args - Arguments to update one UsersTBL.
     * @example
     * // Update one UsersTBL
     * const usersTBL = await prisma.usersTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsersTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersTBLUpdateArgs<ExtArgs>>
    ): Prisma__UsersTBLClient<$Types.GetResult<UsersTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UsersTBLS.
     * @param {UsersTBLDeleteManyArgs} args - Arguments to filter UsersTBLS to delete.
     * @example
     * // Delete a few UsersTBLS
     * const { count } = await prisma.usersTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsersTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersTBLS
     * const usersTBL = await prisma.usersTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsersTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsersTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersTBL.
     * @param {UsersTBLUpsertArgs} args - Arguments to update or create a UsersTBL.
     * @example
     * // Update or create a UsersTBL
     * const usersTBL = await prisma.usersTBL.upsert({
     *   create: {
     *     // ... data to create a UsersTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersTBL we want to update
     *   }
     * })
    **/
    upsert<T extends UsersTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsersTBLUpsertArgs<ExtArgs>>
    ): Prisma__UsersTBLClient<$Types.GetResult<UsersTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UsersTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersTBLCountArgs} args - Arguments to filter UsersTBLS to count.
     * @example
     * // Count the number of UsersTBLS
     * const count = await prisma.usersTBL.count({
     *   where: {
     *     // ... the filter for the UsersTBLS we want to count
     *   }
     * })
    **/
    count<T extends UsersTBLCountArgs>(
      args?: Subset<T, UsersTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersTBLAggregateArgs>(args: Subset<T, UsersTBLAggregateArgs>): Prisma.PrismaPromise<GetUsersTBLAggregateType<T>>

    /**
     * Group by UsersTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersTBLGroupByArgs['orderBy'] }
        : { orderBy?: UsersTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsersTBL model
   */
  readonly fields: UsersTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsersTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Employee<T extends UsersTBL$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, UsersTBL$EmployeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    Items<T extends UsersTBL$ItemsArgs<ExtArgs> = {}>(args?: Subset<T, UsersTBL$ItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ItemsTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    Tokens<T extends UsersTBL$TokensArgs<ExtArgs> = {}>(args?: Subset<T, UsersTBL$TokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TokensTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    Officeboy<T extends UsersTBL$OfficeboyArgs<ExtArgs> = {}>(args?: Subset<T, UsersTBL$OfficeboyArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OfficeBoyTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the UsersTBL model
   */ 
  interface UsersTBLFieldRefs {
    readonly userid: FieldRef<"UsersTBL", 'Int'>
    readonly firstname: FieldRef<"UsersTBL", 'String'>
    readonly lastname: FieldRef<"UsersTBL", 'String'>
    readonly email: FieldRef<"UsersTBL", 'String'>
    readonly password: FieldRef<"UsersTBL", 'String'>
    readonly role: FieldRef<"UsersTBL", 'String'>
  }
    

  // Custom InputTypes

  /**
   * UsersTBL findUnique
   */
  export type UsersTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersTBL
     */
    select?: UsersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersTBLInclude<ExtArgs> | null
    /**
     * Filter, which UsersTBL to fetch.
     */
    where: UsersTBLWhereUniqueInput
  }


  /**
   * UsersTBL findUniqueOrThrow
   */
  export type UsersTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersTBL
     */
    select?: UsersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersTBLInclude<ExtArgs> | null
    /**
     * Filter, which UsersTBL to fetch.
     */
    where: UsersTBLWhereUniqueInput
  }


  /**
   * UsersTBL findFirst
   */
  export type UsersTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersTBL
     */
    select?: UsersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersTBLInclude<ExtArgs> | null
    /**
     * Filter, which UsersTBL to fetch.
     */
    where?: UsersTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersTBLS to fetch.
     */
    orderBy?: UsersTBLOrderByWithRelationInput | UsersTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersTBLS.
     */
    cursor?: UsersTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersTBLS.
     */
    distinct?: UsersTBLScalarFieldEnum | UsersTBLScalarFieldEnum[]
  }


  /**
   * UsersTBL findFirstOrThrow
   */
  export type UsersTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersTBL
     */
    select?: UsersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersTBLInclude<ExtArgs> | null
    /**
     * Filter, which UsersTBL to fetch.
     */
    where?: UsersTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersTBLS to fetch.
     */
    orderBy?: UsersTBLOrderByWithRelationInput | UsersTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersTBLS.
     */
    cursor?: UsersTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersTBLS.
     */
    distinct?: UsersTBLScalarFieldEnum | UsersTBLScalarFieldEnum[]
  }


  /**
   * UsersTBL findMany
   */
  export type UsersTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersTBL
     */
    select?: UsersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersTBLInclude<ExtArgs> | null
    /**
     * Filter, which UsersTBLS to fetch.
     */
    where?: UsersTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersTBLS to fetch.
     */
    orderBy?: UsersTBLOrderByWithRelationInput | UsersTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersTBLS.
     */
    cursor?: UsersTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersTBLS.
     */
    skip?: number
    distinct?: UsersTBLScalarFieldEnum | UsersTBLScalarFieldEnum[]
  }


  /**
   * UsersTBL create
   */
  export type UsersTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersTBL
     */
    select?: UsersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a UsersTBL.
     */
    data: XOR<UsersTBLCreateInput, UsersTBLUncheckedCreateInput>
  }


  /**
   * UsersTBL createMany
   */
  export type UsersTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsersTBLS.
     */
    data: UsersTBLCreateManyInput | UsersTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UsersTBL update
   */
  export type UsersTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersTBL
     */
    select?: UsersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a UsersTBL.
     */
    data: XOR<UsersTBLUpdateInput, UsersTBLUncheckedUpdateInput>
    /**
     * Choose, which UsersTBL to update.
     */
    where: UsersTBLWhereUniqueInput
  }


  /**
   * UsersTBL updateMany
   */
  export type UsersTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsersTBLS.
     */
    data: XOR<UsersTBLUpdateManyMutationInput, UsersTBLUncheckedUpdateManyInput>
    /**
     * Filter which UsersTBLS to update
     */
    where?: UsersTBLWhereInput
  }


  /**
   * UsersTBL upsert
   */
  export type UsersTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersTBL
     */
    select?: UsersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the UsersTBL to update in case it exists.
     */
    where: UsersTBLWhereUniqueInput
    /**
     * In case the UsersTBL found by the `where` argument doesn't exist, create a new UsersTBL with this data.
     */
    create: XOR<UsersTBLCreateInput, UsersTBLUncheckedCreateInput>
    /**
     * In case the UsersTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersTBLUpdateInput, UsersTBLUncheckedUpdateInput>
  }


  /**
   * UsersTBL delete
   */
  export type UsersTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersTBL
     */
    select?: UsersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersTBLInclude<ExtArgs> | null
    /**
     * Filter which UsersTBL to delete.
     */
    where: UsersTBLWhereUniqueInput
  }


  /**
   * UsersTBL deleteMany
   */
  export type UsersTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersTBLS to delete
     */
    where?: UsersTBLWhereInput
  }


  /**
   * UsersTBL.Employee
   */
  export type UsersTBL$EmployeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    where?: EmployeeTBLWhereInput
    orderBy?: EmployeeTBLOrderByWithRelationInput | EmployeeTBLOrderByWithRelationInput[]
    cursor?: EmployeeTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTBLScalarFieldEnum | EmployeeTBLScalarFieldEnum[]
  }


  /**
   * UsersTBL.Items
   */
  export type UsersTBL$ItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsTBL
     */
    select?: ItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsTBLInclude<ExtArgs> | null
    where?: ItemsTBLWhereInput
    orderBy?: ItemsTBLOrderByWithRelationInput | ItemsTBLOrderByWithRelationInput[]
    cursor?: ItemsTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsTBLScalarFieldEnum | ItemsTBLScalarFieldEnum[]
  }


  /**
   * UsersTBL.Tokens
   */
  export type UsersTBL$TokensArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokensTBL
     */
    select?: TokensTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokensTBLInclude<ExtArgs> | null
    where?: TokensTBLWhereInput
    orderBy?: TokensTBLOrderByWithRelationInput | TokensTBLOrderByWithRelationInput[]
    cursor?: TokensTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokensTBLScalarFieldEnum | TokensTBLScalarFieldEnum[]
  }


  /**
   * UsersTBL.Officeboy
   */
  export type UsersTBL$OfficeboyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeBoyTBL
     */
    select?: OfficeBoyTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeBoyTBLInclude<ExtArgs> | null
    where?: OfficeBoyTBLWhereInput
    orderBy?: OfficeBoyTBLOrderByWithRelationInput | OfficeBoyTBLOrderByWithRelationInput[]
    cursor?: OfficeBoyTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfficeBoyTBLScalarFieldEnum | OfficeBoyTBLScalarFieldEnum[]
  }


  /**
   * UsersTBL without action
   */
  export type UsersTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersTBL
     */
    select?: UsersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersTBLInclude<ExtArgs> | null
  }



  /**
   * Model EmployeeTBL
   */


  export type AggregateEmployeeTBL = {
    _count: EmployeeTBLCountAggregateOutputType | null
    _avg: EmployeeTBLAvgAggregateOutputType | null
    _sum: EmployeeTBLSumAggregateOutputType | null
    _min: EmployeeTBLMinAggregateOutputType | null
    _max: EmployeeTBLMaxAggregateOutputType | null
  }

  export type EmployeeTBLAvgAggregateOutputType = {
    empid: number | null
    roomid: number | null
    officeid: number | null
    siteid: number | null
    buildingid: number | null
    departmentid: number | null
  }

  export type EmployeeTBLSumAggregateOutputType = {
    empid: number | null
    roomid: number | null
    officeid: number | null
    siteid: number | null
    buildingid: number | null
    departmentid: number | null
  }

  export type EmployeeTBLMinAggregateOutputType = {
    empid: number | null
    roomid: number | null
    officeid: number | null
    siteid: number | null
    buildingid: number | null
    departmentid: number | null
  }

  export type EmployeeTBLMaxAggregateOutputType = {
    empid: number | null
    roomid: number | null
    officeid: number | null
    siteid: number | null
    buildingid: number | null
    departmentid: number | null
  }

  export type EmployeeTBLCountAggregateOutputType = {
    empid: number
    roomid: number
    officeid: number
    siteid: number
    buildingid: number
    departmentid: number
    _all: number
  }


  export type EmployeeTBLAvgAggregateInputType = {
    empid?: true
    roomid?: true
    officeid?: true
    siteid?: true
    buildingid?: true
    departmentid?: true
  }

  export type EmployeeTBLSumAggregateInputType = {
    empid?: true
    roomid?: true
    officeid?: true
    siteid?: true
    buildingid?: true
    departmentid?: true
  }

  export type EmployeeTBLMinAggregateInputType = {
    empid?: true
    roomid?: true
    officeid?: true
    siteid?: true
    buildingid?: true
    departmentid?: true
  }

  export type EmployeeTBLMaxAggregateInputType = {
    empid?: true
    roomid?: true
    officeid?: true
    siteid?: true
    buildingid?: true
    departmentid?: true
  }

  export type EmployeeTBLCountAggregateInputType = {
    empid?: true
    roomid?: true
    officeid?: true
    siteid?: true
    buildingid?: true
    departmentid?: true
    _all?: true
  }

  export type EmployeeTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeTBL to aggregate.
     */
    where?: EmployeeTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeTBLS to fetch.
     */
    orderBy?: EmployeeTBLOrderByWithRelationInput | EmployeeTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeTBLS
    **/
    _count?: true | EmployeeTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeTBLMaxAggregateInputType
  }

  export type GetEmployeeTBLAggregateType<T extends EmployeeTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeTBL[P]>
      : GetScalarType<T[P], AggregateEmployeeTBL[P]>
  }




  export type EmployeeTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EmployeeTBLWhereInput
    orderBy?: EmployeeTBLOrderByWithAggregationInput | EmployeeTBLOrderByWithAggregationInput[]
    by: EmployeeTBLScalarFieldEnum[] | EmployeeTBLScalarFieldEnum
    having?: EmployeeTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeTBLCountAggregateInputType | true
    _avg?: EmployeeTBLAvgAggregateInputType
    _sum?: EmployeeTBLSumAggregateInputType
    _min?: EmployeeTBLMinAggregateInputType
    _max?: EmployeeTBLMaxAggregateInputType
  }


  export type EmployeeTBLGroupByOutputType = {
    empid: number
    roomid: number
    officeid: number
    siteid: number
    buildingid: number
    departmentid: number
    _count: EmployeeTBLCountAggregateOutputType | null
    _avg: EmployeeTBLAvgAggregateOutputType | null
    _sum: EmployeeTBLSumAggregateOutputType | null
    _min: EmployeeTBLMinAggregateOutputType | null
    _max: EmployeeTBLMaxAggregateOutputType | null
  }

  type GetEmployeeTBLGroupByPayload<T extends EmployeeTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeTBLGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeTBLGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    empid?: boolean
    roomid?: boolean
    officeid?: boolean
    siteid?: boolean
    buildingid?: boolean
    departmentid?: boolean
    emp?: boolean | UsersTBLArgs<ExtArgs>
    romid?: boolean | RoomTBLArgs<ExtArgs>
    offid?: boolean | OfficeTBLArgs<ExtArgs>
    sitid?: boolean | SiteTBLArgs<ExtArgs>
    bulidingref?: boolean | BuildingTBLArgs<ExtArgs>
    departmentref?: boolean | DepartmentTBLArgs<ExtArgs>
    Cart?: boolean | EmployeeTBL$CartArgs<ExtArgs>
    OrdersTBL?: boolean | EmployeeTBL$OrdersTBLArgs<ExtArgs>
    _count?: boolean | EmployeeTBLCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["employeeTBL"]>

  export type EmployeeTBLSelectScalar = {
    empid?: boolean
    roomid?: boolean
    officeid?: boolean
    siteid?: boolean
    buildingid?: boolean
    departmentid?: boolean
  }

  export type EmployeeTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    emp?: boolean | UsersTBLArgs<ExtArgs>
    romid?: boolean | RoomTBLArgs<ExtArgs>
    offid?: boolean | OfficeTBLArgs<ExtArgs>
    sitid?: boolean | SiteTBLArgs<ExtArgs>
    bulidingref?: boolean | BuildingTBLArgs<ExtArgs>
    departmentref?: boolean | DepartmentTBLArgs<ExtArgs>
    Cart?: boolean | EmployeeTBL$CartArgs<ExtArgs>
    OrdersTBL?: boolean | EmployeeTBL$OrdersTBLArgs<ExtArgs>
    _count?: boolean | EmployeeTBLCountOutputTypeArgs<ExtArgs>
  }


  type EmployeeTBLGetPayload<S extends boolean | null | undefined | EmployeeTBLArgs> = $Types.GetResult<EmployeeTBLPayload, S>

  type EmployeeTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EmployeeTBLFindManyArgs, 'select' | 'include'> & {
      select?: EmployeeTBLCountAggregateInputType | true
    }

  export interface EmployeeTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeTBL'], meta: { name: 'EmployeeTBL' } }
    /**
     * Find zero or one EmployeeTBL that matches the filter.
     * @param {EmployeeTBLFindUniqueArgs} args - Arguments to find a EmployeeTBL
     * @example
     * // Get one EmployeeTBL
     * const employeeTBL = await prisma.employeeTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmployeeTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmployeeTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__EmployeeTBLClient<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmployeeTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmployeeTBLFindUniqueOrThrowArgs} args - Arguments to find a EmployeeTBL
     * @example
     * // Get one EmployeeTBL
     * const employeeTBL = await prisma.employeeTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmployeeTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmployeeTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmployeeTBLClient<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmployeeTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTBLFindFirstArgs} args - Arguments to find a EmployeeTBL
     * @example
     * // Get one EmployeeTBL
     * const employeeTBL = await prisma.employeeTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmployeeTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmployeeTBLFindFirstArgs<ExtArgs>>
    ): Prisma__EmployeeTBLClient<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmployeeTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTBLFindFirstOrThrowArgs} args - Arguments to find a EmployeeTBL
     * @example
     * // Get one EmployeeTBL
     * const employeeTBL = await prisma.employeeTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmployeeTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmployeeTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmployeeTBLClient<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmployeeTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeTBLS
     * const employeeTBLS = await prisma.employeeTBL.findMany()
     * 
     * // Get first 10 EmployeeTBLS
     * const employeeTBLS = await prisma.employeeTBL.findMany({ take: 10 })
     * 
     * // Only select the `empid`
     * const employeeTBLWithEmpidOnly = await prisma.employeeTBL.findMany({ select: { empid: true } })
     * 
    **/
    findMany<T extends EmployeeTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmployeeTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmployeeTBL.
     * @param {EmployeeTBLCreateArgs} args - Arguments to create a EmployeeTBL.
     * @example
     * // Create one EmployeeTBL
     * const EmployeeTBL = await prisma.employeeTBL.create({
     *   data: {
     *     // ... data to create a EmployeeTBL
     *   }
     * })
     * 
    **/
    create<T extends EmployeeTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmployeeTBLCreateArgs<ExtArgs>>
    ): Prisma__EmployeeTBLClient<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmployeeTBLS.
     *     @param {EmployeeTBLCreateManyArgs} args - Arguments to create many EmployeeTBLS.
     *     @example
     *     // Create many EmployeeTBLS
     *     const employeeTBL = await prisma.employeeTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmployeeTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmployeeTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeTBL.
     * @param {EmployeeTBLDeleteArgs} args - Arguments to delete one EmployeeTBL.
     * @example
     * // Delete one EmployeeTBL
     * const EmployeeTBL = await prisma.employeeTBL.delete({
     *   where: {
     *     // ... filter to delete one EmployeeTBL
     *   }
     * })
     * 
    **/
    delete<T extends EmployeeTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmployeeTBLDeleteArgs<ExtArgs>>
    ): Prisma__EmployeeTBLClient<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmployeeTBL.
     * @param {EmployeeTBLUpdateArgs} args - Arguments to update one EmployeeTBL.
     * @example
     * // Update one EmployeeTBL
     * const employeeTBL = await prisma.employeeTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmployeeTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmployeeTBLUpdateArgs<ExtArgs>>
    ): Prisma__EmployeeTBLClient<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmployeeTBLS.
     * @param {EmployeeTBLDeleteManyArgs} args - Arguments to filter EmployeeTBLS to delete.
     * @example
     * // Delete a few EmployeeTBLS
     * const { count } = await prisma.employeeTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmployeeTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmployeeTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeTBLS
     * const employeeTBL = await prisma.employeeTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmployeeTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmployeeTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeTBL.
     * @param {EmployeeTBLUpsertArgs} args - Arguments to update or create a EmployeeTBL.
     * @example
     * // Update or create a EmployeeTBL
     * const employeeTBL = await prisma.employeeTBL.upsert({
     *   create: {
     *     // ... data to create a EmployeeTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeTBL we want to update
     *   }
     * })
    **/
    upsert<T extends EmployeeTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmployeeTBLUpsertArgs<ExtArgs>>
    ): Prisma__EmployeeTBLClient<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmployeeTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTBLCountArgs} args - Arguments to filter EmployeeTBLS to count.
     * @example
     * // Count the number of EmployeeTBLS
     * const count = await prisma.employeeTBL.count({
     *   where: {
     *     // ... the filter for the EmployeeTBLS we want to count
     *   }
     * })
    **/
    count<T extends EmployeeTBLCountArgs>(
      args?: Subset<T, EmployeeTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeTBLAggregateArgs>(args: Subset<T, EmployeeTBLAggregateArgs>): Prisma.PrismaPromise<GetEmployeeTBLAggregateType<T>>

    /**
     * Group by EmployeeTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeTBLGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeTBL model
   */
  readonly fields: EmployeeTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EmployeeTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    emp<T extends UsersTBLArgs<ExtArgs> = {}>(args?: Subset<T, UsersTBLArgs<ExtArgs>>): Prisma__UsersTBLClient<$Types.GetResult<UsersTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    romid<T extends RoomTBLArgs<ExtArgs> = {}>(args?: Subset<T, RoomTBLArgs<ExtArgs>>): Prisma__RoomTBLClient<$Types.GetResult<RoomTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    offid<T extends OfficeTBLArgs<ExtArgs> = {}>(args?: Subset<T, OfficeTBLArgs<ExtArgs>>): Prisma__OfficeTBLClient<$Types.GetResult<OfficeTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    sitid<T extends SiteTBLArgs<ExtArgs> = {}>(args?: Subset<T, SiteTBLArgs<ExtArgs>>): Prisma__SiteTBLClient<$Types.GetResult<SiteTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    bulidingref<T extends BuildingTBLArgs<ExtArgs> = {}>(args?: Subset<T, BuildingTBLArgs<ExtArgs>>): Prisma__BuildingTBLClient<$Types.GetResult<BuildingTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    departmentref<T extends DepartmentTBLArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentTBLArgs<ExtArgs>>): Prisma__DepartmentTBLClient<$Types.GetResult<DepartmentTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    Cart<T extends EmployeeTBL$CartArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeTBL$CartArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CartTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    OrdersTBL<T extends EmployeeTBL$OrdersTBLArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeTBL$OrdersTBLArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OrdersTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the EmployeeTBL model
   */ 
  interface EmployeeTBLFieldRefs {
    readonly empid: FieldRef<"EmployeeTBL", 'Int'>
    readonly roomid: FieldRef<"EmployeeTBL", 'Int'>
    readonly officeid: FieldRef<"EmployeeTBL", 'Int'>
    readonly siteid: FieldRef<"EmployeeTBL", 'Int'>
    readonly buildingid: FieldRef<"EmployeeTBL", 'Int'>
    readonly departmentid: FieldRef<"EmployeeTBL", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EmployeeTBL findUnique
   */
  export type EmployeeTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTBL to fetch.
     */
    where: EmployeeTBLWhereUniqueInput
  }


  /**
   * EmployeeTBL findUniqueOrThrow
   */
  export type EmployeeTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTBL to fetch.
     */
    where: EmployeeTBLWhereUniqueInput
  }


  /**
   * EmployeeTBL findFirst
   */
  export type EmployeeTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTBL to fetch.
     */
    where?: EmployeeTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeTBLS to fetch.
     */
    orderBy?: EmployeeTBLOrderByWithRelationInput | EmployeeTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeTBLS.
     */
    cursor?: EmployeeTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeTBLS.
     */
    distinct?: EmployeeTBLScalarFieldEnum | EmployeeTBLScalarFieldEnum[]
  }


  /**
   * EmployeeTBL findFirstOrThrow
   */
  export type EmployeeTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTBL to fetch.
     */
    where?: EmployeeTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeTBLS to fetch.
     */
    orderBy?: EmployeeTBLOrderByWithRelationInput | EmployeeTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeTBLS.
     */
    cursor?: EmployeeTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeTBLS.
     */
    distinct?: EmployeeTBLScalarFieldEnum | EmployeeTBLScalarFieldEnum[]
  }


  /**
   * EmployeeTBL findMany
   */
  export type EmployeeTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTBLS to fetch.
     */
    where?: EmployeeTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeTBLS to fetch.
     */
    orderBy?: EmployeeTBLOrderByWithRelationInput | EmployeeTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeTBLS.
     */
    cursor?: EmployeeTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeTBLS.
     */
    skip?: number
    distinct?: EmployeeTBLScalarFieldEnum | EmployeeTBLScalarFieldEnum[]
  }


  /**
   * EmployeeTBL create
   */
  export type EmployeeTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeTBL.
     */
    data: XOR<EmployeeTBLCreateInput, EmployeeTBLUncheckedCreateInput>
  }


  /**
   * EmployeeTBL createMany
   */
  export type EmployeeTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeTBLS.
     */
    data: EmployeeTBLCreateManyInput | EmployeeTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmployeeTBL update
   */
  export type EmployeeTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeTBL.
     */
    data: XOR<EmployeeTBLUpdateInput, EmployeeTBLUncheckedUpdateInput>
    /**
     * Choose, which EmployeeTBL to update.
     */
    where: EmployeeTBLWhereUniqueInput
  }


  /**
   * EmployeeTBL updateMany
   */
  export type EmployeeTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeTBLS.
     */
    data: XOR<EmployeeTBLUpdateManyMutationInput, EmployeeTBLUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeTBLS to update
     */
    where?: EmployeeTBLWhereInput
  }


  /**
   * EmployeeTBL upsert
   */
  export type EmployeeTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeTBL to update in case it exists.
     */
    where: EmployeeTBLWhereUniqueInput
    /**
     * In case the EmployeeTBL found by the `where` argument doesn't exist, create a new EmployeeTBL with this data.
     */
    create: XOR<EmployeeTBLCreateInput, EmployeeTBLUncheckedCreateInput>
    /**
     * In case the EmployeeTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeTBLUpdateInput, EmployeeTBLUncheckedUpdateInput>
  }


  /**
   * EmployeeTBL delete
   */
  export type EmployeeTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    /**
     * Filter which EmployeeTBL to delete.
     */
    where: EmployeeTBLWhereUniqueInput
  }


  /**
   * EmployeeTBL deleteMany
   */
  export type EmployeeTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeTBLS to delete
     */
    where?: EmployeeTBLWhereInput
  }


  /**
   * EmployeeTBL.Cart
   */
  export type EmployeeTBL$CartArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartTBL
     */
    select?: CartTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartTBLInclude<ExtArgs> | null
    where?: CartTBLWhereInput
    orderBy?: CartTBLOrderByWithRelationInput | CartTBLOrderByWithRelationInput[]
    cursor?: CartTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartTBLScalarFieldEnum | CartTBLScalarFieldEnum[]
  }


  /**
   * EmployeeTBL.OrdersTBL
   */
  export type EmployeeTBL$OrdersTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersTBL
     */
    select?: OrdersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersTBLInclude<ExtArgs> | null
    where?: OrdersTBLWhereInput
    orderBy?: OrdersTBLOrderByWithRelationInput | OrdersTBLOrderByWithRelationInput[]
    cursor?: OrdersTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersTBLScalarFieldEnum | OrdersTBLScalarFieldEnum[]
  }


  /**
   * EmployeeTBL without action
   */
  export type EmployeeTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
  }



  /**
   * Model OfficeBoyTBL
   */


  export type AggregateOfficeBoyTBL = {
    _count: OfficeBoyTBLCountAggregateOutputType | null
    _avg: OfficeBoyTBLAvgAggregateOutputType | null
    _sum: OfficeBoyTBLSumAggregateOutputType | null
    _min: OfficeBoyTBLMinAggregateOutputType | null
    _max: OfficeBoyTBLMaxAggregateOutputType | null
  }

  export type OfficeBoyTBLAvgAggregateOutputType = {
    officeboyid: number | null
    officeid: number | null
    siteid: number | null
  }

  export type OfficeBoyTBLSumAggregateOutputType = {
    officeboyid: number | null
    officeid: number | null
    siteid: number | null
  }

  export type OfficeBoyTBLMinAggregateOutputType = {
    officeboyid: number | null
    officeid: number | null
    siteid: number | null
  }

  export type OfficeBoyTBLMaxAggregateOutputType = {
    officeboyid: number | null
    officeid: number | null
    siteid: number | null
  }

  export type OfficeBoyTBLCountAggregateOutputType = {
    officeboyid: number
    officeid: number
    siteid: number
    _all: number
  }


  export type OfficeBoyTBLAvgAggregateInputType = {
    officeboyid?: true
    officeid?: true
    siteid?: true
  }

  export type OfficeBoyTBLSumAggregateInputType = {
    officeboyid?: true
    officeid?: true
    siteid?: true
  }

  export type OfficeBoyTBLMinAggregateInputType = {
    officeboyid?: true
    officeid?: true
    siteid?: true
  }

  export type OfficeBoyTBLMaxAggregateInputType = {
    officeboyid?: true
    officeid?: true
    siteid?: true
  }

  export type OfficeBoyTBLCountAggregateInputType = {
    officeboyid?: true
    officeid?: true
    siteid?: true
    _all?: true
  }

  export type OfficeBoyTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfficeBoyTBL to aggregate.
     */
    where?: OfficeBoyTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfficeBoyTBLS to fetch.
     */
    orderBy?: OfficeBoyTBLOrderByWithRelationInput | OfficeBoyTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfficeBoyTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfficeBoyTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfficeBoyTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfficeBoyTBLS
    **/
    _count?: true | OfficeBoyTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfficeBoyTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfficeBoyTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfficeBoyTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfficeBoyTBLMaxAggregateInputType
  }

  export type GetOfficeBoyTBLAggregateType<T extends OfficeBoyTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateOfficeBoyTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfficeBoyTBL[P]>
      : GetScalarType<T[P], AggregateOfficeBoyTBL[P]>
  }




  export type OfficeBoyTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfficeBoyTBLWhereInput
    orderBy?: OfficeBoyTBLOrderByWithAggregationInput | OfficeBoyTBLOrderByWithAggregationInput[]
    by: OfficeBoyTBLScalarFieldEnum[] | OfficeBoyTBLScalarFieldEnum
    having?: OfficeBoyTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfficeBoyTBLCountAggregateInputType | true
    _avg?: OfficeBoyTBLAvgAggregateInputType
    _sum?: OfficeBoyTBLSumAggregateInputType
    _min?: OfficeBoyTBLMinAggregateInputType
    _max?: OfficeBoyTBLMaxAggregateInputType
  }


  export type OfficeBoyTBLGroupByOutputType = {
    officeboyid: number
    officeid: number
    siteid: number
    _count: OfficeBoyTBLCountAggregateOutputType | null
    _avg: OfficeBoyTBLAvgAggregateOutputType | null
    _sum: OfficeBoyTBLSumAggregateOutputType | null
    _min: OfficeBoyTBLMinAggregateOutputType | null
    _max: OfficeBoyTBLMaxAggregateOutputType | null
  }

  type GetOfficeBoyTBLGroupByPayload<T extends OfficeBoyTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfficeBoyTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfficeBoyTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfficeBoyTBLGroupByOutputType[P]>
            : GetScalarType<T[P], OfficeBoyTBLGroupByOutputType[P]>
        }
      >
    >


  export type OfficeBoyTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    officeboyid?: boolean
    officeid?: boolean
    siteid?: boolean
    officeboy?: boolean | UsersTBLArgs<ExtArgs>
    offid?: boolean | OfficeTBLArgs<ExtArgs>
    siteref?: boolean | SiteTBLArgs<ExtArgs>
  }, ExtArgs["result"]["officeBoyTBL"]>

  export type OfficeBoyTBLSelectScalar = {
    officeboyid?: boolean
    officeid?: boolean
    siteid?: boolean
  }

  export type OfficeBoyTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    officeboy?: boolean | UsersTBLArgs<ExtArgs>
    offid?: boolean | OfficeTBLArgs<ExtArgs>
    siteref?: boolean | SiteTBLArgs<ExtArgs>
  }


  type OfficeBoyTBLGetPayload<S extends boolean | null | undefined | OfficeBoyTBLArgs> = $Types.GetResult<OfficeBoyTBLPayload, S>

  type OfficeBoyTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OfficeBoyTBLFindManyArgs, 'select' | 'include'> & {
      select?: OfficeBoyTBLCountAggregateInputType | true
    }

  export interface OfficeBoyTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfficeBoyTBL'], meta: { name: 'OfficeBoyTBL' } }
    /**
     * Find zero or one OfficeBoyTBL that matches the filter.
     * @param {OfficeBoyTBLFindUniqueArgs} args - Arguments to find a OfficeBoyTBL
     * @example
     * // Get one OfficeBoyTBL
     * const officeBoyTBL = await prisma.officeBoyTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OfficeBoyTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OfficeBoyTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__OfficeBoyTBLClient<$Types.GetResult<OfficeBoyTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OfficeBoyTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OfficeBoyTBLFindUniqueOrThrowArgs} args - Arguments to find a OfficeBoyTBL
     * @example
     * // Get one OfficeBoyTBL
     * const officeBoyTBL = await prisma.officeBoyTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OfficeBoyTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfficeBoyTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OfficeBoyTBLClient<$Types.GetResult<OfficeBoyTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OfficeBoyTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeBoyTBLFindFirstArgs} args - Arguments to find a OfficeBoyTBL
     * @example
     * // Get one OfficeBoyTBL
     * const officeBoyTBL = await prisma.officeBoyTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OfficeBoyTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OfficeBoyTBLFindFirstArgs<ExtArgs>>
    ): Prisma__OfficeBoyTBLClient<$Types.GetResult<OfficeBoyTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OfficeBoyTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeBoyTBLFindFirstOrThrowArgs} args - Arguments to find a OfficeBoyTBL
     * @example
     * // Get one OfficeBoyTBL
     * const officeBoyTBL = await prisma.officeBoyTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OfficeBoyTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfficeBoyTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OfficeBoyTBLClient<$Types.GetResult<OfficeBoyTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OfficeBoyTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeBoyTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfficeBoyTBLS
     * const officeBoyTBLS = await prisma.officeBoyTBL.findMany()
     * 
     * // Get first 10 OfficeBoyTBLS
     * const officeBoyTBLS = await prisma.officeBoyTBL.findMany({ take: 10 })
     * 
     * // Only select the `officeboyid`
     * const officeBoyTBLWithOfficeboyidOnly = await prisma.officeBoyTBL.findMany({ select: { officeboyid: true } })
     * 
    **/
    findMany<T extends OfficeBoyTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfficeBoyTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OfficeBoyTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OfficeBoyTBL.
     * @param {OfficeBoyTBLCreateArgs} args - Arguments to create a OfficeBoyTBL.
     * @example
     * // Create one OfficeBoyTBL
     * const OfficeBoyTBL = await prisma.officeBoyTBL.create({
     *   data: {
     *     // ... data to create a OfficeBoyTBL
     *   }
     * })
     * 
    **/
    create<T extends OfficeBoyTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OfficeBoyTBLCreateArgs<ExtArgs>>
    ): Prisma__OfficeBoyTBLClient<$Types.GetResult<OfficeBoyTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OfficeBoyTBLS.
     *     @param {OfficeBoyTBLCreateManyArgs} args - Arguments to create many OfficeBoyTBLS.
     *     @example
     *     // Create many OfficeBoyTBLS
     *     const officeBoyTBL = await prisma.officeBoyTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OfficeBoyTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfficeBoyTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfficeBoyTBL.
     * @param {OfficeBoyTBLDeleteArgs} args - Arguments to delete one OfficeBoyTBL.
     * @example
     * // Delete one OfficeBoyTBL
     * const OfficeBoyTBL = await prisma.officeBoyTBL.delete({
     *   where: {
     *     // ... filter to delete one OfficeBoyTBL
     *   }
     * })
     * 
    **/
    delete<T extends OfficeBoyTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OfficeBoyTBLDeleteArgs<ExtArgs>>
    ): Prisma__OfficeBoyTBLClient<$Types.GetResult<OfficeBoyTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OfficeBoyTBL.
     * @param {OfficeBoyTBLUpdateArgs} args - Arguments to update one OfficeBoyTBL.
     * @example
     * // Update one OfficeBoyTBL
     * const officeBoyTBL = await prisma.officeBoyTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OfficeBoyTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OfficeBoyTBLUpdateArgs<ExtArgs>>
    ): Prisma__OfficeBoyTBLClient<$Types.GetResult<OfficeBoyTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OfficeBoyTBLS.
     * @param {OfficeBoyTBLDeleteManyArgs} args - Arguments to filter OfficeBoyTBLS to delete.
     * @example
     * // Delete a few OfficeBoyTBLS
     * const { count } = await prisma.officeBoyTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OfficeBoyTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfficeBoyTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfficeBoyTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeBoyTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfficeBoyTBLS
     * const officeBoyTBL = await prisma.officeBoyTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OfficeBoyTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OfficeBoyTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfficeBoyTBL.
     * @param {OfficeBoyTBLUpsertArgs} args - Arguments to update or create a OfficeBoyTBL.
     * @example
     * // Update or create a OfficeBoyTBL
     * const officeBoyTBL = await prisma.officeBoyTBL.upsert({
     *   create: {
     *     // ... data to create a OfficeBoyTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfficeBoyTBL we want to update
     *   }
     * })
    **/
    upsert<T extends OfficeBoyTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OfficeBoyTBLUpsertArgs<ExtArgs>>
    ): Prisma__OfficeBoyTBLClient<$Types.GetResult<OfficeBoyTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OfficeBoyTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeBoyTBLCountArgs} args - Arguments to filter OfficeBoyTBLS to count.
     * @example
     * // Count the number of OfficeBoyTBLS
     * const count = await prisma.officeBoyTBL.count({
     *   where: {
     *     // ... the filter for the OfficeBoyTBLS we want to count
     *   }
     * })
    **/
    count<T extends OfficeBoyTBLCountArgs>(
      args?: Subset<T, OfficeBoyTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfficeBoyTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfficeBoyTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeBoyTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfficeBoyTBLAggregateArgs>(args: Subset<T, OfficeBoyTBLAggregateArgs>): Prisma.PrismaPromise<GetOfficeBoyTBLAggregateType<T>>

    /**
     * Group by OfficeBoyTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeBoyTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfficeBoyTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfficeBoyTBLGroupByArgs['orderBy'] }
        : { orderBy?: OfficeBoyTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfficeBoyTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfficeBoyTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfficeBoyTBL model
   */
  readonly fields: OfficeBoyTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfficeBoyTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OfficeBoyTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    officeboy<T extends UsersTBLArgs<ExtArgs> = {}>(args?: Subset<T, UsersTBLArgs<ExtArgs>>): Prisma__UsersTBLClient<$Types.GetResult<UsersTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    offid<T extends OfficeTBLArgs<ExtArgs> = {}>(args?: Subset<T, OfficeTBLArgs<ExtArgs>>): Prisma__OfficeTBLClient<$Types.GetResult<OfficeTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    siteref<T extends SiteTBLArgs<ExtArgs> = {}>(args?: Subset<T, SiteTBLArgs<ExtArgs>>): Prisma__SiteTBLClient<$Types.GetResult<SiteTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the OfficeBoyTBL model
   */ 
  interface OfficeBoyTBLFieldRefs {
    readonly officeboyid: FieldRef<"OfficeBoyTBL", 'Int'>
    readonly officeid: FieldRef<"OfficeBoyTBL", 'Int'>
    readonly siteid: FieldRef<"OfficeBoyTBL", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * OfficeBoyTBL findUnique
   */
  export type OfficeBoyTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeBoyTBL
     */
    select?: OfficeBoyTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeBoyTBLInclude<ExtArgs> | null
    /**
     * Filter, which OfficeBoyTBL to fetch.
     */
    where: OfficeBoyTBLWhereUniqueInput
  }


  /**
   * OfficeBoyTBL findUniqueOrThrow
   */
  export type OfficeBoyTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeBoyTBL
     */
    select?: OfficeBoyTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeBoyTBLInclude<ExtArgs> | null
    /**
     * Filter, which OfficeBoyTBL to fetch.
     */
    where: OfficeBoyTBLWhereUniqueInput
  }


  /**
   * OfficeBoyTBL findFirst
   */
  export type OfficeBoyTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeBoyTBL
     */
    select?: OfficeBoyTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeBoyTBLInclude<ExtArgs> | null
    /**
     * Filter, which OfficeBoyTBL to fetch.
     */
    where?: OfficeBoyTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfficeBoyTBLS to fetch.
     */
    orderBy?: OfficeBoyTBLOrderByWithRelationInput | OfficeBoyTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfficeBoyTBLS.
     */
    cursor?: OfficeBoyTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfficeBoyTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfficeBoyTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfficeBoyTBLS.
     */
    distinct?: OfficeBoyTBLScalarFieldEnum | OfficeBoyTBLScalarFieldEnum[]
  }


  /**
   * OfficeBoyTBL findFirstOrThrow
   */
  export type OfficeBoyTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeBoyTBL
     */
    select?: OfficeBoyTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeBoyTBLInclude<ExtArgs> | null
    /**
     * Filter, which OfficeBoyTBL to fetch.
     */
    where?: OfficeBoyTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfficeBoyTBLS to fetch.
     */
    orderBy?: OfficeBoyTBLOrderByWithRelationInput | OfficeBoyTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfficeBoyTBLS.
     */
    cursor?: OfficeBoyTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfficeBoyTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfficeBoyTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfficeBoyTBLS.
     */
    distinct?: OfficeBoyTBLScalarFieldEnum | OfficeBoyTBLScalarFieldEnum[]
  }


  /**
   * OfficeBoyTBL findMany
   */
  export type OfficeBoyTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeBoyTBL
     */
    select?: OfficeBoyTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeBoyTBLInclude<ExtArgs> | null
    /**
     * Filter, which OfficeBoyTBLS to fetch.
     */
    where?: OfficeBoyTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfficeBoyTBLS to fetch.
     */
    orderBy?: OfficeBoyTBLOrderByWithRelationInput | OfficeBoyTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfficeBoyTBLS.
     */
    cursor?: OfficeBoyTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfficeBoyTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfficeBoyTBLS.
     */
    skip?: number
    distinct?: OfficeBoyTBLScalarFieldEnum | OfficeBoyTBLScalarFieldEnum[]
  }


  /**
   * OfficeBoyTBL create
   */
  export type OfficeBoyTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeBoyTBL
     */
    select?: OfficeBoyTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeBoyTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a OfficeBoyTBL.
     */
    data: XOR<OfficeBoyTBLCreateInput, OfficeBoyTBLUncheckedCreateInput>
  }


  /**
   * OfficeBoyTBL createMany
   */
  export type OfficeBoyTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfficeBoyTBLS.
     */
    data: OfficeBoyTBLCreateManyInput | OfficeBoyTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OfficeBoyTBL update
   */
  export type OfficeBoyTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeBoyTBL
     */
    select?: OfficeBoyTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeBoyTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a OfficeBoyTBL.
     */
    data: XOR<OfficeBoyTBLUpdateInput, OfficeBoyTBLUncheckedUpdateInput>
    /**
     * Choose, which OfficeBoyTBL to update.
     */
    where: OfficeBoyTBLWhereUniqueInput
  }


  /**
   * OfficeBoyTBL updateMany
   */
  export type OfficeBoyTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfficeBoyTBLS.
     */
    data: XOR<OfficeBoyTBLUpdateManyMutationInput, OfficeBoyTBLUncheckedUpdateManyInput>
    /**
     * Filter which OfficeBoyTBLS to update
     */
    where?: OfficeBoyTBLWhereInput
  }


  /**
   * OfficeBoyTBL upsert
   */
  export type OfficeBoyTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeBoyTBL
     */
    select?: OfficeBoyTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeBoyTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the OfficeBoyTBL to update in case it exists.
     */
    where: OfficeBoyTBLWhereUniqueInput
    /**
     * In case the OfficeBoyTBL found by the `where` argument doesn't exist, create a new OfficeBoyTBL with this data.
     */
    create: XOR<OfficeBoyTBLCreateInput, OfficeBoyTBLUncheckedCreateInput>
    /**
     * In case the OfficeBoyTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfficeBoyTBLUpdateInput, OfficeBoyTBLUncheckedUpdateInput>
  }


  /**
   * OfficeBoyTBL delete
   */
  export type OfficeBoyTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeBoyTBL
     */
    select?: OfficeBoyTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeBoyTBLInclude<ExtArgs> | null
    /**
     * Filter which OfficeBoyTBL to delete.
     */
    where: OfficeBoyTBLWhereUniqueInput
  }


  /**
   * OfficeBoyTBL deleteMany
   */
  export type OfficeBoyTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfficeBoyTBLS to delete
     */
    where?: OfficeBoyTBLWhereInput
  }


  /**
   * OfficeBoyTBL without action
   */
  export type OfficeBoyTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeBoyTBL
     */
    select?: OfficeBoyTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeBoyTBLInclude<ExtArgs> | null
  }



  /**
   * Model SiteTBL
   */


  export type AggregateSiteTBL = {
    _count: SiteTBLCountAggregateOutputType | null
    _avg: SiteTBLAvgAggregateOutputType | null
    _sum: SiteTBLSumAggregateOutputType | null
    _min: SiteTBLMinAggregateOutputType | null
    _max: SiteTBLMaxAggregateOutputType | null
  }

  export type SiteTBLAvgAggregateOutputType = {
    siteid: number | null
  }

  export type SiteTBLSumAggregateOutputType = {
    siteid: number | null
  }

  export type SiteTBLMinAggregateOutputType = {
    siteid: number | null
    sitename: string | null
  }

  export type SiteTBLMaxAggregateOutputType = {
    siteid: number | null
    sitename: string | null
  }

  export type SiteTBLCountAggregateOutputType = {
    siteid: number
    sitename: number
    _all: number
  }


  export type SiteTBLAvgAggregateInputType = {
    siteid?: true
  }

  export type SiteTBLSumAggregateInputType = {
    siteid?: true
  }

  export type SiteTBLMinAggregateInputType = {
    siteid?: true
    sitename?: true
  }

  export type SiteTBLMaxAggregateInputType = {
    siteid?: true
    sitename?: true
  }

  export type SiteTBLCountAggregateInputType = {
    siteid?: true
    sitename?: true
    _all?: true
  }

  export type SiteTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteTBL to aggregate.
     */
    where?: SiteTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteTBLS to fetch.
     */
    orderBy?: SiteTBLOrderByWithRelationInput | SiteTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteTBLS
    **/
    _count?: true | SiteTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SiteTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SiteTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteTBLMaxAggregateInputType
  }

  export type GetSiteTBLAggregateType<T extends SiteTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteTBL[P]>
      : GetScalarType<T[P], AggregateSiteTBL[P]>
  }




  export type SiteTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SiteTBLWhereInput
    orderBy?: SiteTBLOrderByWithAggregationInput | SiteTBLOrderByWithAggregationInput[]
    by: SiteTBLScalarFieldEnum[] | SiteTBLScalarFieldEnum
    having?: SiteTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteTBLCountAggregateInputType | true
    _avg?: SiteTBLAvgAggregateInputType
    _sum?: SiteTBLSumAggregateInputType
    _min?: SiteTBLMinAggregateInputType
    _max?: SiteTBLMaxAggregateInputType
  }


  export type SiteTBLGroupByOutputType = {
    siteid: number
    sitename: string
    _count: SiteTBLCountAggregateOutputType | null
    _avg: SiteTBLAvgAggregateOutputType | null
    _sum: SiteTBLSumAggregateOutputType | null
    _min: SiteTBLMinAggregateOutputType | null
    _max: SiteTBLMaxAggregateOutputType | null
  }

  type GetSiteTBLGroupByPayload<T extends SiteTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteTBLGroupByOutputType[P]>
            : GetScalarType<T[P], SiteTBLGroupByOutputType[P]>
        }
      >
    >


  export type SiteTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    siteid?: boolean
    sitename?: boolean
    Employee?: boolean | SiteTBL$EmployeeArgs<ExtArgs>
    Building?: boolean | SiteTBL$BuildingArgs<ExtArgs>
    Officeboy?: boolean | SiteTBL$OfficeboyArgs<ExtArgs>
    _count?: boolean | SiteTBLCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["siteTBL"]>

  export type SiteTBLSelectScalar = {
    siteid?: boolean
    sitename?: boolean
  }

  export type SiteTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Employee?: boolean | SiteTBL$EmployeeArgs<ExtArgs>
    Building?: boolean | SiteTBL$BuildingArgs<ExtArgs>
    Officeboy?: boolean | SiteTBL$OfficeboyArgs<ExtArgs>
    _count?: boolean | SiteTBLCountOutputTypeArgs<ExtArgs>
  }


  type SiteTBLGetPayload<S extends boolean | null | undefined | SiteTBLArgs> = $Types.GetResult<SiteTBLPayload, S>

  type SiteTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SiteTBLFindManyArgs, 'select' | 'include'> & {
      select?: SiteTBLCountAggregateInputType | true
    }

  export interface SiteTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteTBL'], meta: { name: 'SiteTBL' } }
    /**
     * Find zero or one SiteTBL that matches the filter.
     * @param {SiteTBLFindUniqueArgs} args - Arguments to find a SiteTBL
     * @example
     * // Get one SiteTBL
     * const siteTBL = await prisma.siteTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SiteTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SiteTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__SiteTBLClient<$Types.GetResult<SiteTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SiteTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SiteTBLFindUniqueOrThrowArgs} args - Arguments to find a SiteTBL
     * @example
     * // Get one SiteTBL
     * const siteTBL = await prisma.siteTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SiteTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SiteTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SiteTBLClient<$Types.GetResult<SiteTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SiteTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTBLFindFirstArgs} args - Arguments to find a SiteTBL
     * @example
     * // Get one SiteTBL
     * const siteTBL = await prisma.siteTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SiteTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SiteTBLFindFirstArgs<ExtArgs>>
    ): Prisma__SiteTBLClient<$Types.GetResult<SiteTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SiteTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTBLFindFirstOrThrowArgs} args - Arguments to find a SiteTBL
     * @example
     * // Get one SiteTBL
     * const siteTBL = await prisma.siteTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SiteTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SiteTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SiteTBLClient<$Types.GetResult<SiteTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SiteTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteTBLS
     * const siteTBLS = await prisma.siteTBL.findMany()
     * 
     * // Get first 10 SiteTBLS
     * const siteTBLS = await prisma.siteTBL.findMany({ take: 10 })
     * 
     * // Only select the `siteid`
     * const siteTBLWithSiteidOnly = await prisma.siteTBL.findMany({ select: { siteid: true } })
     * 
    **/
    findMany<T extends SiteTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SiteTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SiteTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SiteTBL.
     * @param {SiteTBLCreateArgs} args - Arguments to create a SiteTBL.
     * @example
     * // Create one SiteTBL
     * const SiteTBL = await prisma.siteTBL.create({
     *   data: {
     *     // ... data to create a SiteTBL
     *   }
     * })
     * 
    **/
    create<T extends SiteTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SiteTBLCreateArgs<ExtArgs>>
    ): Prisma__SiteTBLClient<$Types.GetResult<SiteTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SiteTBLS.
     *     @param {SiteTBLCreateManyArgs} args - Arguments to create many SiteTBLS.
     *     @example
     *     // Create many SiteTBLS
     *     const siteTBL = await prisma.siteTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SiteTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SiteTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SiteTBL.
     * @param {SiteTBLDeleteArgs} args - Arguments to delete one SiteTBL.
     * @example
     * // Delete one SiteTBL
     * const SiteTBL = await prisma.siteTBL.delete({
     *   where: {
     *     // ... filter to delete one SiteTBL
     *   }
     * })
     * 
    **/
    delete<T extends SiteTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SiteTBLDeleteArgs<ExtArgs>>
    ): Prisma__SiteTBLClient<$Types.GetResult<SiteTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SiteTBL.
     * @param {SiteTBLUpdateArgs} args - Arguments to update one SiteTBL.
     * @example
     * // Update one SiteTBL
     * const siteTBL = await prisma.siteTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SiteTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SiteTBLUpdateArgs<ExtArgs>>
    ): Prisma__SiteTBLClient<$Types.GetResult<SiteTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SiteTBLS.
     * @param {SiteTBLDeleteManyArgs} args - Arguments to filter SiteTBLS to delete.
     * @example
     * // Delete a few SiteTBLS
     * const { count } = await prisma.siteTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SiteTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SiteTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteTBLS
     * const siteTBL = await prisma.siteTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SiteTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SiteTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SiteTBL.
     * @param {SiteTBLUpsertArgs} args - Arguments to update or create a SiteTBL.
     * @example
     * // Update or create a SiteTBL
     * const siteTBL = await prisma.siteTBL.upsert({
     *   create: {
     *     // ... data to create a SiteTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteTBL we want to update
     *   }
     * })
    **/
    upsert<T extends SiteTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SiteTBLUpsertArgs<ExtArgs>>
    ): Prisma__SiteTBLClient<$Types.GetResult<SiteTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SiteTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTBLCountArgs} args - Arguments to filter SiteTBLS to count.
     * @example
     * // Count the number of SiteTBLS
     * const count = await prisma.siteTBL.count({
     *   where: {
     *     // ... the filter for the SiteTBLS we want to count
     *   }
     * })
    **/
    count<T extends SiteTBLCountArgs>(
      args?: Subset<T, SiteTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteTBLAggregateArgs>(args: Subset<T, SiteTBLAggregateArgs>): Prisma.PrismaPromise<GetSiteTBLAggregateType<T>>

    /**
     * Group by SiteTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteTBLGroupByArgs['orderBy'] }
        : { orderBy?: SiteTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteTBL model
   */
  readonly fields: SiteTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SiteTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Employee<T extends SiteTBL$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, SiteTBL$EmployeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    Building<T extends SiteTBL$BuildingArgs<ExtArgs> = {}>(args?: Subset<T, SiteTBL$BuildingArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BuildingTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    Officeboy<T extends SiteTBL$OfficeboyArgs<ExtArgs> = {}>(args?: Subset<T, SiteTBL$OfficeboyArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OfficeBoyTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the SiteTBL model
   */ 
  interface SiteTBLFieldRefs {
    readonly siteid: FieldRef<"SiteTBL", 'Int'>
    readonly sitename: FieldRef<"SiteTBL", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SiteTBL findUnique
   */
  export type SiteTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteTBL
     */
    select?: SiteTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTBLInclude<ExtArgs> | null
    /**
     * Filter, which SiteTBL to fetch.
     */
    where: SiteTBLWhereUniqueInput
  }


  /**
   * SiteTBL findUniqueOrThrow
   */
  export type SiteTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteTBL
     */
    select?: SiteTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTBLInclude<ExtArgs> | null
    /**
     * Filter, which SiteTBL to fetch.
     */
    where: SiteTBLWhereUniqueInput
  }


  /**
   * SiteTBL findFirst
   */
  export type SiteTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteTBL
     */
    select?: SiteTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTBLInclude<ExtArgs> | null
    /**
     * Filter, which SiteTBL to fetch.
     */
    where?: SiteTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteTBLS to fetch.
     */
    orderBy?: SiteTBLOrderByWithRelationInput | SiteTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteTBLS.
     */
    cursor?: SiteTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteTBLS.
     */
    distinct?: SiteTBLScalarFieldEnum | SiteTBLScalarFieldEnum[]
  }


  /**
   * SiteTBL findFirstOrThrow
   */
  export type SiteTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteTBL
     */
    select?: SiteTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTBLInclude<ExtArgs> | null
    /**
     * Filter, which SiteTBL to fetch.
     */
    where?: SiteTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteTBLS to fetch.
     */
    orderBy?: SiteTBLOrderByWithRelationInput | SiteTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteTBLS.
     */
    cursor?: SiteTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteTBLS.
     */
    distinct?: SiteTBLScalarFieldEnum | SiteTBLScalarFieldEnum[]
  }


  /**
   * SiteTBL findMany
   */
  export type SiteTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteTBL
     */
    select?: SiteTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTBLInclude<ExtArgs> | null
    /**
     * Filter, which SiteTBLS to fetch.
     */
    where?: SiteTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteTBLS to fetch.
     */
    orderBy?: SiteTBLOrderByWithRelationInput | SiteTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteTBLS.
     */
    cursor?: SiteTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteTBLS.
     */
    skip?: number
    distinct?: SiteTBLScalarFieldEnum | SiteTBLScalarFieldEnum[]
  }


  /**
   * SiteTBL create
   */
  export type SiteTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteTBL
     */
    select?: SiteTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a SiteTBL.
     */
    data: XOR<SiteTBLCreateInput, SiteTBLUncheckedCreateInput>
  }


  /**
   * SiteTBL createMany
   */
  export type SiteTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteTBLS.
     */
    data: SiteTBLCreateManyInput | SiteTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SiteTBL update
   */
  export type SiteTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteTBL
     */
    select?: SiteTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a SiteTBL.
     */
    data: XOR<SiteTBLUpdateInput, SiteTBLUncheckedUpdateInput>
    /**
     * Choose, which SiteTBL to update.
     */
    where: SiteTBLWhereUniqueInput
  }


  /**
   * SiteTBL updateMany
   */
  export type SiteTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteTBLS.
     */
    data: XOR<SiteTBLUpdateManyMutationInput, SiteTBLUncheckedUpdateManyInput>
    /**
     * Filter which SiteTBLS to update
     */
    where?: SiteTBLWhereInput
  }


  /**
   * SiteTBL upsert
   */
  export type SiteTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteTBL
     */
    select?: SiteTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the SiteTBL to update in case it exists.
     */
    where: SiteTBLWhereUniqueInput
    /**
     * In case the SiteTBL found by the `where` argument doesn't exist, create a new SiteTBL with this data.
     */
    create: XOR<SiteTBLCreateInput, SiteTBLUncheckedCreateInput>
    /**
     * In case the SiteTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteTBLUpdateInput, SiteTBLUncheckedUpdateInput>
  }


  /**
   * SiteTBL delete
   */
  export type SiteTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteTBL
     */
    select?: SiteTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTBLInclude<ExtArgs> | null
    /**
     * Filter which SiteTBL to delete.
     */
    where: SiteTBLWhereUniqueInput
  }


  /**
   * SiteTBL deleteMany
   */
  export type SiteTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteTBLS to delete
     */
    where?: SiteTBLWhereInput
  }


  /**
   * SiteTBL.Employee
   */
  export type SiteTBL$EmployeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    where?: EmployeeTBLWhereInput
    orderBy?: EmployeeTBLOrderByWithRelationInput | EmployeeTBLOrderByWithRelationInput[]
    cursor?: EmployeeTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTBLScalarFieldEnum | EmployeeTBLScalarFieldEnum[]
  }


  /**
   * SiteTBL.Building
   */
  export type SiteTBL$BuildingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingTBL
     */
    select?: BuildingTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingTBLInclude<ExtArgs> | null
    where?: BuildingTBLWhereInput
    orderBy?: BuildingTBLOrderByWithRelationInput | BuildingTBLOrderByWithRelationInput[]
    cursor?: BuildingTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildingTBLScalarFieldEnum | BuildingTBLScalarFieldEnum[]
  }


  /**
   * SiteTBL.Officeboy
   */
  export type SiteTBL$OfficeboyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeBoyTBL
     */
    select?: OfficeBoyTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeBoyTBLInclude<ExtArgs> | null
    where?: OfficeBoyTBLWhereInput
    orderBy?: OfficeBoyTBLOrderByWithRelationInput | OfficeBoyTBLOrderByWithRelationInput[]
    cursor?: OfficeBoyTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfficeBoyTBLScalarFieldEnum | OfficeBoyTBLScalarFieldEnum[]
  }


  /**
   * SiteTBL without action
   */
  export type SiteTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteTBL
     */
    select?: SiteTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTBLInclude<ExtArgs> | null
  }



  /**
   * Model BuildingTBL
   */


  export type AggregateBuildingTBL = {
    _count: BuildingTBLCountAggregateOutputType | null
    _avg: BuildingTBLAvgAggregateOutputType | null
    _sum: BuildingTBLSumAggregateOutputType | null
    _min: BuildingTBLMinAggregateOutputType | null
    _max: BuildingTBLMaxAggregateOutputType | null
  }

  export type BuildingTBLAvgAggregateOutputType = {
    buildingid: number | null
    siteid: number | null
  }

  export type BuildingTBLSumAggregateOutputType = {
    buildingid: number | null
    siteid: number | null
  }

  export type BuildingTBLMinAggregateOutputType = {
    buildingid: number | null
    buildingname: string | null
    siteid: number | null
  }

  export type BuildingTBLMaxAggregateOutputType = {
    buildingid: number | null
    buildingname: string | null
    siteid: number | null
  }

  export type BuildingTBLCountAggregateOutputType = {
    buildingid: number
    buildingname: number
    siteid: number
    _all: number
  }


  export type BuildingTBLAvgAggregateInputType = {
    buildingid?: true
    siteid?: true
  }

  export type BuildingTBLSumAggregateInputType = {
    buildingid?: true
    siteid?: true
  }

  export type BuildingTBLMinAggregateInputType = {
    buildingid?: true
    buildingname?: true
    siteid?: true
  }

  export type BuildingTBLMaxAggregateInputType = {
    buildingid?: true
    buildingname?: true
    siteid?: true
  }

  export type BuildingTBLCountAggregateInputType = {
    buildingid?: true
    buildingname?: true
    siteid?: true
    _all?: true
  }

  export type BuildingTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildingTBL to aggregate.
     */
    where?: BuildingTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingTBLS to fetch.
     */
    orderBy?: BuildingTBLOrderByWithRelationInput | BuildingTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildingTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuildingTBLS
    **/
    _count?: true | BuildingTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildingTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildingTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildingTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildingTBLMaxAggregateInputType
  }

  export type GetBuildingTBLAggregateType<T extends BuildingTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateBuildingTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuildingTBL[P]>
      : GetScalarType<T[P], AggregateBuildingTBL[P]>
  }




  export type BuildingTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BuildingTBLWhereInput
    orderBy?: BuildingTBLOrderByWithAggregationInput | BuildingTBLOrderByWithAggregationInput[]
    by: BuildingTBLScalarFieldEnum[] | BuildingTBLScalarFieldEnum
    having?: BuildingTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildingTBLCountAggregateInputType | true
    _avg?: BuildingTBLAvgAggregateInputType
    _sum?: BuildingTBLSumAggregateInputType
    _min?: BuildingTBLMinAggregateInputType
    _max?: BuildingTBLMaxAggregateInputType
  }


  export type BuildingTBLGroupByOutputType = {
    buildingid: number
    buildingname: string
    siteid: number
    _count: BuildingTBLCountAggregateOutputType | null
    _avg: BuildingTBLAvgAggregateOutputType | null
    _sum: BuildingTBLSumAggregateOutputType | null
    _min: BuildingTBLMinAggregateOutputType | null
    _max: BuildingTBLMaxAggregateOutputType | null
  }

  type GetBuildingTBLGroupByPayload<T extends BuildingTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildingTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildingTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildingTBLGroupByOutputType[P]>
            : GetScalarType<T[P], BuildingTBLGroupByOutputType[P]>
        }
      >
    >


  export type BuildingTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    buildingid?: boolean
    buildingname?: boolean
    siteid?: boolean
    siteref?: boolean | SiteTBLArgs<ExtArgs>
    Department?: boolean | BuildingTBL$DepartmentArgs<ExtArgs>
    Office?: boolean | BuildingTBL$OfficeArgs<ExtArgs>
    Employee?: boolean | BuildingTBL$EmployeeArgs<ExtArgs>
    _count?: boolean | BuildingTBLCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["buildingTBL"]>

  export type BuildingTBLSelectScalar = {
    buildingid?: boolean
    buildingname?: boolean
    siteid?: boolean
  }

  export type BuildingTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    siteref?: boolean | SiteTBLArgs<ExtArgs>
    Department?: boolean | BuildingTBL$DepartmentArgs<ExtArgs>
    Office?: boolean | BuildingTBL$OfficeArgs<ExtArgs>
    Employee?: boolean | BuildingTBL$EmployeeArgs<ExtArgs>
    _count?: boolean | BuildingTBLCountOutputTypeArgs<ExtArgs>
  }


  type BuildingTBLGetPayload<S extends boolean | null | undefined | BuildingTBLArgs> = $Types.GetResult<BuildingTBLPayload, S>

  type BuildingTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BuildingTBLFindManyArgs, 'select' | 'include'> & {
      select?: BuildingTBLCountAggregateInputType | true
    }

  export interface BuildingTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuildingTBL'], meta: { name: 'BuildingTBL' } }
    /**
     * Find zero or one BuildingTBL that matches the filter.
     * @param {BuildingTBLFindUniqueArgs} args - Arguments to find a BuildingTBL
     * @example
     * // Get one BuildingTBL
     * const buildingTBL = await prisma.buildingTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildingTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__BuildingTBLClient<$Types.GetResult<BuildingTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BuildingTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BuildingTBLFindUniqueOrThrowArgs} args - Arguments to find a BuildingTBL
     * @example
     * // Get one BuildingTBL
     * const buildingTBL = await prisma.buildingTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildingTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BuildingTBLClient<$Types.GetResult<BuildingTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BuildingTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingTBLFindFirstArgs} args - Arguments to find a BuildingTBL
     * @example
     * // Get one BuildingTBL
     * const buildingTBL = await prisma.buildingTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildingTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingTBLFindFirstArgs<ExtArgs>>
    ): Prisma__BuildingTBLClient<$Types.GetResult<BuildingTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BuildingTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingTBLFindFirstOrThrowArgs} args - Arguments to find a BuildingTBL
     * @example
     * // Get one BuildingTBL
     * const buildingTBL = await prisma.buildingTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildingTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BuildingTBLClient<$Types.GetResult<BuildingTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BuildingTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuildingTBLS
     * const buildingTBLS = await prisma.buildingTBL.findMany()
     * 
     * // Get first 10 BuildingTBLS
     * const buildingTBLS = await prisma.buildingTBL.findMany({ take: 10 })
     * 
     * // Only select the `buildingid`
     * const buildingTBLWithBuildingidOnly = await prisma.buildingTBL.findMany({ select: { buildingid: true } })
     * 
    **/
    findMany<T extends BuildingTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BuildingTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BuildingTBL.
     * @param {BuildingTBLCreateArgs} args - Arguments to create a BuildingTBL.
     * @example
     * // Create one BuildingTBL
     * const BuildingTBL = await prisma.buildingTBL.create({
     *   data: {
     *     // ... data to create a BuildingTBL
     *   }
     * })
     * 
    **/
    create<T extends BuildingTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingTBLCreateArgs<ExtArgs>>
    ): Prisma__BuildingTBLClient<$Types.GetResult<BuildingTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BuildingTBLS.
     *     @param {BuildingTBLCreateManyArgs} args - Arguments to create many BuildingTBLS.
     *     @example
     *     // Create many BuildingTBLS
     *     const buildingTBL = await prisma.buildingTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildingTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuildingTBL.
     * @param {BuildingTBLDeleteArgs} args - Arguments to delete one BuildingTBL.
     * @example
     * // Delete one BuildingTBL
     * const BuildingTBL = await prisma.buildingTBL.delete({
     *   where: {
     *     // ... filter to delete one BuildingTBL
     *   }
     * })
     * 
    **/
    delete<T extends BuildingTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingTBLDeleteArgs<ExtArgs>>
    ): Prisma__BuildingTBLClient<$Types.GetResult<BuildingTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BuildingTBL.
     * @param {BuildingTBLUpdateArgs} args - Arguments to update one BuildingTBL.
     * @example
     * // Update one BuildingTBL
     * const buildingTBL = await prisma.buildingTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildingTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingTBLUpdateArgs<ExtArgs>>
    ): Prisma__BuildingTBLClient<$Types.GetResult<BuildingTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BuildingTBLS.
     * @param {BuildingTBLDeleteManyArgs} args - Arguments to filter BuildingTBLS to delete.
     * @example
     * // Delete a few BuildingTBLS
     * const { count } = await prisma.buildingTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildingTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuildingTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuildingTBLS
     * const buildingTBL = await prisma.buildingTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildingTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuildingTBL.
     * @param {BuildingTBLUpsertArgs} args - Arguments to update or create a BuildingTBL.
     * @example
     * // Update or create a BuildingTBL
     * const buildingTBL = await prisma.buildingTBL.upsert({
     *   create: {
     *     // ... data to create a BuildingTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuildingTBL we want to update
     *   }
     * })
    **/
    upsert<T extends BuildingTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingTBLUpsertArgs<ExtArgs>>
    ): Prisma__BuildingTBLClient<$Types.GetResult<BuildingTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BuildingTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingTBLCountArgs} args - Arguments to filter BuildingTBLS to count.
     * @example
     * // Count the number of BuildingTBLS
     * const count = await prisma.buildingTBL.count({
     *   where: {
     *     // ... the filter for the BuildingTBLS we want to count
     *   }
     * })
    **/
    count<T extends BuildingTBLCountArgs>(
      args?: Subset<T, BuildingTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildingTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuildingTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildingTBLAggregateArgs>(args: Subset<T, BuildingTBLAggregateArgs>): Prisma.PrismaPromise<GetBuildingTBLAggregateType<T>>

    /**
     * Group by BuildingTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildingTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildingTBLGroupByArgs['orderBy'] }
        : { orderBy?: BuildingTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildingTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildingTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuildingTBL model
   */
  readonly fields: BuildingTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuildingTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BuildingTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    siteref<T extends SiteTBLArgs<ExtArgs> = {}>(args?: Subset<T, SiteTBLArgs<ExtArgs>>): Prisma__SiteTBLClient<$Types.GetResult<SiteTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    Department<T extends BuildingTBL$DepartmentArgs<ExtArgs> = {}>(args?: Subset<T, BuildingTBL$DepartmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DepartmentTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    Office<T extends BuildingTBL$OfficeArgs<ExtArgs> = {}>(args?: Subset<T, BuildingTBL$OfficeArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OfficeTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    Employee<T extends BuildingTBL$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, BuildingTBL$EmployeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the BuildingTBL model
   */ 
  interface BuildingTBLFieldRefs {
    readonly buildingid: FieldRef<"BuildingTBL", 'Int'>
    readonly buildingname: FieldRef<"BuildingTBL", 'String'>
    readonly siteid: FieldRef<"BuildingTBL", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * BuildingTBL findUnique
   */
  export type BuildingTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingTBL
     */
    select?: BuildingTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingTBLInclude<ExtArgs> | null
    /**
     * Filter, which BuildingTBL to fetch.
     */
    where: BuildingTBLWhereUniqueInput
  }


  /**
   * BuildingTBL findUniqueOrThrow
   */
  export type BuildingTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingTBL
     */
    select?: BuildingTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingTBLInclude<ExtArgs> | null
    /**
     * Filter, which BuildingTBL to fetch.
     */
    where: BuildingTBLWhereUniqueInput
  }


  /**
   * BuildingTBL findFirst
   */
  export type BuildingTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingTBL
     */
    select?: BuildingTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingTBLInclude<ExtArgs> | null
    /**
     * Filter, which BuildingTBL to fetch.
     */
    where?: BuildingTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingTBLS to fetch.
     */
    orderBy?: BuildingTBLOrderByWithRelationInput | BuildingTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildingTBLS.
     */
    cursor?: BuildingTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildingTBLS.
     */
    distinct?: BuildingTBLScalarFieldEnum | BuildingTBLScalarFieldEnum[]
  }


  /**
   * BuildingTBL findFirstOrThrow
   */
  export type BuildingTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingTBL
     */
    select?: BuildingTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingTBLInclude<ExtArgs> | null
    /**
     * Filter, which BuildingTBL to fetch.
     */
    where?: BuildingTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingTBLS to fetch.
     */
    orderBy?: BuildingTBLOrderByWithRelationInput | BuildingTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildingTBLS.
     */
    cursor?: BuildingTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildingTBLS.
     */
    distinct?: BuildingTBLScalarFieldEnum | BuildingTBLScalarFieldEnum[]
  }


  /**
   * BuildingTBL findMany
   */
  export type BuildingTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingTBL
     */
    select?: BuildingTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingTBLInclude<ExtArgs> | null
    /**
     * Filter, which BuildingTBLS to fetch.
     */
    where?: BuildingTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingTBLS to fetch.
     */
    orderBy?: BuildingTBLOrderByWithRelationInput | BuildingTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuildingTBLS.
     */
    cursor?: BuildingTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingTBLS.
     */
    skip?: number
    distinct?: BuildingTBLScalarFieldEnum | BuildingTBLScalarFieldEnum[]
  }


  /**
   * BuildingTBL create
   */
  export type BuildingTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingTBL
     */
    select?: BuildingTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a BuildingTBL.
     */
    data: XOR<BuildingTBLCreateInput, BuildingTBLUncheckedCreateInput>
  }


  /**
   * BuildingTBL createMany
   */
  export type BuildingTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuildingTBLS.
     */
    data: BuildingTBLCreateManyInput | BuildingTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BuildingTBL update
   */
  export type BuildingTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingTBL
     */
    select?: BuildingTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a BuildingTBL.
     */
    data: XOR<BuildingTBLUpdateInput, BuildingTBLUncheckedUpdateInput>
    /**
     * Choose, which BuildingTBL to update.
     */
    where: BuildingTBLWhereUniqueInput
  }


  /**
   * BuildingTBL updateMany
   */
  export type BuildingTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuildingTBLS.
     */
    data: XOR<BuildingTBLUpdateManyMutationInput, BuildingTBLUncheckedUpdateManyInput>
    /**
     * Filter which BuildingTBLS to update
     */
    where?: BuildingTBLWhereInput
  }


  /**
   * BuildingTBL upsert
   */
  export type BuildingTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingTBL
     */
    select?: BuildingTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the BuildingTBL to update in case it exists.
     */
    where: BuildingTBLWhereUniqueInput
    /**
     * In case the BuildingTBL found by the `where` argument doesn't exist, create a new BuildingTBL with this data.
     */
    create: XOR<BuildingTBLCreateInput, BuildingTBLUncheckedCreateInput>
    /**
     * In case the BuildingTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildingTBLUpdateInput, BuildingTBLUncheckedUpdateInput>
  }


  /**
   * BuildingTBL delete
   */
  export type BuildingTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingTBL
     */
    select?: BuildingTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingTBLInclude<ExtArgs> | null
    /**
     * Filter which BuildingTBL to delete.
     */
    where: BuildingTBLWhereUniqueInput
  }


  /**
   * BuildingTBL deleteMany
   */
  export type BuildingTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildingTBLS to delete
     */
    where?: BuildingTBLWhereInput
  }


  /**
   * BuildingTBL.Department
   */
  export type BuildingTBL$DepartmentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentTBL
     */
    select?: DepartmentTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentTBLInclude<ExtArgs> | null
    where?: DepartmentTBLWhereInput
    orderBy?: DepartmentTBLOrderByWithRelationInput | DepartmentTBLOrderByWithRelationInput[]
    cursor?: DepartmentTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentTBLScalarFieldEnum | DepartmentTBLScalarFieldEnum[]
  }


  /**
   * BuildingTBL.Office
   */
  export type BuildingTBL$OfficeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeTBL
     */
    select?: OfficeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeTBLInclude<ExtArgs> | null
    where?: OfficeTBLWhereInput
    orderBy?: OfficeTBLOrderByWithRelationInput | OfficeTBLOrderByWithRelationInput[]
    cursor?: OfficeTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfficeTBLScalarFieldEnum | OfficeTBLScalarFieldEnum[]
  }


  /**
   * BuildingTBL.Employee
   */
  export type BuildingTBL$EmployeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    where?: EmployeeTBLWhereInput
    orderBy?: EmployeeTBLOrderByWithRelationInput | EmployeeTBLOrderByWithRelationInput[]
    cursor?: EmployeeTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTBLScalarFieldEnum | EmployeeTBLScalarFieldEnum[]
  }


  /**
   * BuildingTBL without action
   */
  export type BuildingTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingTBL
     */
    select?: BuildingTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingTBLInclude<ExtArgs> | null
  }



  /**
   * Model OfficeTBL
   */


  export type AggregateOfficeTBL = {
    _count: OfficeTBLCountAggregateOutputType | null
    _avg: OfficeTBLAvgAggregateOutputType | null
    _sum: OfficeTBLSumAggregateOutputType | null
    _min: OfficeTBLMinAggregateOutputType | null
    _max: OfficeTBLMaxAggregateOutputType | null
  }

  export type OfficeTBLAvgAggregateOutputType = {
    officeid: number | null
    officeno: number | null
    buildingid: number | null
  }

  export type OfficeTBLSumAggregateOutputType = {
    officeid: number | null
    officeno: number | null
    buildingid: number | null
  }

  export type OfficeTBLMinAggregateOutputType = {
    officeid: number | null
    officeno: number | null
    buildingid: number | null
  }

  export type OfficeTBLMaxAggregateOutputType = {
    officeid: number | null
    officeno: number | null
    buildingid: number | null
  }

  export type OfficeTBLCountAggregateOutputType = {
    officeid: number
    officeno: number
    buildingid: number
    _all: number
  }


  export type OfficeTBLAvgAggregateInputType = {
    officeid?: true
    officeno?: true
    buildingid?: true
  }

  export type OfficeTBLSumAggregateInputType = {
    officeid?: true
    officeno?: true
    buildingid?: true
  }

  export type OfficeTBLMinAggregateInputType = {
    officeid?: true
    officeno?: true
    buildingid?: true
  }

  export type OfficeTBLMaxAggregateInputType = {
    officeid?: true
    officeno?: true
    buildingid?: true
  }

  export type OfficeTBLCountAggregateInputType = {
    officeid?: true
    officeno?: true
    buildingid?: true
    _all?: true
  }

  export type OfficeTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfficeTBL to aggregate.
     */
    where?: OfficeTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfficeTBLS to fetch.
     */
    orderBy?: OfficeTBLOrderByWithRelationInput | OfficeTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfficeTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfficeTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfficeTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfficeTBLS
    **/
    _count?: true | OfficeTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfficeTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfficeTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfficeTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfficeTBLMaxAggregateInputType
  }

  export type GetOfficeTBLAggregateType<T extends OfficeTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateOfficeTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfficeTBL[P]>
      : GetScalarType<T[P], AggregateOfficeTBL[P]>
  }




  export type OfficeTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfficeTBLWhereInput
    orderBy?: OfficeTBLOrderByWithAggregationInput | OfficeTBLOrderByWithAggregationInput[]
    by: OfficeTBLScalarFieldEnum[] | OfficeTBLScalarFieldEnum
    having?: OfficeTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfficeTBLCountAggregateInputType | true
    _avg?: OfficeTBLAvgAggregateInputType
    _sum?: OfficeTBLSumAggregateInputType
    _min?: OfficeTBLMinAggregateInputType
    _max?: OfficeTBLMaxAggregateInputType
  }


  export type OfficeTBLGroupByOutputType = {
    officeid: number
    officeno: number
    buildingid: number
    _count: OfficeTBLCountAggregateOutputType | null
    _avg: OfficeTBLAvgAggregateOutputType | null
    _sum: OfficeTBLSumAggregateOutputType | null
    _min: OfficeTBLMinAggregateOutputType | null
    _max: OfficeTBLMaxAggregateOutputType | null
  }

  type GetOfficeTBLGroupByPayload<T extends OfficeTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfficeTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfficeTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfficeTBLGroupByOutputType[P]>
            : GetScalarType<T[P], OfficeTBLGroupByOutputType[P]>
        }
      >
    >


  export type OfficeTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    officeid?: boolean
    officeno?: boolean
    buildingid?: boolean
    Employee?: boolean | OfficeTBL$EmployeeArgs<ExtArgs>
    Officeboy?: boolean | OfficeTBL$OfficeboyArgs<ExtArgs>
    bulidingref?: boolean | BuildingTBLArgs<ExtArgs>
    Room?: boolean | OfficeTBL$RoomArgs<ExtArgs>
    _count?: boolean | OfficeTBLCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["officeTBL"]>

  export type OfficeTBLSelectScalar = {
    officeid?: boolean
    officeno?: boolean
    buildingid?: boolean
  }

  export type OfficeTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Employee?: boolean | OfficeTBL$EmployeeArgs<ExtArgs>
    Officeboy?: boolean | OfficeTBL$OfficeboyArgs<ExtArgs>
    bulidingref?: boolean | BuildingTBLArgs<ExtArgs>
    Room?: boolean | OfficeTBL$RoomArgs<ExtArgs>
    _count?: boolean | OfficeTBLCountOutputTypeArgs<ExtArgs>
  }


  type OfficeTBLGetPayload<S extends boolean | null | undefined | OfficeTBLArgs> = $Types.GetResult<OfficeTBLPayload, S>

  type OfficeTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OfficeTBLFindManyArgs, 'select' | 'include'> & {
      select?: OfficeTBLCountAggregateInputType | true
    }

  export interface OfficeTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfficeTBL'], meta: { name: 'OfficeTBL' } }
    /**
     * Find zero or one OfficeTBL that matches the filter.
     * @param {OfficeTBLFindUniqueArgs} args - Arguments to find a OfficeTBL
     * @example
     * // Get one OfficeTBL
     * const officeTBL = await prisma.officeTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OfficeTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OfficeTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__OfficeTBLClient<$Types.GetResult<OfficeTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OfficeTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OfficeTBLFindUniqueOrThrowArgs} args - Arguments to find a OfficeTBL
     * @example
     * // Get one OfficeTBL
     * const officeTBL = await prisma.officeTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OfficeTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfficeTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OfficeTBLClient<$Types.GetResult<OfficeTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OfficeTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeTBLFindFirstArgs} args - Arguments to find a OfficeTBL
     * @example
     * // Get one OfficeTBL
     * const officeTBL = await prisma.officeTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OfficeTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OfficeTBLFindFirstArgs<ExtArgs>>
    ): Prisma__OfficeTBLClient<$Types.GetResult<OfficeTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OfficeTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeTBLFindFirstOrThrowArgs} args - Arguments to find a OfficeTBL
     * @example
     * // Get one OfficeTBL
     * const officeTBL = await prisma.officeTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OfficeTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfficeTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OfficeTBLClient<$Types.GetResult<OfficeTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OfficeTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfficeTBLS
     * const officeTBLS = await prisma.officeTBL.findMany()
     * 
     * // Get first 10 OfficeTBLS
     * const officeTBLS = await prisma.officeTBL.findMany({ take: 10 })
     * 
     * // Only select the `officeid`
     * const officeTBLWithOfficeidOnly = await prisma.officeTBL.findMany({ select: { officeid: true } })
     * 
    **/
    findMany<T extends OfficeTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfficeTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OfficeTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OfficeTBL.
     * @param {OfficeTBLCreateArgs} args - Arguments to create a OfficeTBL.
     * @example
     * // Create one OfficeTBL
     * const OfficeTBL = await prisma.officeTBL.create({
     *   data: {
     *     // ... data to create a OfficeTBL
     *   }
     * })
     * 
    **/
    create<T extends OfficeTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OfficeTBLCreateArgs<ExtArgs>>
    ): Prisma__OfficeTBLClient<$Types.GetResult<OfficeTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OfficeTBLS.
     *     @param {OfficeTBLCreateManyArgs} args - Arguments to create many OfficeTBLS.
     *     @example
     *     // Create many OfficeTBLS
     *     const officeTBL = await prisma.officeTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OfficeTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfficeTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfficeTBL.
     * @param {OfficeTBLDeleteArgs} args - Arguments to delete one OfficeTBL.
     * @example
     * // Delete one OfficeTBL
     * const OfficeTBL = await prisma.officeTBL.delete({
     *   where: {
     *     // ... filter to delete one OfficeTBL
     *   }
     * })
     * 
    **/
    delete<T extends OfficeTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OfficeTBLDeleteArgs<ExtArgs>>
    ): Prisma__OfficeTBLClient<$Types.GetResult<OfficeTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OfficeTBL.
     * @param {OfficeTBLUpdateArgs} args - Arguments to update one OfficeTBL.
     * @example
     * // Update one OfficeTBL
     * const officeTBL = await prisma.officeTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OfficeTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OfficeTBLUpdateArgs<ExtArgs>>
    ): Prisma__OfficeTBLClient<$Types.GetResult<OfficeTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OfficeTBLS.
     * @param {OfficeTBLDeleteManyArgs} args - Arguments to filter OfficeTBLS to delete.
     * @example
     * // Delete a few OfficeTBLS
     * const { count } = await prisma.officeTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OfficeTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfficeTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfficeTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfficeTBLS
     * const officeTBL = await prisma.officeTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OfficeTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OfficeTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfficeTBL.
     * @param {OfficeTBLUpsertArgs} args - Arguments to update or create a OfficeTBL.
     * @example
     * // Update or create a OfficeTBL
     * const officeTBL = await prisma.officeTBL.upsert({
     *   create: {
     *     // ... data to create a OfficeTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfficeTBL we want to update
     *   }
     * })
    **/
    upsert<T extends OfficeTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OfficeTBLUpsertArgs<ExtArgs>>
    ): Prisma__OfficeTBLClient<$Types.GetResult<OfficeTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OfficeTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeTBLCountArgs} args - Arguments to filter OfficeTBLS to count.
     * @example
     * // Count the number of OfficeTBLS
     * const count = await prisma.officeTBL.count({
     *   where: {
     *     // ... the filter for the OfficeTBLS we want to count
     *   }
     * })
    **/
    count<T extends OfficeTBLCountArgs>(
      args?: Subset<T, OfficeTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfficeTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfficeTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfficeTBLAggregateArgs>(args: Subset<T, OfficeTBLAggregateArgs>): Prisma.PrismaPromise<GetOfficeTBLAggregateType<T>>

    /**
     * Group by OfficeTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfficeTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfficeTBLGroupByArgs['orderBy'] }
        : { orderBy?: OfficeTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfficeTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfficeTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfficeTBL model
   */
  readonly fields: OfficeTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfficeTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OfficeTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Employee<T extends OfficeTBL$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, OfficeTBL$EmployeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    Officeboy<T extends OfficeTBL$OfficeboyArgs<ExtArgs> = {}>(args?: Subset<T, OfficeTBL$OfficeboyArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OfficeBoyTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    bulidingref<T extends BuildingTBLArgs<ExtArgs> = {}>(args?: Subset<T, BuildingTBLArgs<ExtArgs>>): Prisma__BuildingTBLClient<$Types.GetResult<BuildingTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    Room<T extends OfficeTBL$RoomArgs<ExtArgs> = {}>(args?: Subset<T, OfficeTBL$RoomArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<RoomTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the OfficeTBL model
   */ 
  interface OfficeTBLFieldRefs {
    readonly officeid: FieldRef<"OfficeTBL", 'Int'>
    readonly officeno: FieldRef<"OfficeTBL", 'Int'>
    readonly buildingid: FieldRef<"OfficeTBL", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * OfficeTBL findUnique
   */
  export type OfficeTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeTBL
     */
    select?: OfficeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeTBLInclude<ExtArgs> | null
    /**
     * Filter, which OfficeTBL to fetch.
     */
    where: OfficeTBLWhereUniqueInput
  }


  /**
   * OfficeTBL findUniqueOrThrow
   */
  export type OfficeTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeTBL
     */
    select?: OfficeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeTBLInclude<ExtArgs> | null
    /**
     * Filter, which OfficeTBL to fetch.
     */
    where: OfficeTBLWhereUniqueInput
  }


  /**
   * OfficeTBL findFirst
   */
  export type OfficeTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeTBL
     */
    select?: OfficeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeTBLInclude<ExtArgs> | null
    /**
     * Filter, which OfficeTBL to fetch.
     */
    where?: OfficeTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfficeTBLS to fetch.
     */
    orderBy?: OfficeTBLOrderByWithRelationInput | OfficeTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfficeTBLS.
     */
    cursor?: OfficeTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfficeTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfficeTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfficeTBLS.
     */
    distinct?: OfficeTBLScalarFieldEnum | OfficeTBLScalarFieldEnum[]
  }


  /**
   * OfficeTBL findFirstOrThrow
   */
  export type OfficeTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeTBL
     */
    select?: OfficeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeTBLInclude<ExtArgs> | null
    /**
     * Filter, which OfficeTBL to fetch.
     */
    where?: OfficeTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfficeTBLS to fetch.
     */
    orderBy?: OfficeTBLOrderByWithRelationInput | OfficeTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfficeTBLS.
     */
    cursor?: OfficeTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfficeTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfficeTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfficeTBLS.
     */
    distinct?: OfficeTBLScalarFieldEnum | OfficeTBLScalarFieldEnum[]
  }


  /**
   * OfficeTBL findMany
   */
  export type OfficeTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeTBL
     */
    select?: OfficeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeTBLInclude<ExtArgs> | null
    /**
     * Filter, which OfficeTBLS to fetch.
     */
    where?: OfficeTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfficeTBLS to fetch.
     */
    orderBy?: OfficeTBLOrderByWithRelationInput | OfficeTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfficeTBLS.
     */
    cursor?: OfficeTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfficeTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfficeTBLS.
     */
    skip?: number
    distinct?: OfficeTBLScalarFieldEnum | OfficeTBLScalarFieldEnum[]
  }


  /**
   * OfficeTBL create
   */
  export type OfficeTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeTBL
     */
    select?: OfficeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a OfficeTBL.
     */
    data: XOR<OfficeTBLCreateInput, OfficeTBLUncheckedCreateInput>
  }


  /**
   * OfficeTBL createMany
   */
  export type OfficeTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfficeTBLS.
     */
    data: OfficeTBLCreateManyInput | OfficeTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OfficeTBL update
   */
  export type OfficeTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeTBL
     */
    select?: OfficeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a OfficeTBL.
     */
    data: XOR<OfficeTBLUpdateInput, OfficeTBLUncheckedUpdateInput>
    /**
     * Choose, which OfficeTBL to update.
     */
    where: OfficeTBLWhereUniqueInput
  }


  /**
   * OfficeTBL updateMany
   */
  export type OfficeTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfficeTBLS.
     */
    data: XOR<OfficeTBLUpdateManyMutationInput, OfficeTBLUncheckedUpdateManyInput>
    /**
     * Filter which OfficeTBLS to update
     */
    where?: OfficeTBLWhereInput
  }


  /**
   * OfficeTBL upsert
   */
  export type OfficeTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeTBL
     */
    select?: OfficeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the OfficeTBL to update in case it exists.
     */
    where: OfficeTBLWhereUniqueInput
    /**
     * In case the OfficeTBL found by the `where` argument doesn't exist, create a new OfficeTBL with this data.
     */
    create: XOR<OfficeTBLCreateInput, OfficeTBLUncheckedCreateInput>
    /**
     * In case the OfficeTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfficeTBLUpdateInput, OfficeTBLUncheckedUpdateInput>
  }


  /**
   * OfficeTBL delete
   */
  export type OfficeTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeTBL
     */
    select?: OfficeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeTBLInclude<ExtArgs> | null
    /**
     * Filter which OfficeTBL to delete.
     */
    where: OfficeTBLWhereUniqueInput
  }


  /**
   * OfficeTBL deleteMany
   */
  export type OfficeTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfficeTBLS to delete
     */
    where?: OfficeTBLWhereInput
  }


  /**
   * OfficeTBL.Employee
   */
  export type OfficeTBL$EmployeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    where?: EmployeeTBLWhereInput
    orderBy?: EmployeeTBLOrderByWithRelationInput | EmployeeTBLOrderByWithRelationInput[]
    cursor?: EmployeeTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTBLScalarFieldEnum | EmployeeTBLScalarFieldEnum[]
  }


  /**
   * OfficeTBL.Officeboy
   */
  export type OfficeTBL$OfficeboyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeBoyTBL
     */
    select?: OfficeBoyTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeBoyTBLInclude<ExtArgs> | null
    where?: OfficeBoyTBLWhereInput
    orderBy?: OfficeBoyTBLOrderByWithRelationInput | OfficeBoyTBLOrderByWithRelationInput[]
    cursor?: OfficeBoyTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfficeBoyTBLScalarFieldEnum | OfficeBoyTBLScalarFieldEnum[]
  }


  /**
   * OfficeTBL.Room
   */
  export type OfficeTBL$RoomArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTBL
     */
    select?: RoomTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomTBLInclude<ExtArgs> | null
    where?: RoomTBLWhereInput
    orderBy?: RoomTBLOrderByWithRelationInput | RoomTBLOrderByWithRelationInput[]
    cursor?: RoomTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomTBLScalarFieldEnum | RoomTBLScalarFieldEnum[]
  }


  /**
   * OfficeTBL without action
   */
  export type OfficeTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeTBL
     */
    select?: OfficeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfficeTBLInclude<ExtArgs> | null
  }



  /**
   * Model DepartmentTBL
   */


  export type AggregateDepartmentTBL = {
    _count: DepartmentTBLCountAggregateOutputType | null
    _avg: DepartmentTBLAvgAggregateOutputType | null
    _sum: DepartmentTBLSumAggregateOutputType | null
    _min: DepartmentTBLMinAggregateOutputType | null
    _max: DepartmentTBLMaxAggregateOutputType | null
  }

  export type DepartmentTBLAvgAggregateOutputType = {
    departmentid: number | null
    buildingid: number | null
  }

  export type DepartmentTBLSumAggregateOutputType = {
    departmentid: number | null
    buildingid: number | null
  }

  export type DepartmentTBLMinAggregateOutputType = {
    departmentid: number | null
    departmentname: string | null
    buildingid: number | null
  }

  export type DepartmentTBLMaxAggregateOutputType = {
    departmentid: number | null
    departmentname: string | null
    buildingid: number | null
  }

  export type DepartmentTBLCountAggregateOutputType = {
    departmentid: number
    departmentname: number
    buildingid: number
    _all: number
  }


  export type DepartmentTBLAvgAggregateInputType = {
    departmentid?: true
    buildingid?: true
  }

  export type DepartmentTBLSumAggregateInputType = {
    departmentid?: true
    buildingid?: true
  }

  export type DepartmentTBLMinAggregateInputType = {
    departmentid?: true
    departmentname?: true
    buildingid?: true
  }

  export type DepartmentTBLMaxAggregateInputType = {
    departmentid?: true
    departmentname?: true
    buildingid?: true
  }

  export type DepartmentTBLCountAggregateInputType = {
    departmentid?: true
    departmentname?: true
    buildingid?: true
    _all?: true
  }

  export type DepartmentTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentTBL to aggregate.
     */
    where?: DepartmentTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentTBLS to fetch.
     */
    orderBy?: DepartmentTBLOrderByWithRelationInput | DepartmentTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentTBLS
    **/
    _count?: true | DepartmentTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentTBLMaxAggregateInputType
  }

  export type GetDepartmentTBLAggregateType<T extends DepartmentTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentTBL[P]>
      : GetScalarType<T[P], AggregateDepartmentTBL[P]>
  }




  export type DepartmentTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DepartmentTBLWhereInput
    orderBy?: DepartmentTBLOrderByWithAggregationInput | DepartmentTBLOrderByWithAggregationInput[]
    by: DepartmentTBLScalarFieldEnum[] | DepartmentTBLScalarFieldEnum
    having?: DepartmentTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentTBLCountAggregateInputType | true
    _avg?: DepartmentTBLAvgAggregateInputType
    _sum?: DepartmentTBLSumAggregateInputType
    _min?: DepartmentTBLMinAggregateInputType
    _max?: DepartmentTBLMaxAggregateInputType
  }


  export type DepartmentTBLGroupByOutputType = {
    departmentid: number
    departmentname: string
    buildingid: number
    _count: DepartmentTBLCountAggregateOutputType | null
    _avg: DepartmentTBLAvgAggregateOutputType | null
    _sum: DepartmentTBLSumAggregateOutputType | null
    _min: DepartmentTBLMinAggregateOutputType | null
    _max: DepartmentTBLMaxAggregateOutputType | null
  }

  type GetDepartmentTBLGroupByPayload<T extends DepartmentTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentTBLGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentTBLGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    departmentid?: boolean
    departmentname?: boolean
    buildingid?: boolean
    Room?: boolean | DepartmentTBL$RoomArgs<ExtArgs>
    Employee?: boolean | DepartmentTBL$EmployeeArgs<ExtArgs>
    bulidingref?: boolean | BuildingTBLArgs<ExtArgs>
    _count?: boolean | DepartmentTBLCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["departmentTBL"]>

  export type DepartmentTBLSelectScalar = {
    departmentid?: boolean
    departmentname?: boolean
    buildingid?: boolean
  }

  export type DepartmentTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Room?: boolean | DepartmentTBL$RoomArgs<ExtArgs>
    Employee?: boolean | DepartmentTBL$EmployeeArgs<ExtArgs>
    bulidingref?: boolean | BuildingTBLArgs<ExtArgs>
    _count?: boolean | DepartmentTBLCountOutputTypeArgs<ExtArgs>
  }


  type DepartmentTBLGetPayload<S extends boolean | null | undefined | DepartmentTBLArgs> = $Types.GetResult<DepartmentTBLPayload, S>

  type DepartmentTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DepartmentTBLFindManyArgs, 'select' | 'include'> & {
      select?: DepartmentTBLCountAggregateInputType | true
    }

  export interface DepartmentTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentTBL'], meta: { name: 'DepartmentTBL' } }
    /**
     * Find zero or one DepartmentTBL that matches the filter.
     * @param {DepartmentTBLFindUniqueArgs} args - Arguments to find a DepartmentTBL
     * @example
     * // Get one DepartmentTBL
     * const departmentTBL = await prisma.departmentTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DepartmentTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DepartmentTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__DepartmentTBLClient<$Types.GetResult<DepartmentTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DepartmentTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DepartmentTBLFindUniqueOrThrowArgs} args - Arguments to find a DepartmentTBL
     * @example
     * // Get one DepartmentTBL
     * const departmentTBL = await prisma.departmentTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DepartmentTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DepartmentTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DepartmentTBLClient<$Types.GetResult<DepartmentTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DepartmentTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentTBLFindFirstArgs} args - Arguments to find a DepartmentTBL
     * @example
     * // Get one DepartmentTBL
     * const departmentTBL = await prisma.departmentTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DepartmentTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DepartmentTBLFindFirstArgs<ExtArgs>>
    ): Prisma__DepartmentTBLClient<$Types.GetResult<DepartmentTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DepartmentTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentTBLFindFirstOrThrowArgs} args - Arguments to find a DepartmentTBL
     * @example
     * // Get one DepartmentTBL
     * const departmentTBL = await prisma.departmentTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DepartmentTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DepartmentTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DepartmentTBLClient<$Types.GetResult<DepartmentTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DepartmentTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentTBLS
     * const departmentTBLS = await prisma.departmentTBL.findMany()
     * 
     * // Get first 10 DepartmentTBLS
     * const departmentTBLS = await prisma.departmentTBL.findMany({ take: 10 })
     * 
     * // Only select the `departmentid`
     * const departmentTBLWithDepartmentidOnly = await prisma.departmentTBL.findMany({ select: { departmentid: true } })
     * 
    **/
    findMany<T extends DepartmentTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DepartmentTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DepartmentTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DepartmentTBL.
     * @param {DepartmentTBLCreateArgs} args - Arguments to create a DepartmentTBL.
     * @example
     * // Create one DepartmentTBL
     * const DepartmentTBL = await prisma.departmentTBL.create({
     *   data: {
     *     // ... data to create a DepartmentTBL
     *   }
     * })
     * 
    **/
    create<T extends DepartmentTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DepartmentTBLCreateArgs<ExtArgs>>
    ): Prisma__DepartmentTBLClient<$Types.GetResult<DepartmentTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DepartmentTBLS.
     *     @param {DepartmentTBLCreateManyArgs} args - Arguments to create many DepartmentTBLS.
     *     @example
     *     // Create many DepartmentTBLS
     *     const departmentTBL = await prisma.departmentTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DepartmentTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DepartmentTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DepartmentTBL.
     * @param {DepartmentTBLDeleteArgs} args - Arguments to delete one DepartmentTBL.
     * @example
     * // Delete one DepartmentTBL
     * const DepartmentTBL = await prisma.departmentTBL.delete({
     *   where: {
     *     // ... filter to delete one DepartmentTBL
     *   }
     * })
     * 
    **/
    delete<T extends DepartmentTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DepartmentTBLDeleteArgs<ExtArgs>>
    ): Prisma__DepartmentTBLClient<$Types.GetResult<DepartmentTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DepartmentTBL.
     * @param {DepartmentTBLUpdateArgs} args - Arguments to update one DepartmentTBL.
     * @example
     * // Update one DepartmentTBL
     * const departmentTBL = await prisma.departmentTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DepartmentTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DepartmentTBLUpdateArgs<ExtArgs>>
    ): Prisma__DepartmentTBLClient<$Types.GetResult<DepartmentTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DepartmentTBLS.
     * @param {DepartmentTBLDeleteManyArgs} args - Arguments to filter DepartmentTBLS to delete.
     * @example
     * // Delete a few DepartmentTBLS
     * const { count } = await prisma.departmentTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DepartmentTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DepartmentTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentTBLS
     * const departmentTBL = await prisma.departmentTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DepartmentTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DepartmentTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DepartmentTBL.
     * @param {DepartmentTBLUpsertArgs} args - Arguments to update or create a DepartmentTBL.
     * @example
     * // Update or create a DepartmentTBL
     * const departmentTBL = await prisma.departmentTBL.upsert({
     *   create: {
     *     // ... data to create a DepartmentTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentTBL we want to update
     *   }
     * })
    **/
    upsert<T extends DepartmentTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DepartmentTBLUpsertArgs<ExtArgs>>
    ): Prisma__DepartmentTBLClient<$Types.GetResult<DepartmentTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DepartmentTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentTBLCountArgs} args - Arguments to filter DepartmentTBLS to count.
     * @example
     * // Count the number of DepartmentTBLS
     * const count = await prisma.departmentTBL.count({
     *   where: {
     *     // ... the filter for the DepartmentTBLS we want to count
     *   }
     * })
    **/
    count<T extends DepartmentTBLCountArgs>(
      args?: Subset<T, DepartmentTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentTBLAggregateArgs>(args: Subset<T, DepartmentTBLAggregateArgs>): Prisma.PrismaPromise<GetDepartmentTBLAggregateType<T>>

    /**
     * Group by DepartmentTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentTBLGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentTBL model
   */
  readonly fields: DepartmentTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DepartmentTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Room<T extends DepartmentTBL$RoomArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentTBL$RoomArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<RoomTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    Employee<T extends DepartmentTBL$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentTBL$EmployeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    bulidingref<T extends BuildingTBLArgs<ExtArgs> = {}>(args?: Subset<T, BuildingTBLArgs<ExtArgs>>): Prisma__BuildingTBLClient<$Types.GetResult<BuildingTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the DepartmentTBL model
   */ 
  interface DepartmentTBLFieldRefs {
    readonly departmentid: FieldRef<"DepartmentTBL", 'Int'>
    readonly departmentname: FieldRef<"DepartmentTBL", 'String'>
    readonly buildingid: FieldRef<"DepartmentTBL", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * DepartmentTBL findUnique
   */
  export type DepartmentTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentTBL
     */
    select?: DepartmentTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentTBLInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentTBL to fetch.
     */
    where: DepartmentTBLWhereUniqueInput
  }


  /**
   * DepartmentTBL findUniqueOrThrow
   */
  export type DepartmentTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentTBL
     */
    select?: DepartmentTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentTBLInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentTBL to fetch.
     */
    where: DepartmentTBLWhereUniqueInput
  }


  /**
   * DepartmentTBL findFirst
   */
  export type DepartmentTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentTBL
     */
    select?: DepartmentTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentTBLInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentTBL to fetch.
     */
    where?: DepartmentTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentTBLS to fetch.
     */
    orderBy?: DepartmentTBLOrderByWithRelationInput | DepartmentTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentTBLS.
     */
    cursor?: DepartmentTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentTBLS.
     */
    distinct?: DepartmentTBLScalarFieldEnum | DepartmentTBLScalarFieldEnum[]
  }


  /**
   * DepartmentTBL findFirstOrThrow
   */
  export type DepartmentTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentTBL
     */
    select?: DepartmentTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentTBLInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentTBL to fetch.
     */
    where?: DepartmentTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentTBLS to fetch.
     */
    orderBy?: DepartmentTBLOrderByWithRelationInput | DepartmentTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentTBLS.
     */
    cursor?: DepartmentTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentTBLS.
     */
    distinct?: DepartmentTBLScalarFieldEnum | DepartmentTBLScalarFieldEnum[]
  }


  /**
   * DepartmentTBL findMany
   */
  export type DepartmentTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentTBL
     */
    select?: DepartmentTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentTBLInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentTBLS to fetch.
     */
    where?: DepartmentTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentTBLS to fetch.
     */
    orderBy?: DepartmentTBLOrderByWithRelationInput | DepartmentTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentTBLS.
     */
    cursor?: DepartmentTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentTBLS.
     */
    skip?: number
    distinct?: DepartmentTBLScalarFieldEnum | DepartmentTBLScalarFieldEnum[]
  }


  /**
   * DepartmentTBL create
   */
  export type DepartmentTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentTBL
     */
    select?: DepartmentTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentTBL.
     */
    data: XOR<DepartmentTBLCreateInput, DepartmentTBLUncheckedCreateInput>
  }


  /**
   * DepartmentTBL createMany
   */
  export type DepartmentTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentTBLS.
     */
    data: DepartmentTBLCreateManyInput | DepartmentTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DepartmentTBL update
   */
  export type DepartmentTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentTBL
     */
    select?: DepartmentTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentTBL.
     */
    data: XOR<DepartmentTBLUpdateInput, DepartmentTBLUncheckedUpdateInput>
    /**
     * Choose, which DepartmentTBL to update.
     */
    where: DepartmentTBLWhereUniqueInput
  }


  /**
   * DepartmentTBL updateMany
   */
  export type DepartmentTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentTBLS.
     */
    data: XOR<DepartmentTBLUpdateManyMutationInput, DepartmentTBLUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentTBLS to update
     */
    where?: DepartmentTBLWhereInput
  }


  /**
   * DepartmentTBL upsert
   */
  export type DepartmentTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentTBL
     */
    select?: DepartmentTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentTBL to update in case it exists.
     */
    where: DepartmentTBLWhereUniqueInput
    /**
     * In case the DepartmentTBL found by the `where` argument doesn't exist, create a new DepartmentTBL with this data.
     */
    create: XOR<DepartmentTBLCreateInput, DepartmentTBLUncheckedCreateInput>
    /**
     * In case the DepartmentTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentTBLUpdateInput, DepartmentTBLUncheckedUpdateInput>
  }


  /**
   * DepartmentTBL delete
   */
  export type DepartmentTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentTBL
     */
    select?: DepartmentTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentTBLInclude<ExtArgs> | null
    /**
     * Filter which DepartmentTBL to delete.
     */
    where: DepartmentTBLWhereUniqueInput
  }


  /**
   * DepartmentTBL deleteMany
   */
  export type DepartmentTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentTBLS to delete
     */
    where?: DepartmentTBLWhereInput
  }


  /**
   * DepartmentTBL.Room
   */
  export type DepartmentTBL$RoomArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTBL
     */
    select?: RoomTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomTBLInclude<ExtArgs> | null
    where?: RoomTBLWhereInput
    orderBy?: RoomTBLOrderByWithRelationInput | RoomTBLOrderByWithRelationInput[]
    cursor?: RoomTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomTBLScalarFieldEnum | RoomTBLScalarFieldEnum[]
  }


  /**
   * DepartmentTBL.Employee
   */
  export type DepartmentTBL$EmployeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    where?: EmployeeTBLWhereInput
    orderBy?: EmployeeTBLOrderByWithRelationInput | EmployeeTBLOrderByWithRelationInput[]
    cursor?: EmployeeTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTBLScalarFieldEnum | EmployeeTBLScalarFieldEnum[]
  }


  /**
   * DepartmentTBL without action
   */
  export type DepartmentTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentTBL
     */
    select?: DepartmentTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentTBLInclude<ExtArgs> | null
  }



  /**
   * Model RoomTBL
   */


  export type AggregateRoomTBL = {
    _count: RoomTBLCountAggregateOutputType | null
    _avg: RoomTBLAvgAggregateOutputType | null
    _sum: RoomTBLSumAggregateOutputType | null
    _min: RoomTBLMinAggregateOutputType | null
    _max: RoomTBLMaxAggregateOutputType | null
  }

  export type RoomTBLAvgAggregateOutputType = {
    roomid: number | null
    roomno: number | null
    officeid: number | null
    departmentid: number | null
  }

  export type RoomTBLSumAggregateOutputType = {
    roomid: number | null
    roomno: number | null
    officeid: number | null
    departmentid: number | null
  }

  export type RoomTBLMinAggregateOutputType = {
    roomid: number | null
    roomno: number | null
    roomname: string | null
    officeid: number | null
    departmentid: number | null
  }

  export type RoomTBLMaxAggregateOutputType = {
    roomid: number | null
    roomno: number | null
    roomname: string | null
    officeid: number | null
    departmentid: number | null
  }

  export type RoomTBLCountAggregateOutputType = {
    roomid: number
    roomno: number
    roomname: number
    officeid: number
    departmentid: number
    _all: number
  }


  export type RoomTBLAvgAggregateInputType = {
    roomid?: true
    roomno?: true
    officeid?: true
    departmentid?: true
  }

  export type RoomTBLSumAggregateInputType = {
    roomid?: true
    roomno?: true
    officeid?: true
    departmentid?: true
  }

  export type RoomTBLMinAggregateInputType = {
    roomid?: true
    roomno?: true
    roomname?: true
    officeid?: true
    departmentid?: true
  }

  export type RoomTBLMaxAggregateInputType = {
    roomid?: true
    roomno?: true
    roomname?: true
    officeid?: true
    departmentid?: true
  }

  export type RoomTBLCountAggregateInputType = {
    roomid?: true
    roomno?: true
    roomname?: true
    officeid?: true
    departmentid?: true
    _all?: true
  }

  export type RoomTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomTBL to aggregate.
     */
    where?: RoomTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTBLS to fetch.
     */
    orderBy?: RoomTBLOrderByWithRelationInput | RoomTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomTBLS
    **/
    _count?: true | RoomTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomTBLMaxAggregateInputType
  }

  export type GetRoomTBLAggregateType<T extends RoomTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomTBL[P]>
      : GetScalarType<T[P], AggregateRoomTBL[P]>
  }




  export type RoomTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RoomTBLWhereInput
    orderBy?: RoomTBLOrderByWithAggregationInput | RoomTBLOrderByWithAggregationInput[]
    by: RoomTBLScalarFieldEnum[] | RoomTBLScalarFieldEnum
    having?: RoomTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomTBLCountAggregateInputType | true
    _avg?: RoomTBLAvgAggregateInputType
    _sum?: RoomTBLSumAggregateInputType
    _min?: RoomTBLMinAggregateInputType
    _max?: RoomTBLMaxAggregateInputType
  }


  export type RoomTBLGroupByOutputType = {
    roomid: number
    roomno: number
    roomname: string
    officeid: number
    departmentid: number
    _count: RoomTBLCountAggregateOutputType | null
    _avg: RoomTBLAvgAggregateOutputType | null
    _sum: RoomTBLSumAggregateOutputType | null
    _min: RoomTBLMinAggregateOutputType | null
    _max: RoomTBLMaxAggregateOutputType | null
  }

  type GetRoomTBLGroupByPayload<T extends RoomTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomTBLGroupByOutputType[P]>
            : GetScalarType<T[P], RoomTBLGroupByOutputType[P]>
        }
      >
    >


  export type RoomTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomid?: boolean
    roomno?: boolean
    roomname?: boolean
    officeid?: boolean
    departmentid?: boolean
    officeref?: boolean | OfficeTBLArgs<ExtArgs>
    roomdepref?: boolean | DepartmentTBLArgs<ExtArgs>
    Employee?: boolean | RoomTBL$EmployeeArgs<ExtArgs>
    _count?: boolean | RoomTBLCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["roomTBL"]>

  export type RoomTBLSelectScalar = {
    roomid?: boolean
    roomno?: boolean
    roomname?: boolean
    officeid?: boolean
    departmentid?: boolean
  }

  export type RoomTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    officeref?: boolean | OfficeTBLArgs<ExtArgs>
    roomdepref?: boolean | DepartmentTBLArgs<ExtArgs>
    Employee?: boolean | RoomTBL$EmployeeArgs<ExtArgs>
    _count?: boolean | RoomTBLCountOutputTypeArgs<ExtArgs>
  }


  type RoomTBLGetPayload<S extends boolean | null | undefined | RoomTBLArgs> = $Types.GetResult<RoomTBLPayload, S>

  type RoomTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<RoomTBLFindManyArgs, 'select' | 'include'> & {
      select?: RoomTBLCountAggregateInputType | true
    }

  export interface RoomTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomTBL'], meta: { name: 'RoomTBL' } }
    /**
     * Find zero or one RoomTBL that matches the filter.
     * @param {RoomTBLFindUniqueArgs} args - Arguments to find a RoomTBL
     * @example
     * // Get one RoomTBL
     * const roomTBL = await prisma.roomTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomTBLClient<$Types.GetResult<RoomTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoomTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomTBLFindUniqueOrThrowArgs} args - Arguments to find a RoomTBL
     * @example
     * // Get one RoomTBL
     * const roomTBL = await prisma.roomTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomTBLClient<$Types.GetResult<RoomTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoomTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTBLFindFirstArgs} args - Arguments to find a RoomTBL
     * @example
     * // Get one RoomTBL
     * const roomTBL = await prisma.roomTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTBLFindFirstArgs<ExtArgs>>
    ): Prisma__RoomTBLClient<$Types.GetResult<RoomTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoomTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTBLFindFirstOrThrowArgs} args - Arguments to find a RoomTBL
     * @example
     * // Get one RoomTBL
     * const roomTBL = await prisma.roomTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomTBLClient<$Types.GetResult<RoomTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoomTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomTBLS
     * const roomTBLS = await prisma.roomTBL.findMany()
     * 
     * // Get first 10 RoomTBLS
     * const roomTBLS = await prisma.roomTBL.findMany({ take: 10 })
     * 
     * // Only select the `roomid`
     * const roomTBLWithRoomidOnly = await prisma.roomTBL.findMany({ select: { roomid: true } })
     * 
    **/
    findMany<T extends RoomTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<RoomTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoomTBL.
     * @param {RoomTBLCreateArgs} args - Arguments to create a RoomTBL.
     * @example
     * // Create one RoomTBL
     * const RoomTBL = await prisma.roomTBL.create({
     *   data: {
     *     // ... data to create a RoomTBL
     *   }
     * })
     * 
    **/
    create<T extends RoomTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTBLCreateArgs<ExtArgs>>
    ): Prisma__RoomTBLClient<$Types.GetResult<RoomTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoomTBLS.
     *     @param {RoomTBLCreateManyArgs} args - Arguments to create many RoomTBLS.
     *     @example
     *     // Create many RoomTBLS
     *     const roomTBL = await prisma.roomTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomTBL.
     * @param {RoomTBLDeleteArgs} args - Arguments to delete one RoomTBL.
     * @example
     * // Delete one RoomTBL
     * const RoomTBL = await prisma.roomTBL.delete({
     *   where: {
     *     // ... filter to delete one RoomTBL
     *   }
     * })
     * 
    **/
    delete<T extends RoomTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTBLDeleteArgs<ExtArgs>>
    ): Prisma__RoomTBLClient<$Types.GetResult<RoomTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoomTBL.
     * @param {RoomTBLUpdateArgs} args - Arguments to update one RoomTBL.
     * @example
     * // Update one RoomTBL
     * const roomTBL = await prisma.roomTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTBLUpdateArgs<ExtArgs>>
    ): Prisma__RoomTBLClient<$Types.GetResult<RoomTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoomTBLS.
     * @param {RoomTBLDeleteManyArgs} args - Arguments to filter RoomTBLS to delete.
     * @example
     * // Delete a few RoomTBLS
     * const { count } = await prisma.roomTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomTBLS
     * const roomTBL = await prisma.roomTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomTBL.
     * @param {RoomTBLUpsertArgs} args - Arguments to update or create a RoomTBL.
     * @example
     * // Update or create a RoomTBL
     * const roomTBL = await prisma.roomTBL.upsert({
     *   create: {
     *     // ... data to create a RoomTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomTBL we want to update
     *   }
     * })
    **/
    upsert<T extends RoomTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTBLUpsertArgs<ExtArgs>>
    ): Prisma__RoomTBLClient<$Types.GetResult<RoomTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoomTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTBLCountArgs} args - Arguments to filter RoomTBLS to count.
     * @example
     * // Count the number of RoomTBLS
     * const count = await prisma.roomTBL.count({
     *   where: {
     *     // ... the filter for the RoomTBLS we want to count
     *   }
     * })
    **/
    count<T extends RoomTBLCountArgs>(
      args?: Subset<T, RoomTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomTBLAggregateArgs>(args: Subset<T, RoomTBLAggregateArgs>): Prisma.PrismaPromise<GetRoomTBLAggregateType<T>>

    /**
     * Group by RoomTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomTBLGroupByArgs['orderBy'] }
        : { orderBy?: RoomTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomTBL model
   */
  readonly fields: RoomTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoomTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    officeref<T extends OfficeTBLArgs<ExtArgs> = {}>(args?: Subset<T, OfficeTBLArgs<ExtArgs>>): Prisma__OfficeTBLClient<$Types.GetResult<OfficeTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    roomdepref<T extends DepartmentTBLArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentTBLArgs<ExtArgs>>): Prisma__DepartmentTBLClient<$Types.GetResult<DepartmentTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    Employee<T extends RoomTBL$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, RoomTBL$EmployeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the RoomTBL model
   */ 
  interface RoomTBLFieldRefs {
    readonly roomid: FieldRef<"RoomTBL", 'Int'>
    readonly roomno: FieldRef<"RoomTBL", 'Int'>
    readonly roomname: FieldRef<"RoomTBL", 'String'>
    readonly officeid: FieldRef<"RoomTBL", 'Int'>
    readonly departmentid: FieldRef<"RoomTBL", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * RoomTBL findUnique
   */
  export type RoomTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTBL
     */
    select?: RoomTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomTBLInclude<ExtArgs> | null
    /**
     * Filter, which RoomTBL to fetch.
     */
    where: RoomTBLWhereUniqueInput
  }


  /**
   * RoomTBL findUniqueOrThrow
   */
  export type RoomTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTBL
     */
    select?: RoomTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomTBLInclude<ExtArgs> | null
    /**
     * Filter, which RoomTBL to fetch.
     */
    where: RoomTBLWhereUniqueInput
  }


  /**
   * RoomTBL findFirst
   */
  export type RoomTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTBL
     */
    select?: RoomTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomTBLInclude<ExtArgs> | null
    /**
     * Filter, which RoomTBL to fetch.
     */
    where?: RoomTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTBLS to fetch.
     */
    orderBy?: RoomTBLOrderByWithRelationInput | RoomTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTBLS.
     */
    cursor?: RoomTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTBLS.
     */
    distinct?: RoomTBLScalarFieldEnum | RoomTBLScalarFieldEnum[]
  }


  /**
   * RoomTBL findFirstOrThrow
   */
  export type RoomTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTBL
     */
    select?: RoomTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomTBLInclude<ExtArgs> | null
    /**
     * Filter, which RoomTBL to fetch.
     */
    where?: RoomTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTBLS to fetch.
     */
    orderBy?: RoomTBLOrderByWithRelationInput | RoomTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTBLS.
     */
    cursor?: RoomTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTBLS.
     */
    distinct?: RoomTBLScalarFieldEnum | RoomTBLScalarFieldEnum[]
  }


  /**
   * RoomTBL findMany
   */
  export type RoomTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTBL
     */
    select?: RoomTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomTBLInclude<ExtArgs> | null
    /**
     * Filter, which RoomTBLS to fetch.
     */
    where?: RoomTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTBLS to fetch.
     */
    orderBy?: RoomTBLOrderByWithRelationInput | RoomTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomTBLS.
     */
    cursor?: RoomTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTBLS.
     */
    skip?: number
    distinct?: RoomTBLScalarFieldEnum | RoomTBLScalarFieldEnum[]
  }


  /**
   * RoomTBL create
   */
  export type RoomTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTBL
     */
    select?: RoomTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomTBL.
     */
    data: XOR<RoomTBLCreateInput, RoomTBLUncheckedCreateInput>
  }


  /**
   * RoomTBL createMany
   */
  export type RoomTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomTBLS.
     */
    data: RoomTBLCreateManyInput | RoomTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RoomTBL update
   */
  export type RoomTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTBL
     */
    select?: RoomTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomTBL.
     */
    data: XOR<RoomTBLUpdateInput, RoomTBLUncheckedUpdateInput>
    /**
     * Choose, which RoomTBL to update.
     */
    where: RoomTBLWhereUniqueInput
  }


  /**
   * RoomTBL updateMany
   */
  export type RoomTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomTBLS.
     */
    data: XOR<RoomTBLUpdateManyMutationInput, RoomTBLUncheckedUpdateManyInput>
    /**
     * Filter which RoomTBLS to update
     */
    where?: RoomTBLWhereInput
  }


  /**
   * RoomTBL upsert
   */
  export type RoomTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTBL
     */
    select?: RoomTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomTBL to update in case it exists.
     */
    where: RoomTBLWhereUniqueInput
    /**
     * In case the RoomTBL found by the `where` argument doesn't exist, create a new RoomTBL with this data.
     */
    create: XOR<RoomTBLCreateInput, RoomTBLUncheckedCreateInput>
    /**
     * In case the RoomTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomTBLUpdateInput, RoomTBLUncheckedUpdateInput>
  }


  /**
   * RoomTBL delete
   */
  export type RoomTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTBL
     */
    select?: RoomTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomTBLInclude<ExtArgs> | null
    /**
     * Filter which RoomTBL to delete.
     */
    where: RoomTBLWhereUniqueInput
  }


  /**
   * RoomTBL deleteMany
   */
  export type RoomTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomTBLS to delete
     */
    where?: RoomTBLWhereInput
  }


  /**
   * RoomTBL.Employee
   */
  export type RoomTBL$EmployeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTBL
     */
    select?: EmployeeTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeTBLInclude<ExtArgs> | null
    where?: EmployeeTBLWhereInput
    orderBy?: EmployeeTBLOrderByWithRelationInput | EmployeeTBLOrderByWithRelationInput[]
    cursor?: EmployeeTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTBLScalarFieldEnum | EmployeeTBLScalarFieldEnum[]
  }


  /**
   * RoomTBL without action
   */
  export type RoomTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTBL
     */
    select?: RoomTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomTBLInclude<ExtArgs> | null
  }



  /**
   * Model CategoriesTbl
   */


  export type AggregateCategoriesTbl = {
    _count: CategoriesTblCountAggregateOutputType | null
    _avg: CategoriesTblAvgAggregateOutputType | null
    _sum: CategoriesTblSumAggregateOutputType | null
    _min: CategoriesTblMinAggregateOutputType | null
    _max: CategoriesTblMaxAggregateOutputType | null
  }

  export type CategoriesTblAvgAggregateOutputType = {
    categoryid: number | null
  }

  export type CategoriesTblSumAggregateOutputType = {
    categoryid: number | null
  }

  export type CategoriesTblMinAggregateOutputType = {
    categoryid: number | null
    categoryname: string | null
  }

  export type CategoriesTblMaxAggregateOutputType = {
    categoryid: number | null
    categoryname: string | null
  }

  export type CategoriesTblCountAggregateOutputType = {
    categoryid: number
    categoryname: number
    _all: number
  }


  export type CategoriesTblAvgAggregateInputType = {
    categoryid?: true
  }

  export type CategoriesTblSumAggregateInputType = {
    categoryid?: true
  }

  export type CategoriesTblMinAggregateInputType = {
    categoryid?: true
    categoryname?: true
  }

  export type CategoriesTblMaxAggregateInputType = {
    categoryid?: true
    categoryname?: true
  }

  export type CategoriesTblCountAggregateInputType = {
    categoryid?: true
    categoryname?: true
    _all?: true
  }

  export type CategoriesTblAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoriesTbl to aggregate.
     */
    where?: CategoriesTblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriesTbls to fetch.
     */
    orderBy?: CategoriesTblOrderByWithRelationInput | CategoriesTblOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriesTblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriesTbls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriesTbls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoriesTbls
    **/
    _count?: true | CategoriesTblCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriesTblAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriesTblSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesTblMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesTblMaxAggregateInputType
  }

  export type GetCategoriesTblAggregateType<T extends CategoriesTblAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoriesTbl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoriesTbl[P]>
      : GetScalarType<T[P], AggregateCategoriesTbl[P]>
  }




  export type CategoriesTblGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoriesTblWhereInput
    orderBy?: CategoriesTblOrderByWithAggregationInput | CategoriesTblOrderByWithAggregationInput[]
    by: CategoriesTblScalarFieldEnum[] | CategoriesTblScalarFieldEnum
    having?: CategoriesTblScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesTblCountAggregateInputType | true
    _avg?: CategoriesTblAvgAggregateInputType
    _sum?: CategoriesTblSumAggregateInputType
    _min?: CategoriesTblMinAggregateInputType
    _max?: CategoriesTblMaxAggregateInputType
  }


  export type CategoriesTblGroupByOutputType = {
    categoryid: number
    categoryname: string
    _count: CategoriesTblCountAggregateOutputType | null
    _avg: CategoriesTblAvgAggregateOutputType | null
    _sum: CategoriesTblSumAggregateOutputType | null
    _min: CategoriesTblMinAggregateOutputType | null
    _max: CategoriesTblMaxAggregateOutputType | null
  }

  type GetCategoriesTblGroupByPayload<T extends CategoriesTblGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesTblGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesTblGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesTblGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesTblGroupByOutputType[P]>
        }
      >
    >


  export type CategoriesTblSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    categoryid?: boolean
    categoryname?: boolean
    Item?: boolean | CategoriesTbl$ItemArgs<ExtArgs>
    _count?: boolean | CategoriesTblCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["categoriesTbl"]>

  export type CategoriesTblSelectScalar = {
    categoryid?: boolean
    categoryname?: boolean
  }

  export type CategoriesTblInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Item?: boolean | CategoriesTbl$ItemArgs<ExtArgs>
    _count?: boolean | CategoriesTblCountOutputTypeArgs<ExtArgs>
  }


  type CategoriesTblGetPayload<S extends boolean | null | undefined | CategoriesTblArgs> = $Types.GetResult<CategoriesTblPayload, S>

  type CategoriesTblCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CategoriesTblFindManyArgs, 'select' | 'include'> & {
      select?: CategoriesTblCountAggregateInputType | true
    }

  export interface CategoriesTblDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoriesTbl'], meta: { name: 'CategoriesTbl' } }
    /**
     * Find zero or one CategoriesTbl that matches the filter.
     * @param {CategoriesTblFindUniqueArgs} args - Arguments to find a CategoriesTbl
     * @example
     * // Get one CategoriesTbl
     * const categoriesTbl = await prisma.categoriesTbl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoriesTblFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriesTblFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoriesTblClient<$Types.GetResult<CategoriesTblPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CategoriesTbl that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoriesTblFindUniqueOrThrowArgs} args - Arguments to find a CategoriesTbl
     * @example
     * // Get one CategoriesTbl
     * const categoriesTbl = await prisma.categoriesTbl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoriesTblFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriesTblFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoriesTblClient<$Types.GetResult<CategoriesTblPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CategoriesTbl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesTblFindFirstArgs} args - Arguments to find a CategoriesTbl
     * @example
     * // Get one CategoriesTbl
     * const categoriesTbl = await prisma.categoriesTbl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoriesTblFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriesTblFindFirstArgs<ExtArgs>>
    ): Prisma__CategoriesTblClient<$Types.GetResult<CategoriesTblPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CategoriesTbl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesTblFindFirstOrThrowArgs} args - Arguments to find a CategoriesTbl
     * @example
     * // Get one CategoriesTbl
     * const categoriesTbl = await prisma.categoriesTbl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoriesTblFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriesTblFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoriesTblClient<$Types.GetResult<CategoriesTblPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CategoriesTbls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesTblFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoriesTbls
     * const categoriesTbls = await prisma.categoriesTbl.findMany()
     * 
     * // Get first 10 CategoriesTbls
     * const categoriesTbls = await prisma.categoriesTbl.findMany({ take: 10 })
     * 
     * // Only select the `categoryid`
     * const categoriesTblWithCategoryidOnly = await prisma.categoriesTbl.findMany({ select: { categoryid: true } })
     * 
    **/
    findMany<T extends CategoriesTblFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriesTblFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CategoriesTblPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CategoriesTbl.
     * @param {CategoriesTblCreateArgs} args - Arguments to create a CategoriesTbl.
     * @example
     * // Create one CategoriesTbl
     * const CategoriesTbl = await prisma.categoriesTbl.create({
     *   data: {
     *     // ... data to create a CategoriesTbl
     *   }
     * })
     * 
    **/
    create<T extends CategoriesTblCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriesTblCreateArgs<ExtArgs>>
    ): Prisma__CategoriesTblClient<$Types.GetResult<CategoriesTblPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CategoriesTbls.
     *     @param {CategoriesTblCreateManyArgs} args - Arguments to create many CategoriesTbls.
     *     @example
     *     // Create many CategoriesTbls
     *     const categoriesTbl = await prisma.categoriesTbl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoriesTblCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriesTblCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CategoriesTbl.
     * @param {CategoriesTblDeleteArgs} args - Arguments to delete one CategoriesTbl.
     * @example
     * // Delete one CategoriesTbl
     * const CategoriesTbl = await prisma.categoriesTbl.delete({
     *   where: {
     *     // ... filter to delete one CategoriesTbl
     *   }
     * })
     * 
    **/
    delete<T extends CategoriesTblDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriesTblDeleteArgs<ExtArgs>>
    ): Prisma__CategoriesTblClient<$Types.GetResult<CategoriesTblPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CategoriesTbl.
     * @param {CategoriesTblUpdateArgs} args - Arguments to update one CategoriesTbl.
     * @example
     * // Update one CategoriesTbl
     * const categoriesTbl = await prisma.categoriesTbl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoriesTblUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriesTblUpdateArgs<ExtArgs>>
    ): Prisma__CategoriesTblClient<$Types.GetResult<CategoriesTblPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CategoriesTbls.
     * @param {CategoriesTblDeleteManyArgs} args - Arguments to filter CategoriesTbls to delete.
     * @example
     * // Delete a few CategoriesTbls
     * const { count } = await prisma.categoriesTbl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoriesTblDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriesTblDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoriesTbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesTblUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoriesTbls
     * const categoriesTbl = await prisma.categoriesTbl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoriesTblUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriesTblUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CategoriesTbl.
     * @param {CategoriesTblUpsertArgs} args - Arguments to update or create a CategoriesTbl.
     * @example
     * // Update or create a CategoriesTbl
     * const categoriesTbl = await prisma.categoriesTbl.upsert({
     *   create: {
     *     // ... data to create a CategoriesTbl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoriesTbl we want to update
     *   }
     * })
    **/
    upsert<T extends CategoriesTblUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriesTblUpsertArgs<ExtArgs>>
    ): Prisma__CategoriesTblClient<$Types.GetResult<CategoriesTblPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CategoriesTbls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesTblCountArgs} args - Arguments to filter CategoriesTbls to count.
     * @example
     * // Count the number of CategoriesTbls
     * const count = await prisma.categoriesTbl.count({
     *   where: {
     *     // ... the filter for the CategoriesTbls we want to count
     *   }
     * })
    **/
    count<T extends CategoriesTblCountArgs>(
      args?: Subset<T, CategoriesTblCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesTblCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoriesTbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesTblAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesTblAggregateArgs>(args: Subset<T, CategoriesTblAggregateArgs>): Prisma.PrismaPromise<GetCategoriesTblAggregateType<T>>

    /**
     * Group by CategoriesTbl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesTblGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriesTblGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriesTblGroupByArgs['orderBy'] }
        : { orderBy?: CategoriesTblGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriesTblGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesTblGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoriesTbl model
   */
  readonly fields: CategoriesTblFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoriesTbl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoriesTblClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Item<T extends CategoriesTbl$ItemArgs<ExtArgs> = {}>(args?: Subset<T, CategoriesTbl$ItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ItemsTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the CategoriesTbl model
   */ 
  interface CategoriesTblFieldRefs {
    readonly categoryid: FieldRef<"CategoriesTbl", 'Int'>
    readonly categoryname: FieldRef<"CategoriesTbl", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CategoriesTbl findUnique
   */
  export type CategoriesTblFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesTbl
     */
    select?: CategoriesTblSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriesTblInclude<ExtArgs> | null
    /**
     * Filter, which CategoriesTbl to fetch.
     */
    where: CategoriesTblWhereUniqueInput
  }


  /**
   * CategoriesTbl findUniqueOrThrow
   */
  export type CategoriesTblFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesTbl
     */
    select?: CategoriesTblSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriesTblInclude<ExtArgs> | null
    /**
     * Filter, which CategoriesTbl to fetch.
     */
    where: CategoriesTblWhereUniqueInput
  }


  /**
   * CategoriesTbl findFirst
   */
  export type CategoriesTblFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesTbl
     */
    select?: CategoriesTblSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriesTblInclude<ExtArgs> | null
    /**
     * Filter, which CategoriesTbl to fetch.
     */
    where?: CategoriesTblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriesTbls to fetch.
     */
    orderBy?: CategoriesTblOrderByWithRelationInput | CategoriesTblOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoriesTbls.
     */
    cursor?: CategoriesTblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriesTbls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriesTbls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoriesTbls.
     */
    distinct?: CategoriesTblScalarFieldEnum | CategoriesTblScalarFieldEnum[]
  }


  /**
   * CategoriesTbl findFirstOrThrow
   */
  export type CategoriesTblFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesTbl
     */
    select?: CategoriesTblSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriesTblInclude<ExtArgs> | null
    /**
     * Filter, which CategoriesTbl to fetch.
     */
    where?: CategoriesTblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriesTbls to fetch.
     */
    orderBy?: CategoriesTblOrderByWithRelationInput | CategoriesTblOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoriesTbls.
     */
    cursor?: CategoriesTblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriesTbls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriesTbls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoriesTbls.
     */
    distinct?: CategoriesTblScalarFieldEnum | CategoriesTblScalarFieldEnum[]
  }


  /**
   * CategoriesTbl findMany
   */
  export type CategoriesTblFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesTbl
     */
    select?: CategoriesTblSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriesTblInclude<ExtArgs> | null
    /**
     * Filter, which CategoriesTbls to fetch.
     */
    where?: CategoriesTblWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriesTbls to fetch.
     */
    orderBy?: CategoriesTblOrderByWithRelationInput | CategoriesTblOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoriesTbls.
     */
    cursor?: CategoriesTblWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriesTbls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriesTbls.
     */
    skip?: number
    distinct?: CategoriesTblScalarFieldEnum | CategoriesTblScalarFieldEnum[]
  }


  /**
   * CategoriesTbl create
   */
  export type CategoriesTblCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesTbl
     */
    select?: CategoriesTblSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriesTblInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoriesTbl.
     */
    data: XOR<CategoriesTblCreateInput, CategoriesTblUncheckedCreateInput>
  }


  /**
   * CategoriesTbl createMany
   */
  export type CategoriesTblCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoriesTbls.
     */
    data: CategoriesTblCreateManyInput | CategoriesTblCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CategoriesTbl update
   */
  export type CategoriesTblUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesTbl
     */
    select?: CategoriesTblSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriesTblInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoriesTbl.
     */
    data: XOR<CategoriesTblUpdateInput, CategoriesTblUncheckedUpdateInput>
    /**
     * Choose, which CategoriesTbl to update.
     */
    where: CategoriesTblWhereUniqueInput
  }


  /**
   * CategoriesTbl updateMany
   */
  export type CategoriesTblUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoriesTbls.
     */
    data: XOR<CategoriesTblUpdateManyMutationInput, CategoriesTblUncheckedUpdateManyInput>
    /**
     * Filter which CategoriesTbls to update
     */
    where?: CategoriesTblWhereInput
  }


  /**
   * CategoriesTbl upsert
   */
  export type CategoriesTblUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesTbl
     */
    select?: CategoriesTblSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriesTblInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoriesTbl to update in case it exists.
     */
    where: CategoriesTblWhereUniqueInput
    /**
     * In case the CategoriesTbl found by the `where` argument doesn't exist, create a new CategoriesTbl with this data.
     */
    create: XOR<CategoriesTblCreateInput, CategoriesTblUncheckedCreateInput>
    /**
     * In case the CategoriesTbl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriesTblUpdateInput, CategoriesTblUncheckedUpdateInput>
  }


  /**
   * CategoriesTbl delete
   */
  export type CategoriesTblDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesTbl
     */
    select?: CategoriesTblSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriesTblInclude<ExtArgs> | null
    /**
     * Filter which CategoriesTbl to delete.
     */
    where: CategoriesTblWhereUniqueInput
  }


  /**
   * CategoriesTbl deleteMany
   */
  export type CategoriesTblDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoriesTbls to delete
     */
    where?: CategoriesTblWhereInput
  }


  /**
   * CategoriesTbl.Item
   */
  export type CategoriesTbl$ItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsTBL
     */
    select?: ItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsTBLInclude<ExtArgs> | null
    where?: ItemsTBLWhereInput
    orderBy?: ItemsTBLOrderByWithRelationInput | ItemsTBLOrderByWithRelationInput[]
    cursor?: ItemsTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsTBLScalarFieldEnum | ItemsTBLScalarFieldEnum[]
  }


  /**
   * CategoriesTbl without action
   */
  export type CategoriesTblArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesTbl
     */
    select?: CategoriesTblSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriesTblInclude<ExtArgs> | null
  }



  /**
   * Model ItemsTBL
   */


  export type AggregateItemsTBL = {
    _count: ItemsTBLCountAggregateOutputType | null
    _avg: ItemsTBLAvgAggregateOutputType | null
    _sum: ItemsTBLSumAggregateOutputType | null
    _min: ItemsTBLMinAggregateOutputType | null
    _max: ItemsTBLMaxAggregateOutputType | null
  }

  export type ItemsTBLAvgAggregateOutputType = {
    userid: number | null
    itemid: number | null
    categoryid: number | null
  }

  export type ItemsTBLSumAggregateOutputType = {
    userid: number | null
    itemid: number | null
    categoryid: number | null
  }

  export type ItemsTBLMinAggregateOutputType = {
    userid: number | null
    itemid: number | null
    categoryid: number | null
    itemname: string | null
    itemimagurl: string | null
    itemidescription: string | null
  }

  export type ItemsTBLMaxAggregateOutputType = {
    userid: number | null
    itemid: number | null
    categoryid: number | null
    itemname: string | null
    itemimagurl: string | null
    itemidescription: string | null
  }

  export type ItemsTBLCountAggregateOutputType = {
    userid: number
    itemid: number
    categoryid: number
    itemname: number
    itemimagurl: number
    itemidescription: number
    _all: number
  }


  export type ItemsTBLAvgAggregateInputType = {
    userid?: true
    itemid?: true
    categoryid?: true
  }

  export type ItemsTBLSumAggregateInputType = {
    userid?: true
    itemid?: true
    categoryid?: true
  }

  export type ItemsTBLMinAggregateInputType = {
    userid?: true
    itemid?: true
    categoryid?: true
    itemname?: true
    itemimagurl?: true
    itemidescription?: true
  }

  export type ItemsTBLMaxAggregateInputType = {
    userid?: true
    itemid?: true
    categoryid?: true
    itemname?: true
    itemimagurl?: true
    itemidescription?: true
  }

  export type ItemsTBLCountAggregateInputType = {
    userid?: true
    itemid?: true
    categoryid?: true
    itemname?: true
    itemimagurl?: true
    itemidescription?: true
    _all?: true
  }

  export type ItemsTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemsTBL to aggregate.
     */
    where?: ItemsTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemsTBLS to fetch.
     */
    orderBy?: ItemsTBLOrderByWithRelationInput | ItemsTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemsTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemsTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemsTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemsTBLS
    **/
    _count?: true | ItemsTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemsTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemsTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemsTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemsTBLMaxAggregateInputType
  }

  export type GetItemsTBLAggregateType<T extends ItemsTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateItemsTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemsTBL[P]>
      : GetScalarType<T[P], AggregateItemsTBL[P]>
  }




  export type ItemsTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ItemsTBLWhereInput
    orderBy?: ItemsTBLOrderByWithAggregationInput | ItemsTBLOrderByWithAggregationInput[]
    by: ItemsTBLScalarFieldEnum[] | ItemsTBLScalarFieldEnum
    having?: ItemsTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemsTBLCountAggregateInputType | true
    _avg?: ItemsTBLAvgAggregateInputType
    _sum?: ItemsTBLSumAggregateInputType
    _min?: ItemsTBLMinAggregateInputType
    _max?: ItemsTBLMaxAggregateInputType
  }


  export type ItemsTBLGroupByOutputType = {
    userid: number
    itemid: number
    categoryid: number
    itemname: string
    itemimagurl: string
    itemidescription: string
    _count: ItemsTBLCountAggregateOutputType | null
    _avg: ItemsTBLAvgAggregateOutputType | null
    _sum: ItemsTBLSumAggregateOutputType | null
    _min: ItemsTBLMinAggregateOutputType | null
    _max: ItemsTBLMaxAggregateOutputType | null
  }

  type GetItemsTBLGroupByPayload<T extends ItemsTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemsTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemsTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemsTBLGroupByOutputType[P]>
            : GetScalarType<T[P], ItemsTBLGroupByOutputType[P]>
        }
      >
    >


  export type ItemsTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    itemid?: boolean
    categoryid?: boolean
    itemname?: boolean
    itemimagurl?: boolean
    itemidescription?: boolean
    creator?: boolean | UsersTBLArgs<ExtArgs>
    catid?: boolean | CategoriesTblArgs<ExtArgs>
    CartItems?: boolean | ItemsTBL$CartItemsArgs<ExtArgs>
    _count?: boolean | ItemsTBLCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["itemsTBL"]>

  export type ItemsTBLSelectScalar = {
    userid?: boolean
    itemid?: boolean
    categoryid?: boolean
    itemname?: boolean
    itemimagurl?: boolean
    itemidescription?: boolean
  }

  export type ItemsTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    creator?: boolean | UsersTBLArgs<ExtArgs>
    catid?: boolean | CategoriesTblArgs<ExtArgs>
    CartItems?: boolean | ItemsTBL$CartItemsArgs<ExtArgs>
    _count?: boolean | ItemsTBLCountOutputTypeArgs<ExtArgs>
  }


  type ItemsTBLGetPayload<S extends boolean | null | undefined | ItemsTBLArgs> = $Types.GetResult<ItemsTBLPayload, S>

  type ItemsTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ItemsTBLFindManyArgs, 'select' | 'include'> & {
      select?: ItemsTBLCountAggregateInputType | true
    }

  export interface ItemsTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemsTBL'], meta: { name: 'ItemsTBL' } }
    /**
     * Find zero or one ItemsTBL that matches the filter.
     * @param {ItemsTBLFindUniqueArgs} args - Arguments to find a ItemsTBL
     * @example
     * // Get one ItemsTBL
     * const itemsTBL = await prisma.itemsTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemsTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemsTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemsTBLClient<$Types.GetResult<ItemsTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemsTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemsTBLFindUniqueOrThrowArgs} args - Arguments to find a ItemsTBL
     * @example
     * // Get one ItemsTBL
     * const itemsTBL = await prisma.itemsTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemsTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemsTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemsTBLClient<$Types.GetResult<ItemsTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemsTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsTBLFindFirstArgs} args - Arguments to find a ItemsTBL
     * @example
     * // Get one ItemsTBL
     * const itemsTBL = await prisma.itemsTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemsTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemsTBLFindFirstArgs<ExtArgs>>
    ): Prisma__ItemsTBLClient<$Types.GetResult<ItemsTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemsTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsTBLFindFirstOrThrowArgs} args - Arguments to find a ItemsTBL
     * @example
     * // Get one ItemsTBL
     * const itemsTBL = await prisma.itemsTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemsTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemsTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemsTBLClient<$Types.GetResult<ItemsTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemsTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemsTBLS
     * const itemsTBLS = await prisma.itemsTBL.findMany()
     * 
     * // Get first 10 ItemsTBLS
     * const itemsTBLS = await prisma.itemsTBL.findMany({ take: 10 })
     * 
     * // Only select the `userid`
     * const itemsTBLWithUseridOnly = await prisma.itemsTBL.findMany({ select: { userid: true } })
     * 
    **/
    findMany<T extends ItemsTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemsTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ItemsTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemsTBL.
     * @param {ItemsTBLCreateArgs} args - Arguments to create a ItemsTBL.
     * @example
     * // Create one ItemsTBL
     * const ItemsTBL = await prisma.itemsTBL.create({
     *   data: {
     *     // ... data to create a ItemsTBL
     *   }
     * })
     * 
    **/
    create<T extends ItemsTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemsTBLCreateArgs<ExtArgs>>
    ): Prisma__ItemsTBLClient<$Types.GetResult<ItemsTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemsTBLS.
     *     @param {ItemsTBLCreateManyArgs} args - Arguments to create many ItemsTBLS.
     *     @example
     *     // Create many ItemsTBLS
     *     const itemsTBL = await prisma.itemsTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemsTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemsTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemsTBL.
     * @param {ItemsTBLDeleteArgs} args - Arguments to delete one ItemsTBL.
     * @example
     * // Delete one ItemsTBL
     * const ItemsTBL = await prisma.itemsTBL.delete({
     *   where: {
     *     // ... filter to delete one ItemsTBL
     *   }
     * })
     * 
    **/
    delete<T extends ItemsTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemsTBLDeleteArgs<ExtArgs>>
    ): Prisma__ItemsTBLClient<$Types.GetResult<ItemsTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemsTBL.
     * @param {ItemsTBLUpdateArgs} args - Arguments to update one ItemsTBL.
     * @example
     * // Update one ItemsTBL
     * const itemsTBL = await prisma.itemsTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemsTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemsTBLUpdateArgs<ExtArgs>>
    ): Prisma__ItemsTBLClient<$Types.GetResult<ItemsTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemsTBLS.
     * @param {ItemsTBLDeleteManyArgs} args - Arguments to filter ItemsTBLS to delete.
     * @example
     * // Delete a few ItemsTBLS
     * const { count } = await prisma.itemsTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemsTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemsTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemsTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemsTBLS
     * const itemsTBL = await prisma.itemsTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemsTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemsTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemsTBL.
     * @param {ItemsTBLUpsertArgs} args - Arguments to update or create a ItemsTBL.
     * @example
     * // Update or create a ItemsTBL
     * const itemsTBL = await prisma.itemsTBL.upsert({
     *   create: {
     *     // ... data to create a ItemsTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemsTBL we want to update
     *   }
     * })
    **/
    upsert<T extends ItemsTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemsTBLUpsertArgs<ExtArgs>>
    ): Prisma__ItemsTBLClient<$Types.GetResult<ItemsTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemsTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsTBLCountArgs} args - Arguments to filter ItemsTBLS to count.
     * @example
     * // Count the number of ItemsTBLS
     * const count = await prisma.itemsTBL.count({
     *   where: {
     *     // ... the filter for the ItemsTBLS we want to count
     *   }
     * })
    **/
    count<T extends ItemsTBLCountArgs>(
      args?: Subset<T, ItemsTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemsTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemsTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemsTBLAggregateArgs>(args: Subset<T, ItemsTBLAggregateArgs>): Prisma.PrismaPromise<GetItemsTBLAggregateType<T>>

    /**
     * Group by ItemsTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemsTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemsTBLGroupByArgs['orderBy'] }
        : { orderBy?: ItemsTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemsTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemsTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemsTBL model
   */
  readonly fields: ItemsTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemsTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ItemsTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    creator<T extends UsersTBLArgs<ExtArgs> = {}>(args?: Subset<T, UsersTBLArgs<ExtArgs>>): Prisma__UsersTBLClient<$Types.GetResult<UsersTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    catid<T extends CategoriesTblArgs<ExtArgs> = {}>(args?: Subset<T, CategoriesTblArgs<ExtArgs>>): Prisma__CategoriesTblClient<$Types.GetResult<CategoriesTblPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    CartItems<T extends ItemsTBL$CartItemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemsTBL$CartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CartItemsTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ItemsTBL model
   */ 
  interface ItemsTBLFieldRefs {
    readonly userid: FieldRef<"ItemsTBL", 'Int'>
    readonly itemid: FieldRef<"ItemsTBL", 'Int'>
    readonly categoryid: FieldRef<"ItemsTBL", 'Int'>
    readonly itemname: FieldRef<"ItemsTBL", 'String'>
    readonly itemimagurl: FieldRef<"ItemsTBL", 'String'>
    readonly itemidescription: FieldRef<"ItemsTBL", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ItemsTBL findUnique
   */
  export type ItemsTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsTBL
     */
    select?: ItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which ItemsTBL to fetch.
     */
    where: ItemsTBLWhereUniqueInput
  }


  /**
   * ItemsTBL findUniqueOrThrow
   */
  export type ItemsTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsTBL
     */
    select?: ItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which ItemsTBL to fetch.
     */
    where: ItemsTBLWhereUniqueInput
  }


  /**
   * ItemsTBL findFirst
   */
  export type ItemsTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsTBL
     */
    select?: ItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which ItemsTBL to fetch.
     */
    where?: ItemsTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemsTBLS to fetch.
     */
    orderBy?: ItemsTBLOrderByWithRelationInput | ItemsTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemsTBLS.
     */
    cursor?: ItemsTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemsTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemsTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemsTBLS.
     */
    distinct?: ItemsTBLScalarFieldEnum | ItemsTBLScalarFieldEnum[]
  }


  /**
   * ItemsTBL findFirstOrThrow
   */
  export type ItemsTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsTBL
     */
    select?: ItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which ItemsTBL to fetch.
     */
    where?: ItemsTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemsTBLS to fetch.
     */
    orderBy?: ItemsTBLOrderByWithRelationInput | ItemsTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemsTBLS.
     */
    cursor?: ItemsTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemsTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemsTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemsTBLS.
     */
    distinct?: ItemsTBLScalarFieldEnum | ItemsTBLScalarFieldEnum[]
  }


  /**
   * ItemsTBL findMany
   */
  export type ItemsTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsTBL
     */
    select?: ItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which ItemsTBLS to fetch.
     */
    where?: ItemsTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemsTBLS to fetch.
     */
    orderBy?: ItemsTBLOrderByWithRelationInput | ItemsTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemsTBLS.
     */
    cursor?: ItemsTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemsTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemsTBLS.
     */
    skip?: number
    distinct?: ItemsTBLScalarFieldEnum | ItemsTBLScalarFieldEnum[]
  }


  /**
   * ItemsTBL create
   */
  export type ItemsTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsTBL
     */
    select?: ItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemsTBL.
     */
    data: XOR<ItemsTBLCreateInput, ItemsTBLUncheckedCreateInput>
  }


  /**
   * ItemsTBL createMany
   */
  export type ItemsTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemsTBLS.
     */
    data: ItemsTBLCreateManyInput | ItemsTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemsTBL update
   */
  export type ItemsTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsTBL
     */
    select?: ItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemsTBL.
     */
    data: XOR<ItemsTBLUpdateInput, ItemsTBLUncheckedUpdateInput>
    /**
     * Choose, which ItemsTBL to update.
     */
    where: ItemsTBLWhereUniqueInput
  }


  /**
   * ItemsTBL updateMany
   */
  export type ItemsTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemsTBLS.
     */
    data: XOR<ItemsTBLUpdateManyMutationInput, ItemsTBLUncheckedUpdateManyInput>
    /**
     * Filter which ItemsTBLS to update
     */
    where?: ItemsTBLWhereInput
  }


  /**
   * ItemsTBL upsert
   */
  export type ItemsTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsTBL
     */
    select?: ItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemsTBL to update in case it exists.
     */
    where: ItemsTBLWhereUniqueInput
    /**
     * In case the ItemsTBL found by the `where` argument doesn't exist, create a new ItemsTBL with this data.
     */
    create: XOR<ItemsTBLCreateInput, ItemsTBLUncheckedCreateInput>
    /**
     * In case the ItemsTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemsTBLUpdateInput, ItemsTBLUncheckedUpdateInput>
  }


  /**
   * ItemsTBL delete
   */
  export type ItemsTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsTBL
     */
    select?: ItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsTBLInclude<ExtArgs> | null
    /**
     * Filter which ItemsTBL to delete.
     */
    where: ItemsTBLWhereUniqueInput
  }


  /**
   * ItemsTBL deleteMany
   */
  export type ItemsTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemsTBLS to delete
     */
    where?: ItemsTBLWhereInput
  }


  /**
   * ItemsTBL.CartItems
   */
  export type ItemsTBL$CartItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemsTBL
     */
    select?: CartItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartItemsTBLInclude<ExtArgs> | null
    where?: CartItemsTBLWhereInput
    orderBy?: CartItemsTBLOrderByWithRelationInput | CartItemsTBLOrderByWithRelationInput[]
    cursor?: CartItemsTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemsTBLScalarFieldEnum | CartItemsTBLScalarFieldEnum[]
  }


  /**
   * ItemsTBL without action
   */
  export type ItemsTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsTBL
     */
    select?: ItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsTBLInclude<ExtArgs> | null
  }



  /**
   * Model OrdersTBL
   */


  export type AggregateOrdersTBL = {
    _count: OrdersTBLCountAggregateOutputType | null
    _avg: OrdersTBLAvgAggregateOutputType | null
    _sum: OrdersTBLSumAggregateOutputType | null
    _min: OrdersTBLMinAggregateOutputType | null
    _max: OrdersTBLMaxAggregateOutputType | null
  }

  export type OrdersTBLAvgAggregateOutputType = {
    orderid: number | null
    empid: number | null
  }

  export type OrdersTBLSumAggregateOutputType = {
    orderid: number | null
    empid: number | null
  }

  export type OrdersTBLMinAggregateOutputType = {
    orderid: number | null
    empid: number | null
  }

  export type OrdersTBLMaxAggregateOutputType = {
    orderid: number | null
    empid: number | null
  }

  export type OrdersTBLCountAggregateOutputType = {
    orderid: number
    empid: number
    _all: number
  }


  export type OrdersTBLAvgAggregateInputType = {
    orderid?: true
    empid?: true
  }

  export type OrdersTBLSumAggregateInputType = {
    orderid?: true
    empid?: true
  }

  export type OrdersTBLMinAggregateInputType = {
    orderid?: true
    empid?: true
  }

  export type OrdersTBLMaxAggregateInputType = {
    orderid?: true
    empid?: true
  }

  export type OrdersTBLCountAggregateInputType = {
    orderid?: true
    empid?: true
    _all?: true
  }

  export type OrdersTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrdersTBL to aggregate.
     */
    where?: OrdersTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdersTBLS to fetch.
     */
    orderBy?: OrdersTBLOrderByWithRelationInput | OrdersTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrdersTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdersTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdersTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrdersTBLS
    **/
    _count?: true | OrdersTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdersTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdersTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersTBLMaxAggregateInputType
  }

  export type GetOrdersTBLAggregateType<T extends OrdersTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateOrdersTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrdersTBL[P]>
      : GetScalarType<T[P], AggregateOrdersTBL[P]>
  }




  export type OrdersTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrdersTBLWhereInput
    orderBy?: OrdersTBLOrderByWithAggregationInput | OrdersTBLOrderByWithAggregationInput[]
    by: OrdersTBLScalarFieldEnum[] | OrdersTBLScalarFieldEnum
    having?: OrdersTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersTBLCountAggregateInputType | true
    _avg?: OrdersTBLAvgAggregateInputType
    _sum?: OrdersTBLSumAggregateInputType
    _min?: OrdersTBLMinAggregateInputType
    _max?: OrdersTBLMaxAggregateInputType
  }


  export type OrdersTBLGroupByOutputType = {
    orderid: number
    empid: number
    _count: OrdersTBLCountAggregateOutputType | null
    _avg: OrdersTBLAvgAggregateOutputType | null
    _sum: OrdersTBLSumAggregateOutputType | null
    _min: OrdersTBLMinAggregateOutputType | null
    _max: OrdersTBLMaxAggregateOutputType | null
  }

  type GetOrdersTBLGroupByPayload<T extends OrdersTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdersTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersTBLGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersTBLGroupByOutputType[P]>
        }
      >
    >


  export type OrdersTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderid?: boolean
    empid?: boolean
    empref?: boolean | EmployeeTBLArgs<ExtArgs>
    orderItems?: boolean | OrdersTBL$orderItemsArgs<ExtArgs>
    _count?: boolean | OrdersTBLCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["ordersTBL"]>

  export type OrdersTBLSelectScalar = {
    orderid?: boolean
    empid?: boolean
  }

  export type OrdersTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    empref?: boolean | EmployeeTBLArgs<ExtArgs>
    orderItems?: boolean | OrdersTBL$orderItemsArgs<ExtArgs>
    _count?: boolean | OrdersTBLCountOutputTypeArgs<ExtArgs>
  }


  type OrdersTBLGetPayload<S extends boolean | null | undefined | OrdersTBLArgs> = $Types.GetResult<OrdersTBLPayload, S>

  type OrdersTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OrdersTBLFindManyArgs, 'select' | 'include'> & {
      select?: OrdersTBLCountAggregateInputType | true
    }

  export interface OrdersTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrdersTBL'], meta: { name: 'OrdersTBL' } }
    /**
     * Find zero or one OrdersTBL that matches the filter.
     * @param {OrdersTBLFindUniqueArgs} args - Arguments to find a OrdersTBL
     * @example
     * // Get one OrdersTBL
     * const ordersTBL = await prisma.ordersTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrdersTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrdersTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__OrdersTBLClient<$Types.GetResult<OrdersTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrdersTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrdersTBLFindUniqueOrThrowArgs} args - Arguments to find a OrdersTBL
     * @example
     * // Get one OrdersTBL
     * const ordersTBL = await prisma.ordersTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrdersTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrdersTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrdersTBLClient<$Types.GetResult<OrdersTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrdersTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersTBLFindFirstArgs} args - Arguments to find a OrdersTBL
     * @example
     * // Get one OrdersTBL
     * const ordersTBL = await prisma.ordersTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrdersTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrdersTBLFindFirstArgs<ExtArgs>>
    ): Prisma__OrdersTBLClient<$Types.GetResult<OrdersTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrdersTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersTBLFindFirstOrThrowArgs} args - Arguments to find a OrdersTBL
     * @example
     * // Get one OrdersTBL
     * const ordersTBL = await prisma.ordersTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrdersTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrdersTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrdersTBLClient<$Types.GetResult<OrdersTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrdersTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrdersTBLS
     * const ordersTBLS = await prisma.ordersTBL.findMany()
     * 
     * // Get first 10 OrdersTBLS
     * const ordersTBLS = await prisma.ordersTBL.findMany({ take: 10 })
     * 
     * // Only select the `orderid`
     * const ordersTBLWithOrderidOnly = await prisma.ordersTBL.findMany({ select: { orderid: true } })
     * 
    **/
    findMany<T extends OrdersTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrdersTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OrdersTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrdersTBL.
     * @param {OrdersTBLCreateArgs} args - Arguments to create a OrdersTBL.
     * @example
     * // Create one OrdersTBL
     * const OrdersTBL = await prisma.ordersTBL.create({
     *   data: {
     *     // ... data to create a OrdersTBL
     *   }
     * })
     * 
    **/
    create<T extends OrdersTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrdersTBLCreateArgs<ExtArgs>>
    ): Prisma__OrdersTBLClient<$Types.GetResult<OrdersTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrdersTBLS.
     *     @param {OrdersTBLCreateManyArgs} args - Arguments to create many OrdersTBLS.
     *     @example
     *     // Create many OrdersTBLS
     *     const ordersTBL = await prisma.ordersTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrdersTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrdersTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrdersTBL.
     * @param {OrdersTBLDeleteArgs} args - Arguments to delete one OrdersTBL.
     * @example
     * // Delete one OrdersTBL
     * const OrdersTBL = await prisma.ordersTBL.delete({
     *   where: {
     *     // ... filter to delete one OrdersTBL
     *   }
     * })
     * 
    **/
    delete<T extends OrdersTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrdersTBLDeleteArgs<ExtArgs>>
    ): Prisma__OrdersTBLClient<$Types.GetResult<OrdersTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrdersTBL.
     * @param {OrdersTBLUpdateArgs} args - Arguments to update one OrdersTBL.
     * @example
     * // Update one OrdersTBL
     * const ordersTBL = await prisma.ordersTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrdersTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrdersTBLUpdateArgs<ExtArgs>>
    ): Prisma__OrdersTBLClient<$Types.GetResult<OrdersTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrdersTBLS.
     * @param {OrdersTBLDeleteManyArgs} args - Arguments to filter OrdersTBLS to delete.
     * @example
     * // Delete a few OrdersTBLS
     * const { count } = await prisma.ordersTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrdersTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrdersTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrdersTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrdersTBLS
     * const ordersTBL = await prisma.ordersTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrdersTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrdersTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrdersTBL.
     * @param {OrdersTBLUpsertArgs} args - Arguments to update or create a OrdersTBL.
     * @example
     * // Update or create a OrdersTBL
     * const ordersTBL = await prisma.ordersTBL.upsert({
     *   create: {
     *     // ... data to create a OrdersTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrdersTBL we want to update
     *   }
     * })
    **/
    upsert<T extends OrdersTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrdersTBLUpsertArgs<ExtArgs>>
    ): Prisma__OrdersTBLClient<$Types.GetResult<OrdersTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrdersTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersTBLCountArgs} args - Arguments to filter OrdersTBLS to count.
     * @example
     * // Count the number of OrdersTBLS
     * const count = await prisma.ordersTBL.count({
     *   where: {
     *     // ... the filter for the OrdersTBLS we want to count
     *   }
     * })
    **/
    count<T extends OrdersTBLCountArgs>(
      args?: Subset<T, OrdersTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrdersTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersTBLAggregateArgs>(args: Subset<T, OrdersTBLAggregateArgs>): Prisma.PrismaPromise<GetOrdersTBLAggregateType<T>>

    /**
     * Group by OrdersTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdersTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdersTBLGroupByArgs['orderBy'] }
        : { orderBy?: OrdersTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdersTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrdersTBL model
   */
  readonly fields: OrdersTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrdersTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrdersTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    empref<T extends EmployeeTBLArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeTBLArgs<ExtArgs>>): Prisma__EmployeeTBLClient<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    orderItems<T extends OrdersTBL$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, OrdersTBL$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OrderItemsTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the OrdersTBL model
   */ 
  interface OrdersTBLFieldRefs {
    readonly orderid: FieldRef<"OrdersTBL", 'Int'>
    readonly empid: FieldRef<"OrdersTBL", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * OrdersTBL findUnique
   */
  export type OrdersTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersTBL
     */
    select?: OrdersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersTBLInclude<ExtArgs> | null
    /**
     * Filter, which OrdersTBL to fetch.
     */
    where: OrdersTBLWhereUniqueInput
  }


  /**
   * OrdersTBL findUniqueOrThrow
   */
  export type OrdersTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersTBL
     */
    select?: OrdersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersTBLInclude<ExtArgs> | null
    /**
     * Filter, which OrdersTBL to fetch.
     */
    where: OrdersTBLWhereUniqueInput
  }


  /**
   * OrdersTBL findFirst
   */
  export type OrdersTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersTBL
     */
    select?: OrdersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersTBLInclude<ExtArgs> | null
    /**
     * Filter, which OrdersTBL to fetch.
     */
    where?: OrdersTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdersTBLS to fetch.
     */
    orderBy?: OrdersTBLOrderByWithRelationInput | OrdersTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrdersTBLS.
     */
    cursor?: OrdersTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdersTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdersTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrdersTBLS.
     */
    distinct?: OrdersTBLScalarFieldEnum | OrdersTBLScalarFieldEnum[]
  }


  /**
   * OrdersTBL findFirstOrThrow
   */
  export type OrdersTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersTBL
     */
    select?: OrdersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersTBLInclude<ExtArgs> | null
    /**
     * Filter, which OrdersTBL to fetch.
     */
    where?: OrdersTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdersTBLS to fetch.
     */
    orderBy?: OrdersTBLOrderByWithRelationInput | OrdersTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrdersTBLS.
     */
    cursor?: OrdersTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdersTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdersTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrdersTBLS.
     */
    distinct?: OrdersTBLScalarFieldEnum | OrdersTBLScalarFieldEnum[]
  }


  /**
   * OrdersTBL findMany
   */
  export type OrdersTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersTBL
     */
    select?: OrdersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersTBLInclude<ExtArgs> | null
    /**
     * Filter, which OrdersTBLS to fetch.
     */
    where?: OrdersTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdersTBLS to fetch.
     */
    orderBy?: OrdersTBLOrderByWithRelationInput | OrdersTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrdersTBLS.
     */
    cursor?: OrdersTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdersTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdersTBLS.
     */
    skip?: number
    distinct?: OrdersTBLScalarFieldEnum | OrdersTBLScalarFieldEnum[]
  }


  /**
   * OrdersTBL create
   */
  export type OrdersTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersTBL
     */
    select?: OrdersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a OrdersTBL.
     */
    data: XOR<OrdersTBLCreateInput, OrdersTBLUncheckedCreateInput>
  }


  /**
   * OrdersTBL createMany
   */
  export type OrdersTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrdersTBLS.
     */
    data: OrdersTBLCreateManyInput | OrdersTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OrdersTBL update
   */
  export type OrdersTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersTBL
     */
    select?: OrdersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a OrdersTBL.
     */
    data: XOR<OrdersTBLUpdateInput, OrdersTBLUncheckedUpdateInput>
    /**
     * Choose, which OrdersTBL to update.
     */
    where: OrdersTBLWhereUniqueInput
  }


  /**
   * OrdersTBL updateMany
   */
  export type OrdersTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrdersTBLS.
     */
    data: XOR<OrdersTBLUpdateManyMutationInput, OrdersTBLUncheckedUpdateManyInput>
    /**
     * Filter which OrdersTBLS to update
     */
    where?: OrdersTBLWhereInput
  }


  /**
   * OrdersTBL upsert
   */
  export type OrdersTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersTBL
     */
    select?: OrdersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the OrdersTBL to update in case it exists.
     */
    where: OrdersTBLWhereUniqueInput
    /**
     * In case the OrdersTBL found by the `where` argument doesn't exist, create a new OrdersTBL with this data.
     */
    create: XOR<OrdersTBLCreateInput, OrdersTBLUncheckedCreateInput>
    /**
     * In case the OrdersTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdersTBLUpdateInput, OrdersTBLUncheckedUpdateInput>
  }


  /**
   * OrdersTBL delete
   */
  export type OrdersTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersTBL
     */
    select?: OrdersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersTBLInclude<ExtArgs> | null
    /**
     * Filter which OrdersTBL to delete.
     */
    where: OrdersTBLWhereUniqueInput
  }


  /**
   * OrdersTBL deleteMany
   */
  export type OrdersTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrdersTBLS to delete
     */
    where?: OrdersTBLWhereInput
  }


  /**
   * OrdersTBL.orderItems
   */
  export type OrdersTBL$orderItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemsTBL
     */
    select?: OrderItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemsTBLInclude<ExtArgs> | null
    where?: OrderItemsTBLWhereInput
    orderBy?: OrderItemsTBLOrderByWithRelationInput | OrderItemsTBLOrderByWithRelationInput[]
    cursor?: OrderItemsTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemsTBLScalarFieldEnum | OrderItemsTBLScalarFieldEnum[]
  }


  /**
   * OrdersTBL without action
   */
  export type OrdersTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersTBL
     */
    select?: OrdersTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersTBLInclude<ExtArgs> | null
  }



  /**
   * Model OrderItemsTBL
   */


  export type AggregateOrderItemsTBL = {
    _count: OrderItemsTBLCountAggregateOutputType | null
    _avg: OrderItemsTBLAvgAggregateOutputType | null
    _sum: OrderItemsTBLSumAggregateOutputType | null
    _min: OrderItemsTBLMinAggregateOutputType | null
    _max: OrderItemsTBLMaxAggregateOutputType | null
  }

  export type OrderItemsTBLAvgAggregateOutputType = {
    orderitemid: number | null
    itemquantity: number | null
    orderid: number | null
  }

  export type OrderItemsTBLSumAggregateOutputType = {
    orderitemid: number | null
    itemquantity: number | null
    orderid: number | null
  }

  export type OrderItemsTBLMinAggregateOutputType = {
    orderitemid: number | null
    itemname: string | null
    itemquantity: number | null
    itemsize: string | null
    orderid: number | null
  }

  export type OrderItemsTBLMaxAggregateOutputType = {
    orderitemid: number | null
    itemname: string | null
    itemquantity: number | null
    itemsize: string | null
    orderid: number | null
  }

  export type OrderItemsTBLCountAggregateOutputType = {
    orderitemid: number
    itemname: number
    itemquantity: number
    itemsize: number
    orderid: number
    _all: number
  }


  export type OrderItemsTBLAvgAggregateInputType = {
    orderitemid?: true
    itemquantity?: true
    orderid?: true
  }

  export type OrderItemsTBLSumAggregateInputType = {
    orderitemid?: true
    itemquantity?: true
    orderid?: true
  }

  export type OrderItemsTBLMinAggregateInputType = {
    orderitemid?: true
    itemname?: true
    itemquantity?: true
    itemsize?: true
    orderid?: true
  }

  export type OrderItemsTBLMaxAggregateInputType = {
    orderitemid?: true
    itemname?: true
    itemquantity?: true
    itemsize?: true
    orderid?: true
  }

  export type OrderItemsTBLCountAggregateInputType = {
    orderitemid?: true
    itemname?: true
    itemquantity?: true
    itemsize?: true
    orderid?: true
    _all?: true
  }

  export type OrderItemsTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItemsTBL to aggregate.
     */
    where?: OrderItemsTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemsTBLS to fetch.
     */
    orderBy?: OrderItemsTBLOrderByWithRelationInput | OrderItemsTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemsTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemsTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemsTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItemsTBLS
    **/
    _count?: true | OrderItemsTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemsTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemsTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemsTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemsTBLMaxAggregateInputType
  }

  export type GetOrderItemsTBLAggregateType<T extends OrderItemsTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItemsTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItemsTBL[P]>
      : GetScalarType<T[P], AggregateOrderItemsTBL[P]>
  }




  export type OrderItemsTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderItemsTBLWhereInput
    orderBy?: OrderItemsTBLOrderByWithAggregationInput | OrderItemsTBLOrderByWithAggregationInput[]
    by: OrderItemsTBLScalarFieldEnum[] | OrderItemsTBLScalarFieldEnum
    having?: OrderItemsTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemsTBLCountAggregateInputType | true
    _avg?: OrderItemsTBLAvgAggregateInputType
    _sum?: OrderItemsTBLSumAggregateInputType
    _min?: OrderItemsTBLMinAggregateInputType
    _max?: OrderItemsTBLMaxAggregateInputType
  }


  export type OrderItemsTBLGroupByOutputType = {
    orderitemid: number
    itemname: string
    itemquantity: number
    itemsize: string
    orderid: number
    _count: OrderItemsTBLCountAggregateOutputType | null
    _avg: OrderItemsTBLAvgAggregateOutputType | null
    _sum: OrderItemsTBLSumAggregateOutputType | null
    _min: OrderItemsTBLMinAggregateOutputType | null
    _max: OrderItemsTBLMaxAggregateOutputType | null
  }

  type GetOrderItemsTBLGroupByPayload<T extends OrderItemsTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemsTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemsTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemsTBLGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemsTBLGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemsTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderitemid?: boolean
    itemname?: boolean
    itemquantity?: boolean
    itemsize?: boolean
    orderid?: boolean
    ordersid?: boolean | OrdersTBLArgs<ExtArgs>
  }, ExtArgs["result"]["orderItemsTBL"]>

  export type OrderItemsTBLSelectScalar = {
    orderitemid?: boolean
    itemname?: boolean
    itemquantity?: boolean
    itemsize?: boolean
    orderid?: boolean
  }

  export type OrderItemsTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    ordersid?: boolean | OrdersTBLArgs<ExtArgs>
  }


  type OrderItemsTBLGetPayload<S extends boolean | null | undefined | OrderItemsTBLArgs> = $Types.GetResult<OrderItemsTBLPayload, S>

  type OrderItemsTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OrderItemsTBLFindManyArgs, 'select' | 'include'> & {
      select?: OrderItemsTBLCountAggregateInputType | true
    }

  export interface OrderItemsTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItemsTBL'], meta: { name: 'OrderItemsTBL' } }
    /**
     * Find zero or one OrderItemsTBL that matches the filter.
     * @param {OrderItemsTBLFindUniqueArgs} args - Arguments to find a OrderItemsTBL
     * @example
     * // Get one OrderItemsTBL
     * const orderItemsTBL = await prisma.orderItemsTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderItemsTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderItemsTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderItemsTBLClient<$Types.GetResult<OrderItemsTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderItemsTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderItemsTBLFindUniqueOrThrowArgs} args - Arguments to find a OrderItemsTBL
     * @example
     * // Get one OrderItemsTBL
     * const orderItemsTBL = await prisma.orderItemsTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderItemsTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderItemsTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderItemsTBLClient<$Types.GetResult<OrderItemsTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderItemsTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsTBLFindFirstArgs} args - Arguments to find a OrderItemsTBL
     * @example
     * // Get one OrderItemsTBL
     * const orderItemsTBL = await prisma.orderItemsTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderItemsTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderItemsTBLFindFirstArgs<ExtArgs>>
    ): Prisma__OrderItemsTBLClient<$Types.GetResult<OrderItemsTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderItemsTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsTBLFindFirstOrThrowArgs} args - Arguments to find a OrderItemsTBL
     * @example
     * // Get one OrderItemsTBL
     * const orderItemsTBL = await prisma.orderItemsTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderItemsTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderItemsTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderItemsTBLClient<$Types.GetResult<OrderItemsTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderItemsTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItemsTBLS
     * const orderItemsTBLS = await prisma.orderItemsTBL.findMany()
     * 
     * // Get first 10 OrderItemsTBLS
     * const orderItemsTBLS = await prisma.orderItemsTBL.findMany({ take: 10 })
     * 
     * // Only select the `orderitemid`
     * const orderItemsTBLWithOrderitemidOnly = await prisma.orderItemsTBL.findMany({ select: { orderitemid: true } })
     * 
    **/
    findMany<T extends OrderItemsTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderItemsTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OrderItemsTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderItemsTBL.
     * @param {OrderItemsTBLCreateArgs} args - Arguments to create a OrderItemsTBL.
     * @example
     * // Create one OrderItemsTBL
     * const OrderItemsTBL = await prisma.orderItemsTBL.create({
     *   data: {
     *     // ... data to create a OrderItemsTBL
     *   }
     * })
     * 
    **/
    create<T extends OrderItemsTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderItemsTBLCreateArgs<ExtArgs>>
    ): Prisma__OrderItemsTBLClient<$Types.GetResult<OrderItemsTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderItemsTBLS.
     *     @param {OrderItemsTBLCreateManyArgs} args - Arguments to create many OrderItemsTBLS.
     *     @example
     *     // Create many OrderItemsTBLS
     *     const orderItemsTBL = await prisma.orderItemsTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderItemsTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderItemsTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItemsTBL.
     * @param {OrderItemsTBLDeleteArgs} args - Arguments to delete one OrderItemsTBL.
     * @example
     * // Delete one OrderItemsTBL
     * const OrderItemsTBL = await prisma.orderItemsTBL.delete({
     *   where: {
     *     // ... filter to delete one OrderItemsTBL
     *   }
     * })
     * 
    **/
    delete<T extends OrderItemsTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderItemsTBLDeleteArgs<ExtArgs>>
    ): Prisma__OrderItemsTBLClient<$Types.GetResult<OrderItemsTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderItemsTBL.
     * @param {OrderItemsTBLUpdateArgs} args - Arguments to update one OrderItemsTBL.
     * @example
     * // Update one OrderItemsTBL
     * const orderItemsTBL = await prisma.orderItemsTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderItemsTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderItemsTBLUpdateArgs<ExtArgs>>
    ): Prisma__OrderItemsTBLClient<$Types.GetResult<OrderItemsTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderItemsTBLS.
     * @param {OrderItemsTBLDeleteManyArgs} args - Arguments to filter OrderItemsTBLS to delete.
     * @example
     * // Delete a few OrderItemsTBLS
     * const { count } = await prisma.orderItemsTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderItemsTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderItemsTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItemsTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItemsTBLS
     * const orderItemsTBL = await prisma.orderItemsTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderItemsTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderItemsTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItemsTBL.
     * @param {OrderItemsTBLUpsertArgs} args - Arguments to update or create a OrderItemsTBL.
     * @example
     * // Update or create a OrderItemsTBL
     * const orderItemsTBL = await prisma.orderItemsTBL.upsert({
     *   create: {
     *     // ... data to create a OrderItemsTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItemsTBL we want to update
     *   }
     * })
    **/
    upsert<T extends OrderItemsTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderItemsTBLUpsertArgs<ExtArgs>>
    ): Prisma__OrderItemsTBLClient<$Types.GetResult<OrderItemsTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderItemsTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsTBLCountArgs} args - Arguments to filter OrderItemsTBLS to count.
     * @example
     * // Count the number of OrderItemsTBLS
     * const count = await prisma.orderItemsTBL.count({
     *   where: {
     *     // ... the filter for the OrderItemsTBLS we want to count
     *   }
     * })
    **/
    count<T extends OrderItemsTBLCountArgs>(
      args?: Subset<T, OrderItemsTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemsTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItemsTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemsTBLAggregateArgs>(args: Subset<T, OrderItemsTBLAggregateArgs>): Prisma.PrismaPromise<GetOrderItemsTBLAggregateType<T>>

    /**
     * Group by OrderItemsTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemsTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemsTBLGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemsTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemsTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemsTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItemsTBL model
   */
  readonly fields: OrderItemsTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItemsTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderItemsTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ordersid<T extends OrdersTBLArgs<ExtArgs> = {}>(args?: Subset<T, OrdersTBLArgs<ExtArgs>>): Prisma__OrdersTBLClient<$Types.GetResult<OrdersTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the OrderItemsTBL model
   */ 
  interface OrderItemsTBLFieldRefs {
    readonly orderitemid: FieldRef<"OrderItemsTBL", 'Int'>
    readonly itemname: FieldRef<"OrderItemsTBL", 'String'>
    readonly itemquantity: FieldRef<"OrderItemsTBL", 'Int'>
    readonly itemsize: FieldRef<"OrderItemsTBL", 'String'>
    readonly orderid: FieldRef<"OrderItemsTBL", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * OrderItemsTBL findUnique
   */
  export type OrderItemsTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemsTBL
     */
    select?: OrderItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemsTBL to fetch.
     */
    where: OrderItemsTBLWhereUniqueInput
  }


  /**
   * OrderItemsTBL findUniqueOrThrow
   */
  export type OrderItemsTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemsTBL
     */
    select?: OrderItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemsTBL to fetch.
     */
    where: OrderItemsTBLWhereUniqueInput
  }


  /**
   * OrderItemsTBL findFirst
   */
  export type OrderItemsTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemsTBL
     */
    select?: OrderItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemsTBL to fetch.
     */
    where?: OrderItemsTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemsTBLS to fetch.
     */
    orderBy?: OrderItemsTBLOrderByWithRelationInput | OrderItemsTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItemsTBLS.
     */
    cursor?: OrderItemsTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemsTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemsTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItemsTBLS.
     */
    distinct?: OrderItemsTBLScalarFieldEnum | OrderItemsTBLScalarFieldEnum[]
  }


  /**
   * OrderItemsTBL findFirstOrThrow
   */
  export type OrderItemsTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemsTBL
     */
    select?: OrderItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemsTBL to fetch.
     */
    where?: OrderItemsTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemsTBLS to fetch.
     */
    orderBy?: OrderItemsTBLOrderByWithRelationInput | OrderItemsTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItemsTBLS.
     */
    cursor?: OrderItemsTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemsTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemsTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItemsTBLS.
     */
    distinct?: OrderItemsTBLScalarFieldEnum | OrderItemsTBLScalarFieldEnum[]
  }


  /**
   * OrderItemsTBL findMany
   */
  export type OrderItemsTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemsTBL
     */
    select?: OrderItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemsTBLS to fetch.
     */
    where?: OrderItemsTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemsTBLS to fetch.
     */
    orderBy?: OrderItemsTBLOrderByWithRelationInput | OrderItemsTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItemsTBLS.
     */
    cursor?: OrderItemsTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemsTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemsTBLS.
     */
    skip?: number
    distinct?: OrderItemsTBLScalarFieldEnum | OrderItemsTBLScalarFieldEnum[]
  }


  /**
   * OrderItemsTBL create
   */
  export type OrderItemsTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemsTBL
     */
    select?: OrderItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemsTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItemsTBL.
     */
    data: XOR<OrderItemsTBLCreateInput, OrderItemsTBLUncheckedCreateInput>
  }


  /**
   * OrderItemsTBL createMany
   */
  export type OrderItemsTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItemsTBLS.
     */
    data: OrderItemsTBLCreateManyInput | OrderItemsTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OrderItemsTBL update
   */
  export type OrderItemsTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemsTBL
     */
    select?: OrderItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemsTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItemsTBL.
     */
    data: XOR<OrderItemsTBLUpdateInput, OrderItemsTBLUncheckedUpdateInput>
    /**
     * Choose, which OrderItemsTBL to update.
     */
    where: OrderItemsTBLWhereUniqueInput
  }


  /**
   * OrderItemsTBL updateMany
   */
  export type OrderItemsTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItemsTBLS.
     */
    data: XOR<OrderItemsTBLUpdateManyMutationInput, OrderItemsTBLUncheckedUpdateManyInput>
    /**
     * Filter which OrderItemsTBLS to update
     */
    where?: OrderItemsTBLWhereInput
  }


  /**
   * OrderItemsTBL upsert
   */
  export type OrderItemsTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemsTBL
     */
    select?: OrderItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemsTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItemsTBL to update in case it exists.
     */
    where: OrderItemsTBLWhereUniqueInput
    /**
     * In case the OrderItemsTBL found by the `where` argument doesn't exist, create a new OrderItemsTBL with this data.
     */
    create: XOR<OrderItemsTBLCreateInput, OrderItemsTBLUncheckedCreateInput>
    /**
     * In case the OrderItemsTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemsTBLUpdateInput, OrderItemsTBLUncheckedUpdateInput>
  }


  /**
   * OrderItemsTBL delete
   */
  export type OrderItemsTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemsTBL
     */
    select?: OrderItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemsTBLInclude<ExtArgs> | null
    /**
     * Filter which OrderItemsTBL to delete.
     */
    where: OrderItemsTBLWhereUniqueInput
  }


  /**
   * OrderItemsTBL deleteMany
   */
  export type OrderItemsTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItemsTBLS to delete
     */
    where?: OrderItemsTBLWhereInput
  }


  /**
   * OrderItemsTBL without action
   */
  export type OrderItemsTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemsTBL
     */
    select?: OrderItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemsTBLInclude<ExtArgs> | null
  }



  /**
   * Model CartTBL
   */


  export type AggregateCartTBL = {
    _count: CartTBLCountAggregateOutputType | null
    _avg: CartTBLAvgAggregateOutputType | null
    _sum: CartTBLSumAggregateOutputType | null
    _min: CartTBLMinAggregateOutputType | null
    _max: CartTBLMaxAggregateOutputType | null
  }

  export type CartTBLAvgAggregateOutputType = {
    cartid: number | null
    empid: number | null
  }

  export type CartTBLSumAggregateOutputType = {
    cartid: number | null
    empid: number | null
  }

  export type CartTBLMinAggregateOutputType = {
    cartid: number | null
    empid: number | null
  }

  export type CartTBLMaxAggregateOutputType = {
    cartid: number | null
    empid: number | null
  }

  export type CartTBLCountAggregateOutputType = {
    cartid: number
    empid: number
    _all: number
  }


  export type CartTBLAvgAggregateInputType = {
    cartid?: true
    empid?: true
  }

  export type CartTBLSumAggregateInputType = {
    cartid?: true
    empid?: true
  }

  export type CartTBLMinAggregateInputType = {
    cartid?: true
    empid?: true
  }

  export type CartTBLMaxAggregateInputType = {
    cartid?: true
    empid?: true
  }

  export type CartTBLCountAggregateInputType = {
    cartid?: true
    empid?: true
    _all?: true
  }

  export type CartTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartTBL to aggregate.
     */
    where?: CartTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartTBLS to fetch.
     */
    orderBy?: CartTBLOrderByWithRelationInput | CartTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartTBLS
    **/
    _count?: true | CartTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartTBLMaxAggregateInputType
  }

  export type GetCartTBLAggregateType<T extends CartTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateCartTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartTBL[P]>
      : GetScalarType<T[P], AggregateCartTBL[P]>
  }




  export type CartTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CartTBLWhereInput
    orderBy?: CartTBLOrderByWithAggregationInput | CartTBLOrderByWithAggregationInput[]
    by: CartTBLScalarFieldEnum[] | CartTBLScalarFieldEnum
    having?: CartTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartTBLCountAggregateInputType | true
    _avg?: CartTBLAvgAggregateInputType
    _sum?: CartTBLSumAggregateInputType
    _min?: CartTBLMinAggregateInputType
    _max?: CartTBLMaxAggregateInputType
  }


  export type CartTBLGroupByOutputType = {
    cartid: number
    empid: number
    _count: CartTBLCountAggregateOutputType | null
    _avg: CartTBLAvgAggregateOutputType | null
    _sum: CartTBLSumAggregateOutputType | null
    _min: CartTBLMinAggregateOutputType | null
    _max: CartTBLMaxAggregateOutputType | null
  }

  type GetCartTBLGroupByPayload<T extends CartTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartTBLGroupByOutputType[P]>
            : GetScalarType<T[P], CartTBLGroupByOutputType[P]>
        }
      >
    >


  export type CartTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cartid?: boolean
    empid?: boolean
    employeeid?: boolean | EmployeeTBLArgs<ExtArgs>
    CartItems?: boolean | CartTBL$CartItemsArgs<ExtArgs>
    _count?: boolean | CartTBLCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["cartTBL"]>

  export type CartTBLSelectScalar = {
    cartid?: boolean
    empid?: boolean
  }

  export type CartTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    employeeid?: boolean | EmployeeTBLArgs<ExtArgs>
    CartItems?: boolean | CartTBL$CartItemsArgs<ExtArgs>
    _count?: boolean | CartTBLCountOutputTypeArgs<ExtArgs>
  }


  type CartTBLGetPayload<S extends boolean | null | undefined | CartTBLArgs> = $Types.GetResult<CartTBLPayload, S>

  type CartTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CartTBLFindManyArgs, 'select' | 'include'> & {
      select?: CartTBLCountAggregateInputType | true
    }

  export interface CartTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartTBL'], meta: { name: 'CartTBL' } }
    /**
     * Find zero or one CartTBL that matches the filter.
     * @param {CartTBLFindUniqueArgs} args - Arguments to find a CartTBL
     * @example
     * // Get one CartTBL
     * const cartTBL = await prisma.cartTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CartTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CartTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__CartTBLClient<$Types.GetResult<CartTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CartTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CartTBLFindUniqueOrThrowArgs} args - Arguments to find a CartTBL
     * @example
     * // Get one CartTBL
     * const cartTBL = await prisma.cartTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CartTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CartTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CartTBLClient<$Types.GetResult<CartTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CartTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartTBLFindFirstArgs} args - Arguments to find a CartTBL
     * @example
     * // Get one CartTBL
     * const cartTBL = await prisma.cartTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CartTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CartTBLFindFirstArgs<ExtArgs>>
    ): Prisma__CartTBLClient<$Types.GetResult<CartTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CartTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartTBLFindFirstOrThrowArgs} args - Arguments to find a CartTBL
     * @example
     * // Get one CartTBL
     * const cartTBL = await prisma.cartTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CartTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CartTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CartTBLClient<$Types.GetResult<CartTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CartTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartTBLS
     * const cartTBLS = await prisma.cartTBL.findMany()
     * 
     * // Get first 10 CartTBLS
     * const cartTBLS = await prisma.cartTBL.findMany({ take: 10 })
     * 
     * // Only select the `cartid`
     * const cartTBLWithCartidOnly = await prisma.cartTBL.findMany({ select: { cartid: true } })
     * 
    **/
    findMany<T extends CartTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CartTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CartTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CartTBL.
     * @param {CartTBLCreateArgs} args - Arguments to create a CartTBL.
     * @example
     * // Create one CartTBL
     * const CartTBL = await prisma.cartTBL.create({
     *   data: {
     *     // ... data to create a CartTBL
     *   }
     * })
     * 
    **/
    create<T extends CartTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CartTBLCreateArgs<ExtArgs>>
    ): Prisma__CartTBLClient<$Types.GetResult<CartTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CartTBLS.
     *     @param {CartTBLCreateManyArgs} args - Arguments to create many CartTBLS.
     *     @example
     *     // Create many CartTBLS
     *     const cartTBL = await prisma.cartTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CartTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CartTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CartTBL.
     * @param {CartTBLDeleteArgs} args - Arguments to delete one CartTBL.
     * @example
     * // Delete one CartTBL
     * const CartTBL = await prisma.cartTBL.delete({
     *   where: {
     *     // ... filter to delete one CartTBL
     *   }
     * })
     * 
    **/
    delete<T extends CartTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CartTBLDeleteArgs<ExtArgs>>
    ): Prisma__CartTBLClient<$Types.GetResult<CartTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CartTBL.
     * @param {CartTBLUpdateArgs} args - Arguments to update one CartTBL.
     * @example
     * // Update one CartTBL
     * const cartTBL = await prisma.cartTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CartTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CartTBLUpdateArgs<ExtArgs>>
    ): Prisma__CartTBLClient<$Types.GetResult<CartTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CartTBLS.
     * @param {CartTBLDeleteManyArgs} args - Arguments to filter CartTBLS to delete.
     * @example
     * // Delete a few CartTBLS
     * const { count } = await prisma.cartTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CartTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CartTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartTBLS
     * const cartTBL = await prisma.cartTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CartTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CartTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CartTBL.
     * @param {CartTBLUpsertArgs} args - Arguments to update or create a CartTBL.
     * @example
     * // Update or create a CartTBL
     * const cartTBL = await prisma.cartTBL.upsert({
     *   create: {
     *     // ... data to create a CartTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartTBL we want to update
     *   }
     * })
    **/
    upsert<T extends CartTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CartTBLUpsertArgs<ExtArgs>>
    ): Prisma__CartTBLClient<$Types.GetResult<CartTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CartTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartTBLCountArgs} args - Arguments to filter CartTBLS to count.
     * @example
     * // Count the number of CartTBLS
     * const count = await prisma.cartTBL.count({
     *   where: {
     *     // ... the filter for the CartTBLS we want to count
     *   }
     * })
    **/
    count<T extends CartTBLCountArgs>(
      args?: Subset<T, CartTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartTBLAggregateArgs>(args: Subset<T, CartTBLAggregateArgs>): Prisma.PrismaPromise<GetCartTBLAggregateType<T>>

    /**
     * Group by CartTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartTBLGroupByArgs['orderBy'] }
        : { orderBy?: CartTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartTBL model
   */
  readonly fields: CartTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CartTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    employeeid<T extends EmployeeTBLArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeTBLArgs<ExtArgs>>): Prisma__EmployeeTBLClient<$Types.GetResult<EmployeeTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    CartItems<T extends CartTBL$CartItemsArgs<ExtArgs> = {}>(args?: Subset<T, CartTBL$CartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CartItemsTBLPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the CartTBL model
   */ 
  interface CartTBLFieldRefs {
    readonly cartid: FieldRef<"CartTBL", 'Int'>
    readonly empid: FieldRef<"CartTBL", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CartTBL findUnique
   */
  export type CartTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartTBL
     */
    select?: CartTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartTBLInclude<ExtArgs> | null
    /**
     * Filter, which CartTBL to fetch.
     */
    where: CartTBLWhereUniqueInput
  }


  /**
   * CartTBL findUniqueOrThrow
   */
  export type CartTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartTBL
     */
    select?: CartTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartTBLInclude<ExtArgs> | null
    /**
     * Filter, which CartTBL to fetch.
     */
    where: CartTBLWhereUniqueInput
  }


  /**
   * CartTBL findFirst
   */
  export type CartTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartTBL
     */
    select?: CartTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartTBLInclude<ExtArgs> | null
    /**
     * Filter, which CartTBL to fetch.
     */
    where?: CartTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartTBLS to fetch.
     */
    orderBy?: CartTBLOrderByWithRelationInput | CartTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartTBLS.
     */
    cursor?: CartTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartTBLS.
     */
    distinct?: CartTBLScalarFieldEnum | CartTBLScalarFieldEnum[]
  }


  /**
   * CartTBL findFirstOrThrow
   */
  export type CartTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartTBL
     */
    select?: CartTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartTBLInclude<ExtArgs> | null
    /**
     * Filter, which CartTBL to fetch.
     */
    where?: CartTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartTBLS to fetch.
     */
    orderBy?: CartTBLOrderByWithRelationInput | CartTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartTBLS.
     */
    cursor?: CartTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartTBLS.
     */
    distinct?: CartTBLScalarFieldEnum | CartTBLScalarFieldEnum[]
  }


  /**
   * CartTBL findMany
   */
  export type CartTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartTBL
     */
    select?: CartTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartTBLInclude<ExtArgs> | null
    /**
     * Filter, which CartTBLS to fetch.
     */
    where?: CartTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartTBLS to fetch.
     */
    orderBy?: CartTBLOrderByWithRelationInput | CartTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartTBLS.
     */
    cursor?: CartTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartTBLS.
     */
    skip?: number
    distinct?: CartTBLScalarFieldEnum | CartTBLScalarFieldEnum[]
  }


  /**
   * CartTBL create
   */
  export type CartTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartTBL
     */
    select?: CartTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a CartTBL.
     */
    data: XOR<CartTBLCreateInput, CartTBLUncheckedCreateInput>
  }


  /**
   * CartTBL createMany
   */
  export type CartTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartTBLS.
     */
    data: CartTBLCreateManyInput | CartTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CartTBL update
   */
  export type CartTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartTBL
     */
    select?: CartTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a CartTBL.
     */
    data: XOR<CartTBLUpdateInput, CartTBLUncheckedUpdateInput>
    /**
     * Choose, which CartTBL to update.
     */
    where: CartTBLWhereUniqueInput
  }


  /**
   * CartTBL updateMany
   */
  export type CartTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartTBLS.
     */
    data: XOR<CartTBLUpdateManyMutationInput, CartTBLUncheckedUpdateManyInput>
    /**
     * Filter which CartTBLS to update
     */
    where?: CartTBLWhereInput
  }


  /**
   * CartTBL upsert
   */
  export type CartTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartTBL
     */
    select?: CartTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the CartTBL to update in case it exists.
     */
    where: CartTBLWhereUniqueInput
    /**
     * In case the CartTBL found by the `where` argument doesn't exist, create a new CartTBL with this data.
     */
    create: XOR<CartTBLCreateInput, CartTBLUncheckedCreateInput>
    /**
     * In case the CartTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartTBLUpdateInput, CartTBLUncheckedUpdateInput>
  }


  /**
   * CartTBL delete
   */
  export type CartTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartTBL
     */
    select?: CartTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartTBLInclude<ExtArgs> | null
    /**
     * Filter which CartTBL to delete.
     */
    where: CartTBLWhereUniqueInput
  }


  /**
   * CartTBL deleteMany
   */
  export type CartTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartTBLS to delete
     */
    where?: CartTBLWhereInput
  }


  /**
   * CartTBL.CartItems
   */
  export type CartTBL$CartItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemsTBL
     */
    select?: CartItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartItemsTBLInclude<ExtArgs> | null
    where?: CartItemsTBLWhereInput
    orderBy?: CartItemsTBLOrderByWithRelationInput | CartItemsTBLOrderByWithRelationInput[]
    cursor?: CartItemsTBLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemsTBLScalarFieldEnum | CartItemsTBLScalarFieldEnum[]
  }


  /**
   * CartTBL without action
   */
  export type CartTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartTBL
     */
    select?: CartTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartTBLInclude<ExtArgs> | null
  }



  /**
   * Model CartItemsTBL
   */


  export type AggregateCartItemsTBL = {
    _count: CartItemsTBLCountAggregateOutputType | null
    _avg: CartItemsTBLAvgAggregateOutputType | null
    _sum: CartItemsTBLSumAggregateOutputType | null
    _min: CartItemsTBLMinAggregateOutputType | null
    _max: CartItemsTBLMaxAggregateOutputType | null
  }

  export type CartItemsTBLAvgAggregateOutputType = {
    cartitemid: number | null
    quanity: number | null
    cartid: number | null
    itemid: number | null
  }

  export type CartItemsTBLSumAggregateOutputType = {
    cartitemid: number | null
    quanity: number | null
    cartid: number | null
    itemid: number | null
  }

  export type CartItemsTBLMinAggregateOutputType = {
    cartitemid: number | null
    quanity: number | null
    cartid: number | null
    itemsize: string | null
    notes: string | null
    itemid: number | null
  }

  export type CartItemsTBLMaxAggregateOutputType = {
    cartitemid: number | null
    quanity: number | null
    cartid: number | null
    itemsize: string | null
    notes: string | null
    itemid: number | null
  }

  export type CartItemsTBLCountAggregateOutputType = {
    cartitemid: number
    quanity: number
    cartid: number
    itemsize: number
    notes: number
    itemid: number
    _all: number
  }


  export type CartItemsTBLAvgAggregateInputType = {
    cartitemid?: true
    quanity?: true
    cartid?: true
    itemid?: true
  }

  export type CartItemsTBLSumAggregateInputType = {
    cartitemid?: true
    quanity?: true
    cartid?: true
    itemid?: true
  }

  export type CartItemsTBLMinAggregateInputType = {
    cartitemid?: true
    quanity?: true
    cartid?: true
    itemsize?: true
    notes?: true
    itemid?: true
  }

  export type CartItemsTBLMaxAggregateInputType = {
    cartitemid?: true
    quanity?: true
    cartid?: true
    itemsize?: true
    notes?: true
    itemid?: true
  }

  export type CartItemsTBLCountAggregateInputType = {
    cartitemid?: true
    quanity?: true
    cartid?: true
    itemsize?: true
    notes?: true
    itemid?: true
    _all?: true
  }

  export type CartItemsTBLAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItemsTBL to aggregate.
     */
    where?: CartItemsTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItemsTBLS to fetch.
     */
    orderBy?: CartItemsTBLOrderByWithRelationInput | CartItemsTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemsTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItemsTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItemsTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItemsTBLS
    **/
    _count?: true | CartItemsTBLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemsTBLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemsTBLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemsTBLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemsTBLMaxAggregateInputType
  }

  export type GetCartItemsTBLAggregateType<T extends CartItemsTBLAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItemsTBL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItemsTBL[P]>
      : GetScalarType<T[P], AggregateCartItemsTBL[P]>
  }




  export type CartItemsTBLGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CartItemsTBLWhereInput
    orderBy?: CartItemsTBLOrderByWithAggregationInput | CartItemsTBLOrderByWithAggregationInput[]
    by: CartItemsTBLScalarFieldEnum[] | CartItemsTBLScalarFieldEnum
    having?: CartItemsTBLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemsTBLCountAggregateInputType | true
    _avg?: CartItemsTBLAvgAggregateInputType
    _sum?: CartItemsTBLSumAggregateInputType
    _min?: CartItemsTBLMinAggregateInputType
    _max?: CartItemsTBLMaxAggregateInputType
  }


  export type CartItemsTBLGroupByOutputType = {
    cartitemid: number
    quanity: number
    cartid: number
    itemsize: string
    notes: string | null
    itemid: number
    _count: CartItemsTBLCountAggregateOutputType | null
    _avg: CartItemsTBLAvgAggregateOutputType | null
    _sum: CartItemsTBLSumAggregateOutputType | null
    _min: CartItemsTBLMinAggregateOutputType | null
    _max: CartItemsTBLMaxAggregateOutputType | null
  }

  type GetCartItemsTBLGroupByPayload<T extends CartItemsTBLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemsTBLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemsTBLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemsTBLGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemsTBLGroupByOutputType[P]>
        }
      >
    >


  export type CartItemsTBLSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cartitemid?: boolean
    quanity?: boolean
    cartid?: boolean
    itemsize?: boolean
    notes?: boolean
    itemid?: boolean
    carttid?: boolean | CartItemsTBL$carttidArgs<ExtArgs>
    itemids?: boolean | ItemsTBLArgs<ExtArgs>
  }, ExtArgs["result"]["cartItemsTBL"]>

  export type CartItemsTBLSelectScalar = {
    cartitemid?: boolean
    quanity?: boolean
    cartid?: boolean
    itemsize?: boolean
    notes?: boolean
    itemid?: boolean
  }

  export type CartItemsTBLInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    carttid?: boolean | CartItemsTBL$carttidArgs<ExtArgs>
    itemids?: boolean | ItemsTBLArgs<ExtArgs>
  }


  type CartItemsTBLGetPayload<S extends boolean | null | undefined | CartItemsTBLArgs> = $Types.GetResult<CartItemsTBLPayload, S>

  type CartItemsTBLCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CartItemsTBLFindManyArgs, 'select' | 'include'> & {
      select?: CartItemsTBLCountAggregateInputType | true
    }

  export interface CartItemsTBLDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItemsTBL'], meta: { name: 'CartItemsTBL' } }
    /**
     * Find zero or one CartItemsTBL that matches the filter.
     * @param {CartItemsTBLFindUniqueArgs} args - Arguments to find a CartItemsTBL
     * @example
     * // Get one CartItemsTBL
     * const cartItemsTBL = await prisma.cartItemsTBL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CartItemsTBLFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CartItemsTBLFindUniqueArgs<ExtArgs>>
    ): Prisma__CartItemsTBLClient<$Types.GetResult<CartItemsTBLPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CartItemsTBL that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CartItemsTBLFindUniqueOrThrowArgs} args - Arguments to find a CartItemsTBL
     * @example
     * // Get one CartItemsTBL
     * const cartItemsTBL = await prisma.cartItemsTBL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CartItemsTBLFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CartItemsTBLFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CartItemsTBLClient<$Types.GetResult<CartItemsTBLPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CartItemsTBL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsTBLFindFirstArgs} args - Arguments to find a CartItemsTBL
     * @example
     * // Get one CartItemsTBL
     * const cartItemsTBL = await prisma.cartItemsTBL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CartItemsTBLFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CartItemsTBLFindFirstArgs<ExtArgs>>
    ): Prisma__CartItemsTBLClient<$Types.GetResult<CartItemsTBLPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CartItemsTBL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsTBLFindFirstOrThrowArgs} args - Arguments to find a CartItemsTBL
     * @example
     * // Get one CartItemsTBL
     * const cartItemsTBL = await prisma.cartItemsTBL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CartItemsTBLFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CartItemsTBLFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CartItemsTBLClient<$Types.GetResult<CartItemsTBLPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CartItemsTBLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsTBLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItemsTBLS
     * const cartItemsTBLS = await prisma.cartItemsTBL.findMany()
     * 
     * // Get first 10 CartItemsTBLS
     * const cartItemsTBLS = await prisma.cartItemsTBL.findMany({ take: 10 })
     * 
     * // Only select the `cartitemid`
     * const cartItemsTBLWithCartitemidOnly = await prisma.cartItemsTBL.findMany({ select: { cartitemid: true } })
     * 
    **/
    findMany<T extends CartItemsTBLFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CartItemsTBLFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CartItemsTBLPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CartItemsTBL.
     * @param {CartItemsTBLCreateArgs} args - Arguments to create a CartItemsTBL.
     * @example
     * // Create one CartItemsTBL
     * const CartItemsTBL = await prisma.cartItemsTBL.create({
     *   data: {
     *     // ... data to create a CartItemsTBL
     *   }
     * })
     * 
    **/
    create<T extends CartItemsTBLCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CartItemsTBLCreateArgs<ExtArgs>>
    ): Prisma__CartItemsTBLClient<$Types.GetResult<CartItemsTBLPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CartItemsTBLS.
     *     @param {CartItemsTBLCreateManyArgs} args - Arguments to create many CartItemsTBLS.
     *     @example
     *     // Create many CartItemsTBLS
     *     const cartItemsTBL = await prisma.cartItemsTBL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CartItemsTBLCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CartItemsTBLCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CartItemsTBL.
     * @param {CartItemsTBLDeleteArgs} args - Arguments to delete one CartItemsTBL.
     * @example
     * // Delete one CartItemsTBL
     * const CartItemsTBL = await prisma.cartItemsTBL.delete({
     *   where: {
     *     // ... filter to delete one CartItemsTBL
     *   }
     * })
     * 
    **/
    delete<T extends CartItemsTBLDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CartItemsTBLDeleteArgs<ExtArgs>>
    ): Prisma__CartItemsTBLClient<$Types.GetResult<CartItemsTBLPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CartItemsTBL.
     * @param {CartItemsTBLUpdateArgs} args - Arguments to update one CartItemsTBL.
     * @example
     * // Update one CartItemsTBL
     * const cartItemsTBL = await prisma.cartItemsTBL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CartItemsTBLUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CartItemsTBLUpdateArgs<ExtArgs>>
    ): Prisma__CartItemsTBLClient<$Types.GetResult<CartItemsTBLPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CartItemsTBLS.
     * @param {CartItemsTBLDeleteManyArgs} args - Arguments to filter CartItemsTBLS to delete.
     * @example
     * // Delete a few CartItemsTBLS
     * const { count } = await prisma.cartItemsTBL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CartItemsTBLDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CartItemsTBLDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItemsTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsTBLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItemsTBLS
     * const cartItemsTBL = await prisma.cartItemsTBL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CartItemsTBLUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CartItemsTBLUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CartItemsTBL.
     * @param {CartItemsTBLUpsertArgs} args - Arguments to update or create a CartItemsTBL.
     * @example
     * // Update or create a CartItemsTBL
     * const cartItemsTBL = await prisma.cartItemsTBL.upsert({
     *   create: {
     *     // ... data to create a CartItemsTBL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItemsTBL we want to update
     *   }
     * })
    **/
    upsert<T extends CartItemsTBLUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CartItemsTBLUpsertArgs<ExtArgs>>
    ): Prisma__CartItemsTBLClient<$Types.GetResult<CartItemsTBLPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CartItemsTBLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsTBLCountArgs} args - Arguments to filter CartItemsTBLS to count.
     * @example
     * // Count the number of CartItemsTBLS
     * const count = await prisma.cartItemsTBL.count({
     *   where: {
     *     // ... the filter for the CartItemsTBLS we want to count
     *   }
     * })
    **/
    count<T extends CartItemsTBLCountArgs>(
      args?: Subset<T, CartItemsTBLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemsTBLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItemsTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsTBLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemsTBLAggregateArgs>(args: Subset<T, CartItemsTBLAggregateArgs>): Prisma.PrismaPromise<GetCartItemsTBLAggregateType<T>>

    /**
     * Group by CartItemsTBL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsTBLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemsTBLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemsTBLGroupByArgs['orderBy'] }
        : { orderBy?: CartItemsTBLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemsTBLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemsTBLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItemsTBL model
   */
  readonly fields: CartItemsTBLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItemsTBL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CartItemsTBLClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    carttid<T extends CartItemsTBL$carttidArgs<ExtArgs> = {}>(args?: Subset<T, CartItemsTBL$carttidArgs<ExtArgs>>): Prisma__CartTBLClient<$Types.GetResult<CartTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    itemids<T extends ItemsTBLArgs<ExtArgs> = {}>(args?: Subset<T, ItemsTBLArgs<ExtArgs>>): Prisma__ItemsTBLClient<$Types.GetResult<ItemsTBLPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the CartItemsTBL model
   */ 
  interface CartItemsTBLFieldRefs {
    readonly cartitemid: FieldRef<"CartItemsTBL", 'Int'>
    readonly quanity: FieldRef<"CartItemsTBL", 'Int'>
    readonly cartid: FieldRef<"CartItemsTBL", 'Int'>
    readonly itemsize: FieldRef<"CartItemsTBL", 'String'>
    readonly notes: FieldRef<"CartItemsTBL", 'String'>
    readonly itemid: FieldRef<"CartItemsTBL", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CartItemsTBL findUnique
   */
  export type CartItemsTBLFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemsTBL
     */
    select?: CartItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which CartItemsTBL to fetch.
     */
    where: CartItemsTBLWhereUniqueInput
  }


  /**
   * CartItemsTBL findUniqueOrThrow
   */
  export type CartItemsTBLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemsTBL
     */
    select?: CartItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which CartItemsTBL to fetch.
     */
    where: CartItemsTBLWhereUniqueInput
  }


  /**
   * CartItemsTBL findFirst
   */
  export type CartItemsTBLFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemsTBL
     */
    select?: CartItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which CartItemsTBL to fetch.
     */
    where?: CartItemsTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItemsTBLS to fetch.
     */
    orderBy?: CartItemsTBLOrderByWithRelationInput | CartItemsTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItemsTBLS.
     */
    cursor?: CartItemsTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItemsTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItemsTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItemsTBLS.
     */
    distinct?: CartItemsTBLScalarFieldEnum | CartItemsTBLScalarFieldEnum[]
  }


  /**
   * CartItemsTBL findFirstOrThrow
   */
  export type CartItemsTBLFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemsTBL
     */
    select?: CartItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which CartItemsTBL to fetch.
     */
    where?: CartItemsTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItemsTBLS to fetch.
     */
    orderBy?: CartItemsTBLOrderByWithRelationInput | CartItemsTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItemsTBLS.
     */
    cursor?: CartItemsTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItemsTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItemsTBLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItemsTBLS.
     */
    distinct?: CartItemsTBLScalarFieldEnum | CartItemsTBLScalarFieldEnum[]
  }


  /**
   * CartItemsTBL findMany
   */
  export type CartItemsTBLFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemsTBL
     */
    select?: CartItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartItemsTBLInclude<ExtArgs> | null
    /**
     * Filter, which CartItemsTBLS to fetch.
     */
    where?: CartItemsTBLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItemsTBLS to fetch.
     */
    orderBy?: CartItemsTBLOrderByWithRelationInput | CartItemsTBLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItemsTBLS.
     */
    cursor?: CartItemsTBLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItemsTBLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItemsTBLS.
     */
    skip?: number
    distinct?: CartItemsTBLScalarFieldEnum | CartItemsTBLScalarFieldEnum[]
  }


  /**
   * CartItemsTBL create
   */
  export type CartItemsTBLCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemsTBL
     */
    select?: CartItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartItemsTBLInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItemsTBL.
     */
    data: XOR<CartItemsTBLCreateInput, CartItemsTBLUncheckedCreateInput>
  }


  /**
   * CartItemsTBL createMany
   */
  export type CartItemsTBLCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItemsTBLS.
     */
    data: CartItemsTBLCreateManyInput | CartItemsTBLCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CartItemsTBL update
   */
  export type CartItemsTBLUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemsTBL
     */
    select?: CartItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartItemsTBLInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItemsTBL.
     */
    data: XOR<CartItemsTBLUpdateInput, CartItemsTBLUncheckedUpdateInput>
    /**
     * Choose, which CartItemsTBL to update.
     */
    where: CartItemsTBLWhereUniqueInput
  }


  /**
   * CartItemsTBL updateMany
   */
  export type CartItemsTBLUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItemsTBLS.
     */
    data: XOR<CartItemsTBLUpdateManyMutationInput, CartItemsTBLUncheckedUpdateManyInput>
    /**
     * Filter which CartItemsTBLS to update
     */
    where?: CartItemsTBLWhereInput
  }


  /**
   * CartItemsTBL upsert
   */
  export type CartItemsTBLUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemsTBL
     */
    select?: CartItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartItemsTBLInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItemsTBL to update in case it exists.
     */
    where: CartItemsTBLWhereUniqueInput
    /**
     * In case the CartItemsTBL found by the `where` argument doesn't exist, create a new CartItemsTBL with this data.
     */
    create: XOR<CartItemsTBLCreateInput, CartItemsTBLUncheckedCreateInput>
    /**
     * In case the CartItemsTBL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemsTBLUpdateInput, CartItemsTBLUncheckedUpdateInput>
  }


  /**
   * CartItemsTBL delete
   */
  export type CartItemsTBLDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemsTBL
     */
    select?: CartItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartItemsTBLInclude<ExtArgs> | null
    /**
     * Filter which CartItemsTBL to delete.
     */
    where: CartItemsTBLWhereUniqueInput
  }


  /**
   * CartItemsTBL deleteMany
   */
  export type CartItemsTBLDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItemsTBLS to delete
     */
    where?: CartItemsTBLWhereInput
  }


  /**
   * CartItemsTBL.carttid
   */
  export type CartItemsTBL$carttidArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartTBL
     */
    select?: CartTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartTBLInclude<ExtArgs> | null
    where?: CartTBLWhereInput
  }


  /**
   * CartItemsTBL without action
   */
  export type CartItemsTBLArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemsTBL
     */
    select?: CartItemsTBLSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartItemsTBLInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TokensTBLScalarFieldEnum: {
    tokenid: 'tokenid',
    refreshtoken: 'refreshtoken',
    userid: 'userid'
  };

  export type TokensTBLScalarFieldEnum = (typeof TokensTBLScalarFieldEnum)[keyof typeof TokensTBLScalarFieldEnum]


  export const BlacklistedTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    createdat: 'createdat'
  };

  export type BlacklistedTokenScalarFieldEnum = (typeof BlacklistedTokenScalarFieldEnum)[keyof typeof BlacklistedTokenScalarFieldEnum]


  export const UsersTBLScalarFieldEnum: {
    userid: 'userid',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    password: 'password',
    role: 'role'
  };

  export type UsersTBLScalarFieldEnum = (typeof UsersTBLScalarFieldEnum)[keyof typeof UsersTBLScalarFieldEnum]


  export const EmployeeTBLScalarFieldEnum: {
    empid: 'empid',
    roomid: 'roomid',
    officeid: 'officeid',
    siteid: 'siteid',
    buildingid: 'buildingid',
    departmentid: 'departmentid'
  };

  export type EmployeeTBLScalarFieldEnum = (typeof EmployeeTBLScalarFieldEnum)[keyof typeof EmployeeTBLScalarFieldEnum]


  export const OfficeBoyTBLScalarFieldEnum: {
    officeboyid: 'officeboyid',
    officeid: 'officeid',
    siteid: 'siteid'
  };

  export type OfficeBoyTBLScalarFieldEnum = (typeof OfficeBoyTBLScalarFieldEnum)[keyof typeof OfficeBoyTBLScalarFieldEnum]


  export const SiteTBLScalarFieldEnum: {
    siteid: 'siteid',
    sitename: 'sitename'
  };

  export type SiteTBLScalarFieldEnum = (typeof SiteTBLScalarFieldEnum)[keyof typeof SiteTBLScalarFieldEnum]


  export const BuildingTBLScalarFieldEnum: {
    buildingid: 'buildingid',
    buildingname: 'buildingname',
    siteid: 'siteid'
  };

  export type BuildingTBLScalarFieldEnum = (typeof BuildingTBLScalarFieldEnum)[keyof typeof BuildingTBLScalarFieldEnum]


  export const OfficeTBLScalarFieldEnum: {
    officeid: 'officeid',
    officeno: 'officeno',
    buildingid: 'buildingid'
  };

  export type OfficeTBLScalarFieldEnum = (typeof OfficeTBLScalarFieldEnum)[keyof typeof OfficeTBLScalarFieldEnum]


  export const DepartmentTBLScalarFieldEnum: {
    departmentid: 'departmentid',
    departmentname: 'departmentname',
    buildingid: 'buildingid'
  };

  export type DepartmentTBLScalarFieldEnum = (typeof DepartmentTBLScalarFieldEnum)[keyof typeof DepartmentTBLScalarFieldEnum]


  export const RoomTBLScalarFieldEnum: {
    roomid: 'roomid',
    roomno: 'roomno',
    roomname: 'roomname',
    officeid: 'officeid',
    departmentid: 'departmentid'
  };

  export type RoomTBLScalarFieldEnum = (typeof RoomTBLScalarFieldEnum)[keyof typeof RoomTBLScalarFieldEnum]


  export const CategoriesTblScalarFieldEnum: {
    categoryid: 'categoryid',
    categoryname: 'categoryname'
  };

  export type CategoriesTblScalarFieldEnum = (typeof CategoriesTblScalarFieldEnum)[keyof typeof CategoriesTblScalarFieldEnum]


  export const ItemsTBLScalarFieldEnum: {
    userid: 'userid',
    itemid: 'itemid',
    categoryid: 'categoryid',
    itemname: 'itemname',
    itemimagurl: 'itemimagurl',
    itemidescription: 'itemidescription'
  };

  export type ItemsTBLScalarFieldEnum = (typeof ItemsTBLScalarFieldEnum)[keyof typeof ItemsTBLScalarFieldEnum]


  export const OrdersTBLScalarFieldEnum: {
    orderid: 'orderid',
    empid: 'empid'
  };

  export type OrdersTBLScalarFieldEnum = (typeof OrdersTBLScalarFieldEnum)[keyof typeof OrdersTBLScalarFieldEnum]


  export const OrderItemsTBLScalarFieldEnum: {
    orderitemid: 'orderitemid',
    itemname: 'itemname',
    itemquantity: 'itemquantity',
    itemsize: 'itemsize',
    orderid: 'orderid'
  };

  export type OrderItemsTBLScalarFieldEnum = (typeof OrderItemsTBLScalarFieldEnum)[keyof typeof OrderItemsTBLScalarFieldEnum]


  export const CartTBLScalarFieldEnum: {
    cartid: 'cartid',
    empid: 'empid'
  };

  export type CartTBLScalarFieldEnum = (typeof CartTBLScalarFieldEnum)[keyof typeof CartTBLScalarFieldEnum]


  export const CartItemsTBLScalarFieldEnum: {
    cartitemid: 'cartitemid',
    quanity: 'quanity',
    cartid: 'cartid',
    itemsize: 'itemsize',
    notes: 'notes',
    itemid: 'itemid'
  };

  export type CartItemsTBLScalarFieldEnum = (typeof CartItemsTBLScalarFieldEnum)[keyof typeof CartItemsTBLScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TokensTBLWhereInput = {
    AND?: TokensTBLWhereInput | TokensTBLWhereInput[]
    OR?: TokensTBLWhereInput[]
    NOT?: TokensTBLWhereInput | TokensTBLWhereInput[]
    tokenid?: IntFilter<"TokensTBL"> | number
    refreshtoken?: StringFilter<"TokensTBL"> | string
    userid?: IntFilter<"TokensTBL"> | number
    reftoken?: XOR<UsersTBLRelationFilter, UsersTBLWhereInput>
  }

  export type TokensTBLOrderByWithRelationInput = {
    tokenid?: SortOrder
    refreshtoken?: SortOrder
    userid?: SortOrder
    reftoken?: UsersTBLOrderByWithRelationInput
  }

  export type TokensTBLWhereUniqueInput = Prisma.AtLeast<{
    tokenid?: number
    AND?: TokensTBLWhereInput | TokensTBLWhereInput[]
    OR?: TokensTBLWhereInput[]
    NOT?: TokensTBLWhereInput | TokensTBLWhereInput[]
    refreshtoken?: StringFilter<"TokensTBL"> | string
    userid?: IntFilter<"TokensTBL"> | number
    reftoken?: XOR<UsersTBLRelationFilter, UsersTBLWhereInput>
  }, "tokenid">

  export type TokensTBLOrderByWithAggregationInput = {
    tokenid?: SortOrder
    refreshtoken?: SortOrder
    userid?: SortOrder
    _count?: TokensTBLCountOrderByAggregateInput
    _avg?: TokensTBLAvgOrderByAggregateInput
    _max?: TokensTBLMaxOrderByAggregateInput
    _min?: TokensTBLMinOrderByAggregateInput
    _sum?: TokensTBLSumOrderByAggregateInput
  }

  export type TokensTBLScalarWhereWithAggregatesInput = {
    AND?: TokensTBLScalarWhereWithAggregatesInput | TokensTBLScalarWhereWithAggregatesInput[]
    OR?: TokensTBLScalarWhereWithAggregatesInput[]
    NOT?: TokensTBLScalarWhereWithAggregatesInput | TokensTBLScalarWhereWithAggregatesInput[]
    tokenid?: IntWithAggregatesFilter<"TokensTBL"> | number
    refreshtoken?: StringWithAggregatesFilter<"TokensTBL"> | string
    userid?: IntWithAggregatesFilter<"TokensTBL"> | number
  }

  export type BlacklistedTokenWhereInput = {
    AND?: BlacklistedTokenWhereInput | BlacklistedTokenWhereInput[]
    OR?: BlacklistedTokenWhereInput[]
    NOT?: BlacklistedTokenWhereInput | BlacklistedTokenWhereInput[]
    id?: IntFilter<"BlacklistedToken"> | number
    token?: StringFilter<"BlacklistedToken"> | string
    createdat?: DateTimeFilter<"BlacklistedToken"> | Date | string
  }

  export type BlacklistedTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    createdat?: SortOrder
  }

  export type BlacklistedTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: BlacklistedTokenWhereInput | BlacklistedTokenWhereInput[]
    OR?: BlacklistedTokenWhereInput[]
    NOT?: BlacklistedTokenWhereInput | BlacklistedTokenWhereInput[]
    createdat?: DateTimeFilter<"BlacklistedToken"> | Date | string
  }, "id" | "token">

  export type BlacklistedTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    createdat?: SortOrder
    _count?: BlacklistedTokenCountOrderByAggregateInput
    _avg?: BlacklistedTokenAvgOrderByAggregateInput
    _max?: BlacklistedTokenMaxOrderByAggregateInput
    _min?: BlacklistedTokenMinOrderByAggregateInput
    _sum?: BlacklistedTokenSumOrderByAggregateInput
  }

  export type BlacklistedTokenScalarWhereWithAggregatesInput = {
    AND?: BlacklistedTokenScalarWhereWithAggregatesInput | BlacklistedTokenScalarWhereWithAggregatesInput[]
    OR?: BlacklistedTokenScalarWhereWithAggregatesInput[]
    NOT?: BlacklistedTokenScalarWhereWithAggregatesInput | BlacklistedTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlacklistedToken"> | number
    token?: StringWithAggregatesFilter<"BlacklistedToken"> | string
    createdat?: DateTimeWithAggregatesFilter<"BlacklistedToken"> | Date | string
  }

  export type UsersTBLWhereInput = {
    AND?: UsersTBLWhereInput | UsersTBLWhereInput[]
    OR?: UsersTBLWhereInput[]
    NOT?: UsersTBLWhereInput | UsersTBLWhereInput[]
    userid?: IntFilter<"UsersTBL"> | number
    firstname?: StringFilter<"UsersTBL"> | string
    lastname?: StringFilter<"UsersTBL"> | string
    email?: StringFilter<"UsersTBL"> | string
    password?: StringFilter<"UsersTBL"> | string
    role?: StringFilter<"UsersTBL"> | string
    Employee?: EmployeeTBLListRelationFilter
    Items?: ItemsTBLListRelationFilter
    Tokens?: TokensTBLListRelationFilter
    Officeboy?: OfficeBoyTBLListRelationFilter
  }

  export type UsersTBLOrderByWithRelationInput = {
    userid?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    Employee?: EmployeeTBLOrderByRelationAggregateInput
    Items?: ItemsTBLOrderByRelationAggregateInput
    Tokens?: TokensTBLOrderByRelationAggregateInput
    Officeboy?: OfficeBoyTBLOrderByRelationAggregateInput
  }

  export type UsersTBLWhereUniqueInput = Prisma.AtLeast<{
    userid?: number
    email?: string
    AND?: UsersTBLWhereInput | UsersTBLWhereInput[]
    OR?: UsersTBLWhereInput[]
    NOT?: UsersTBLWhereInput | UsersTBLWhereInput[]
    firstname?: StringFilter<"UsersTBL"> | string
    lastname?: StringFilter<"UsersTBL"> | string
    password?: StringFilter<"UsersTBL"> | string
    role?: StringFilter<"UsersTBL"> | string
    Employee?: EmployeeTBLListRelationFilter
    Items?: ItemsTBLListRelationFilter
    Tokens?: TokensTBLListRelationFilter
    Officeboy?: OfficeBoyTBLListRelationFilter
  }, "userid" | "email">

  export type UsersTBLOrderByWithAggregationInput = {
    userid?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: UsersTBLCountOrderByAggregateInput
    _avg?: UsersTBLAvgOrderByAggregateInput
    _max?: UsersTBLMaxOrderByAggregateInput
    _min?: UsersTBLMinOrderByAggregateInput
    _sum?: UsersTBLSumOrderByAggregateInput
  }

  export type UsersTBLScalarWhereWithAggregatesInput = {
    AND?: UsersTBLScalarWhereWithAggregatesInput | UsersTBLScalarWhereWithAggregatesInput[]
    OR?: UsersTBLScalarWhereWithAggregatesInput[]
    NOT?: UsersTBLScalarWhereWithAggregatesInput | UsersTBLScalarWhereWithAggregatesInput[]
    userid?: IntWithAggregatesFilter<"UsersTBL"> | number
    firstname?: StringWithAggregatesFilter<"UsersTBL"> | string
    lastname?: StringWithAggregatesFilter<"UsersTBL"> | string
    email?: StringWithAggregatesFilter<"UsersTBL"> | string
    password?: StringWithAggregatesFilter<"UsersTBL"> | string
    role?: StringWithAggregatesFilter<"UsersTBL"> | string
  }

  export type EmployeeTBLWhereInput = {
    AND?: EmployeeTBLWhereInput | EmployeeTBLWhereInput[]
    OR?: EmployeeTBLWhereInput[]
    NOT?: EmployeeTBLWhereInput | EmployeeTBLWhereInput[]
    empid?: IntFilter<"EmployeeTBL"> | number
    roomid?: IntFilter<"EmployeeTBL"> | number
    officeid?: IntFilter<"EmployeeTBL"> | number
    siteid?: IntFilter<"EmployeeTBL"> | number
    buildingid?: IntFilter<"EmployeeTBL"> | number
    departmentid?: IntFilter<"EmployeeTBL"> | number
    emp?: XOR<UsersTBLRelationFilter, UsersTBLWhereInput>
    romid?: XOR<RoomTBLRelationFilter, RoomTBLWhereInput>
    offid?: XOR<OfficeTBLRelationFilter, OfficeTBLWhereInput>
    sitid?: XOR<SiteTBLRelationFilter, SiteTBLWhereInput>
    bulidingref?: XOR<BuildingTBLRelationFilter, BuildingTBLWhereInput>
    departmentref?: XOR<DepartmentTBLRelationFilter, DepartmentTBLWhereInput>
    Cart?: CartTBLListRelationFilter
    OrdersTBL?: OrdersTBLListRelationFilter
  }

  export type EmployeeTBLOrderByWithRelationInput = {
    empid?: SortOrder
    roomid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
    buildingid?: SortOrder
    departmentid?: SortOrder
    emp?: UsersTBLOrderByWithRelationInput
    romid?: RoomTBLOrderByWithRelationInput
    offid?: OfficeTBLOrderByWithRelationInput
    sitid?: SiteTBLOrderByWithRelationInput
    bulidingref?: BuildingTBLOrderByWithRelationInput
    departmentref?: DepartmentTBLOrderByWithRelationInput
    Cart?: CartTBLOrderByRelationAggregateInput
    OrdersTBL?: OrdersTBLOrderByRelationAggregateInput
  }

  export type EmployeeTBLWhereUniqueInput = Prisma.AtLeast<{
    empid?: number
    AND?: EmployeeTBLWhereInput | EmployeeTBLWhereInput[]
    OR?: EmployeeTBLWhereInput[]
    NOT?: EmployeeTBLWhereInput | EmployeeTBLWhereInput[]
    roomid?: IntFilter<"EmployeeTBL"> | number
    officeid?: IntFilter<"EmployeeTBL"> | number
    siteid?: IntFilter<"EmployeeTBL"> | number
    buildingid?: IntFilter<"EmployeeTBL"> | number
    departmentid?: IntFilter<"EmployeeTBL"> | number
    emp?: XOR<UsersTBLRelationFilter, UsersTBLWhereInput>
    romid?: XOR<RoomTBLRelationFilter, RoomTBLWhereInput>
    offid?: XOR<OfficeTBLRelationFilter, OfficeTBLWhereInput>
    sitid?: XOR<SiteTBLRelationFilter, SiteTBLWhereInput>
    bulidingref?: XOR<BuildingTBLRelationFilter, BuildingTBLWhereInput>
    departmentref?: XOR<DepartmentTBLRelationFilter, DepartmentTBLWhereInput>
    Cart?: CartTBLListRelationFilter
    OrdersTBL?: OrdersTBLListRelationFilter
  }, "empid" | "empid">

  export type EmployeeTBLOrderByWithAggregationInput = {
    empid?: SortOrder
    roomid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
    buildingid?: SortOrder
    departmentid?: SortOrder
    _count?: EmployeeTBLCountOrderByAggregateInput
    _avg?: EmployeeTBLAvgOrderByAggregateInput
    _max?: EmployeeTBLMaxOrderByAggregateInput
    _min?: EmployeeTBLMinOrderByAggregateInput
    _sum?: EmployeeTBLSumOrderByAggregateInput
  }

  export type EmployeeTBLScalarWhereWithAggregatesInput = {
    AND?: EmployeeTBLScalarWhereWithAggregatesInput | EmployeeTBLScalarWhereWithAggregatesInput[]
    OR?: EmployeeTBLScalarWhereWithAggregatesInput[]
    NOT?: EmployeeTBLScalarWhereWithAggregatesInput | EmployeeTBLScalarWhereWithAggregatesInput[]
    empid?: IntWithAggregatesFilter<"EmployeeTBL"> | number
    roomid?: IntWithAggregatesFilter<"EmployeeTBL"> | number
    officeid?: IntWithAggregatesFilter<"EmployeeTBL"> | number
    siteid?: IntWithAggregatesFilter<"EmployeeTBL"> | number
    buildingid?: IntWithAggregatesFilter<"EmployeeTBL"> | number
    departmentid?: IntWithAggregatesFilter<"EmployeeTBL"> | number
  }

  export type OfficeBoyTBLWhereInput = {
    AND?: OfficeBoyTBLWhereInput | OfficeBoyTBLWhereInput[]
    OR?: OfficeBoyTBLWhereInput[]
    NOT?: OfficeBoyTBLWhereInput | OfficeBoyTBLWhereInput[]
    officeboyid?: IntFilter<"OfficeBoyTBL"> | number
    officeid?: IntFilter<"OfficeBoyTBL"> | number
    siteid?: IntFilter<"OfficeBoyTBL"> | number
    officeboy?: XOR<UsersTBLRelationFilter, UsersTBLWhereInput>
    offid?: XOR<OfficeTBLRelationFilter, OfficeTBLWhereInput>
    siteref?: XOR<SiteTBLRelationFilter, SiteTBLWhereInput>
  }

  export type OfficeBoyTBLOrderByWithRelationInput = {
    officeboyid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
    officeboy?: UsersTBLOrderByWithRelationInput
    offid?: OfficeTBLOrderByWithRelationInput
    siteref?: SiteTBLOrderByWithRelationInput
  }

  export type OfficeBoyTBLWhereUniqueInput = Prisma.AtLeast<{
    officeboyid?: number
    AND?: OfficeBoyTBLWhereInput | OfficeBoyTBLWhereInput[]
    OR?: OfficeBoyTBLWhereInput[]
    NOT?: OfficeBoyTBLWhereInput | OfficeBoyTBLWhereInput[]
    officeid?: IntFilter<"OfficeBoyTBL"> | number
    siteid?: IntFilter<"OfficeBoyTBL"> | number
    officeboy?: XOR<UsersTBLRelationFilter, UsersTBLWhereInput>
    offid?: XOR<OfficeTBLRelationFilter, OfficeTBLWhereInput>
    siteref?: XOR<SiteTBLRelationFilter, SiteTBLWhereInput>
  }, "officeboyid" | "officeboyid">

  export type OfficeBoyTBLOrderByWithAggregationInput = {
    officeboyid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
    _count?: OfficeBoyTBLCountOrderByAggregateInput
    _avg?: OfficeBoyTBLAvgOrderByAggregateInput
    _max?: OfficeBoyTBLMaxOrderByAggregateInput
    _min?: OfficeBoyTBLMinOrderByAggregateInput
    _sum?: OfficeBoyTBLSumOrderByAggregateInput
  }

  export type OfficeBoyTBLScalarWhereWithAggregatesInput = {
    AND?: OfficeBoyTBLScalarWhereWithAggregatesInput | OfficeBoyTBLScalarWhereWithAggregatesInput[]
    OR?: OfficeBoyTBLScalarWhereWithAggregatesInput[]
    NOT?: OfficeBoyTBLScalarWhereWithAggregatesInput | OfficeBoyTBLScalarWhereWithAggregatesInput[]
    officeboyid?: IntWithAggregatesFilter<"OfficeBoyTBL"> | number
    officeid?: IntWithAggregatesFilter<"OfficeBoyTBL"> | number
    siteid?: IntWithAggregatesFilter<"OfficeBoyTBL"> | number
  }

  export type SiteTBLWhereInput = {
    AND?: SiteTBLWhereInput | SiteTBLWhereInput[]
    OR?: SiteTBLWhereInput[]
    NOT?: SiteTBLWhereInput | SiteTBLWhereInput[]
    siteid?: IntFilter<"SiteTBL"> | number
    sitename?: StringFilter<"SiteTBL"> | string
    Employee?: EmployeeTBLListRelationFilter
    Building?: BuildingTBLListRelationFilter
    Officeboy?: OfficeBoyTBLListRelationFilter
  }

  export type SiteTBLOrderByWithRelationInput = {
    siteid?: SortOrder
    sitename?: SortOrder
    Employee?: EmployeeTBLOrderByRelationAggregateInput
    Building?: BuildingTBLOrderByRelationAggregateInput
    Officeboy?: OfficeBoyTBLOrderByRelationAggregateInput
  }

  export type SiteTBLWhereUniqueInput = Prisma.AtLeast<{
    siteid?: number
    sitename?: string
    AND?: SiteTBLWhereInput | SiteTBLWhereInput[]
    OR?: SiteTBLWhereInput[]
    NOT?: SiteTBLWhereInput | SiteTBLWhereInput[]
    Employee?: EmployeeTBLListRelationFilter
    Building?: BuildingTBLListRelationFilter
    Officeboy?: OfficeBoyTBLListRelationFilter
  }, "siteid" | "siteid" | "sitename">

  export type SiteTBLOrderByWithAggregationInput = {
    siteid?: SortOrder
    sitename?: SortOrder
    _count?: SiteTBLCountOrderByAggregateInput
    _avg?: SiteTBLAvgOrderByAggregateInput
    _max?: SiteTBLMaxOrderByAggregateInput
    _min?: SiteTBLMinOrderByAggregateInput
    _sum?: SiteTBLSumOrderByAggregateInput
  }

  export type SiteTBLScalarWhereWithAggregatesInput = {
    AND?: SiteTBLScalarWhereWithAggregatesInput | SiteTBLScalarWhereWithAggregatesInput[]
    OR?: SiteTBLScalarWhereWithAggregatesInput[]
    NOT?: SiteTBLScalarWhereWithAggregatesInput | SiteTBLScalarWhereWithAggregatesInput[]
    siteid?: IntWithAggregatesFilter<"SiteTBL"> | number
    sitename?: StringWithAggregatesFilter<"SiteTBL"> | string
  }

  export type BuildingTBLWhereInput = {
    AND?: BuildingTBLWhereInput | BuildingTBLWhereInput[]
    OR?: BuildingTBLWhereInput[]
    NOT?: BuildingTBLWhereInput | BuildingTBLWhereInput[]
    buildingid?: IntFilter<"BuildingTBL"> | number
    buildingname?: StringFilter<"BuildingTBL"> | string
    siteid?: IntFilter<"BuildingTBL"> | number
    siteref?: XOR<SiteTBLRelationFilter, SiteTBLWhereInput>
    Department?: DepartmentTBLListRelationFilter
    Office?: OfficeTBLListRelationFilter
    Employee?: EmployeeTBLListRelationFilter
  }

  export type BuildingTBLOrderByWithRelationInput = {
    buildingid?: SortOrder
    buildingname?: SortOrder
    siteid?: SortOrder
    siteref?: SiteTBLOrderByWithRelationInput
    Department?: DepartmentTBLOrderByRelationAggregateInput
    Office?: OfficeTBLOrderByRelationAggregateInput
    Employee?: EmployeeTBLOrderByRelationAggregateInput
  }

  export type BuildingTBLWhereUniqueInput = Prisma.AtLeast<{
    buildingid?: number
    buildingname?: string
    AND?: BuildingTBLWhereInput | BuildingTBLWhereInput[]
    OR?: BuildingTBLWhereInput[]
    NOT?: BuildingTBLWhereInput | BuildingTBLWhereInput[]
    siteid?: IntFilter<"BuildingTBL"> | number
    siteref?: XOR<SiteTBLRelationFilter, SiteTBLWhereInput>
    Department?: DepartmentTBLListRelationFilter
    Office?: OfficeTBLListRelationFilter
    Employee?: EmployeeTBLListRelationFilter
  }, "buildingid" | "buildingid" | "buildingname">

  export type BuildingTBLOrderByWithAggregationInput = {
    buildingid?: SortOrder
    buildingname?: SortOrder
    siteid?: SortOrder
    _count?: BuildingTBLCountOrderByAggregateInput
    _avg?: BuildingTBLAvgOrderByAggregateInput
    _max?: BuildingTBLMaxOrderByAggregateInput
    _min?: BuildingTBLMinOrderByAggregateInput
    _sum?: BuildingTBLSumOrderByAggregateInput
  }

  export type BuildingTBLScalarWhereWithAggregatesInput = {
    AND?: BuildingTBLScalarWhereWithAggregatesInput | BuildingTBLScalarWhereWithAggregatesInput[]
    OR?: BuildingTBLScalarWhereWithAggregatesInput[]
    NOT?: BuildingTBLScalarWhereWithAggregatesInput | BuildingTBLScalarWhereWithAggregatesInput[]
    buildingid?: IntWithAggregatesFilter<"BuildingTBL"> | number
    buildingname?: StringWithAggregatesFilter<"BuildingTBL"> | string
    siteid?: IntWithAggregatesFilter<"BuildingTBL"> | number
  }

  export type OfficeTBLWhereInput = {
    AND?: OfficeTBLWhereInput | OfficeTBLWhereInput[]
    OR?: OfficeTBLWhereInput[]
    NOT?: OfficeTBLWhereInput | OfficeTBLWhereInput[]
    officeid?: IntFilter<"OfficeTBL"> | number
    officeno?: IntFilter<"OfficeTBL"> | number
    buildingid?: IntFilter<"OfficeTBL"> | number
    Employee?: EmployeeTBLListRelationFilter
    Officeboy?: OfficeBoyTBLListRelationFilter
    bulidingref?: XOR<BuildingTBLRelationFilter, BuildingTBLWhereInput>
    Room?: RoomTBLListRelationFilter
  }

  export type OfficeTBLOrderByWithRelationInput = {
    officeid?: SortOrder
    officeno?: SortOrder
    buildingid?: SortOrder
    Employee?: EmployeeTBLOrderByRelationAggregateInput
    Officeboy?: OfficeBoyTBLOrderByRelationAggregateInput
    bulidingref?: BuildingTBLOrderByWithRelationInput
    Room?: RoomTBLOrderByRelationAggregateInput
  }

  export type OfficeTBLWhereUniqueInput = Prisma.AtLeast<{
    officeid?: number
    officeno?: number
    AND?: OfficeTBLWhereInput | OfficeTBLWhereInput[]
    OR?: OfficeTBLWhereInput[]
    NOT?: OfficeTBLWhereInput | OfficeTBLWhereInput[]
    buildingid?: IntFilter<"OfficeTBL"> | number
    Employee?: EmployeeTBLListRelationFilter
    Officeboy?: OfficeBoyTBLListRelationFilter
    bulidingref?: XOR<BuildingTBLRelationFilter, BuildingTBLWhereInput>
    Room?: RoomTBLListRelationFilter
  }, "officeid" | "officeid" | "officeno">

  export type OfficeTBLOrderByWithAggregationInput = {
    officeid?: SortOrder
    officeno?: SortOrder
    buildingid?: SortOrder
    _count?: OfficeTBLCountOrderByAggregateInput
    _avg?: OfficeTBLAvgOrderByAggregateInput
    _max?: OfficeTBLMaxOrderByAggregateInput
    _min?: OfficeTBLMinOrderByAggregateInput
    _sum?: OfficeTBLSumOrderByAggregateInput
  }

  export type OfficeTBLScalarWhereWithAggregatesInput = {
    AND?: OfficeTBLScalarWhereWithAggregatesInput | OfficeTBLScalarWhereWithAggregatesInput[]
    OR?: OfficeTBLScalarWhereWithAggregatesInput[]
    NOT?: OfficeTBLScalarWhereWithAggregatesInput | OfficeTBLScalarWhereWithAggregatesInput[]
    officeid?: IntWithAggregatesFilter<"OfficeTBL"> | number
    officeno?: IntWithAggregatesFilter<"OfficeTBL"> | number
    buildingid?: IntWithAggregatesFilter<"OfficeTBL"> | number
  }

  export type DepartmentTBLWhereInput = {
    AND?: DepartmentTBLWhereInput | DepartmentTBLWhereInput[]
    OR?: DepartmentTBLWhereInput[]
    NOT?: DepartmentTBLWhereInput | DepartmentTBLWhereInput[]
    departmentid?: IntFilter<"DepartmentTBL"> | number
    departmentname?: StringFilter<"DepartmentTBL"> | string
    buildingid?: IntFilter<"DepartmentTBL"> | number
    Room?: RoomTBLListRelationFilter
    Employee?: EmployeeTBLListRelationFilter
    bulidingref?: XOR<BuildingTBLRelationFilter, BuildingTBLWhereInput>
  }

  export type DepartmentTBLOrderByWithRelationInput = {
    departmentid?: SortOrder
    departmentname?: SortOrder
    buildingid?: SortOrder
    Room?: RoomTBLOrderByRelationAggregateInput
    Employee?: EmployeeTBLOrderByRelationAggregateInput
    bulidingref?: BuildingTBLOrderByWithRelationInput
  }

  export type DepartmentTBLWhereUniqueInput = Prisma.AtLeast<{
    departmentid?: number
    departmentname?: string
    AND?: DepartmentTBLWhereInput | DepartmentTBLWhereInput[]
    OR?: DepartmentTBLWhereInput[]
    NOT?: DepartmentTBLWhereInput | DepartmentTBLWhereInput[]
    buildingid?: IntFilter<"DepartmentTBL"> | number
    Room?: RoomTBLListRelationFilter
    Employee?: EmployeeTBLListRelationFilter
    bulidingref?: XOR<BuildingTBLRelationFilter, BuildingTBLWhereInput>
  }, "departmentid" | "departmentid" | "departmentname">

  export type DepartmentTBLOrderByWithAggregationInput = {
    departmentid?: SortOrder
    departmentname?: SortOrder
    buildingid?: SortOrder
    _count?: DepartmentTBLCountOrderByAggregateInput
    _avg?: DepartmentTBLAvgOrderByAggregateInput
    _max?: DepartmentTBLMaxOrderByAggregateInput
    _min?: DepartmentTBLMinOrderByAggregateInput
    _sum?: DepartmentTBLSumOrderByAggregateInput
  }

  export type DepartmentTBLScalarWhereWithAggregatesInput = {
    AND?: DepartmentTBLScalarWhereWithAggregatesInput | DepartmentTBLScalarWhereWithAggregatesInput[]
    OR?: DepartmentTBLScalarWhereWithAggregatesInput[]
    NOT?: DepartmentTBLScalarWhereWithAggregatesInput | DepartmentTBLScalarWhereWithAggregatesInput[]
    departmentid?: IntWithAggregatesFilter<"DepartmentTBL"> | number
    departmentname?: StringWithAggregatesFilter<"DepartmentTBL"> | string
    buildingid?: IntWithAggregatesFilter<"DepartmentTBL"> | number
  }

  export type RoomTBLWhereInput = {
    AND?: RoomTBLWhereInput | RoomTBLWhereInput[]
    OR?: RoomTBLWhereInput[]
    NOT?: RoomTBLWhereInput | RoomTBLWhereInput[]
    roomid?: IntFilter<"RoomTBL"> | number
    roomno?: IntFilter<"RoomTBL"> | number
    roomname?: StringFilter<"RoomTBL"> | string
    officeid?: IntFilter<"RoomTBL"> | number
    departmentid?: IntFilter<"RoomTBL"> | number
    officeref?: XOR<OfficeTBLRelationFilter, OfficeTBLWhereInput>
    roomdepref?: XOR<DepartmentTBLRelationFilter, DepartmentTBLWhereInput>
    Employee?: EmployeeTBLListRelationFilter
  }

  export type RoomTBLOrderByWithRelationInput = {
    roomid?: SortOrder
    roomno?: SortOrder
    roomname?: SortOrder
    officeid?: SortOrder
    departmentid?: SortOrder
    officeref?: OfficeTBLOrderByWithRelationInput
    roomdepref?: DepartmentTBLOrderByWithRelationInput
    Employee?: EmployeeTBLOrderByRelationAggregateInput
  }

  export type RoomTBLWhereUniqueInput = Prisma.AtLeast<{
    roomid?: number
    roomno?: number
    roomname?: string
    AND?: RoomTBLWhereInput | RoomTBLWhereInput[]
    OR?: RoomTBLWhereInput[]
    NOT?: RoomTBLWhereInput | RoomTBLWhereInput[]
    officeid?: IntFilter<"RoomTBL"> | number
    departmentid?: IntFilter<"RoomTBL"> | number
    officeref?: XOR<OfficeTBLRelationFilter, OfficeTBLWhereInput>
    roomdepref?: XOR<DepartmentTBLRelationFilter, DepartmentTBLWhereInput>
    Employee?: EmployeeTBLListRelationFilter
  }, "roomid" | "roomid" | "roomno" | "roomname">

  export type RoomTBLOrderByWithAggregationInput = {
    roomid?: SortOrder
    roomno?: SortOrder
    roomname?: SortOrder
    officeid?: SortOrder
    departmentid?: SortOrder
    _count?: RoomTBLCountOrderByAggregateInput
    _avg?: RoomTBLAvgOrderByAggregateInput
    _max?: RoomTBLMaxOrderByAggregateInput
    _min?: RoomTBLMinOrderByAggregateInput
    _sum?: RoomTBLSumOrderByAggregateInput
  }

  export type RoomTBLScalarWhereWithAggregatesInput = {
    AND?: RoomTBLScalarWhereWithAggregatesInput | RoomTBLScalarWhereWithAggregatesInput[]
    OR?: RoomTBLScalarWhereWithAggregatesInput[]
    NOT?: RoomTBLScalarWhereWithAggregatesInput | RoomTBLScalarWhereWithAggregatesInput[]
    roomid?: IntWithAggregatesFilter<"RoomTBL"> | number
    roomno?: IntWithAggregatesFilter<"RoomTBL"> | number
    roomname?: StringWithAggregatesFilter<"RoomTBL"> | string
    officeid?: IntWithAggregatesFilter<"RoomTBL"> | number
    departmentid?: IntWithAggregatesFilter<"RoomTBL"> | number
  }

  export type CategoriesTblWhereInput = {
    AND?: CategoriesTblWhereInput | CategoriesTblWhereInput[]
    OR?: CategoriesTblWhereInput[]
    NOT?: CategoriesTblWhereInput | CategoriesTblWhereInput[]
    categoryid?: IntFilter<"CategoriesTbl"> | number
    categoryname?: StringFilter<"CategoriesTbl"> | string
    Item?: ItemsTBLListRelationFilter
  }

  export type CategoriesTblOrderByWithRelationInput = {
    categoryid?: SortOrder
    categoryname?: SortOrder
    Item?: ItemsTBLOrderByRelationAggregateInput
  }

  export type CategoriesTblWhereUniqueInput = Prisma.AtLeast<{
    categoryid?: number
    categoryname?: string
    AND?: CategoriesTblWhereInput | CategoriesTblWhereInput[]
    OR?: CategoriesTblWhereInput[]
    NOT?: CategoriesTblWhereInput | CategoriesTblWhereInput[]
    Item?: ItemsTBLListRelationFilter
  }, "categoryid" | "categoryid" | "categoryname">

  export type CategoriesTblOrderByWithAggregationInput = {
    categoryid?: SortOrder
    categoryname?: SortOrder
    _count?: CategoriesTblCountOrderByAggregateInput
    _avg?: CategoriesTblAvgOrderByAggregateInput
    _max?: CategoriesTblMaxOrderByAggregateInput
    _min?: CategoriesTblMinOrderByAggregateInput
    _sum?: CategoriesTblSumOrderByAggregateInput
  }

  export type CategoriesTblScalarWhereWithAggregatesInput = {
    AND?: CategoriesTblScalarWhereWithAggregatesInput | CategoriesTblScalarWhereWithAggregatesInput[]
    OR?: CategoriesTblScalarWhereWithAggregatesInput[]
    NOT?: CategoriesTblScalarWhereWithAggregatesInput | CategoriesTblScalarWhereWithAggregatesInput[]
    categoryid?: IntWithAggregatesFilter<"CategoriesTbl"> | number
    categoryname?: StringWithAggregatesFilter<"CategoriesTbl"> | string
  }

  export type ItemsTBLWhereInput = {
    AND?: ItemsTBLWhereInput | ItemsTBLWhereInput[]
    OR?: ItemsTBLWhereInput[]
    NOT?: ItemsTBLWhereInput | ItemsTBLWhereInput[]
    userid?: IntFilter<"ItemsTBL"> | number
    itemid?: IntFilter<"ItemsTBL"> | number
    categoryid?: IntFilter<"ItemsTBL"> | number
    itemname?: StringFilter<"ItemsTBL"> | string
    itemimagurl?: StringFilter<"ItemsTBL"> | string
    itemidescription?: StringFilter<"ItemsTBL"> | string
    creator?: XOR<UsersTBLRelationFilter, UsersTBLWhereInput>
    catid?: XOR<CategoriesTblRelationFilter, CategoriesTblWhereInput>
    CartItems?: CartItemsTBLListRelationFilter
  }

  export type ItemsTBLOrderByWithRelationInput = {
    userid?: SortOrder
    itemid?: SortOrder
    categoryid?: SortOrder
    itemname?: SortOrder
    itemimagurl?: SortOrder
    itemidescription?: SortOrder
    creator?: UsersTBLOrderByWithRelationInput
    catid?: CategoriesTblOrderByWithRelationInput
    CartItems?: CartItemsTBLOrderByRelationAggregateInput
  }

  export type ItemsTBLWhereUniqueInput = Prisma.AtLeast<{
    itemid?: number
    itemname?: string
    AND?: ItemsTBLWhereInput | ItemsTBLWhereInput[]
    OR?: ItemsTBLWhereInput[]
    NOT?: ItemsTBLWhereInput | ItemsTBLWhereInput[]
    userid?: IntFilter<"ItemsTBL"> | number
    categoryid?: IntFilter<"ItemsTBL"> | number
    itemimagurl?: StringFilter<"ItemsTBL"> | string
    itemidescription?: StringFilter<"ItemsTBL"> | string
    creator?: XOR<UsersTBLRelationFilter, UsersTBLWhereInput>
    catid?: XOR<CategoriesTblRelationFilter, CategoriesTblWhereInput>
    CartItems?: CartItemsTBLListRelationFilter
  }, "itemid" | "itemid" | "itemname">

  export type ItemsTBLOrderByWithAggregationInput = {
    userid?: SortOrder
    itemid?: SortOrder
    categoryid?: SortOrder
    itemname?: SortOrder
    itemimagurl?: SortOrder
    itemidescription?: SortOrder
    _count?: ItemsTBLCountOrderByAggregateInput
    _avg?: ItemsTBLAvgOrderByAggregateInput
    _max?: ItemsTBLMaxOrderByAggregateInput
    _min?: ItemsTBLMinOrderByAggregateInput
    _sum?: ItemsTBLSumOrderByAggregateInput
  }

  export type ItemsTBLScalarWhereWithAggregatesInput = {
    AND?: ItemsTBLScalarWhereWithAggregatesInput | ItemsTBLScalarWhereWithAggregatesInput[]
    OR?: ItemsTBLScalarWhereWithAggregatesInput[]
    NOT?: ItemsTBLScalarWhereWithAggregatesInput | ItemsTBLScalarWhereWithAggregatesInput[]
    userid?: IntWithAggregatesFilter<"ItemsTBL"> | number
    itemid?: IntWithAggregatesFilter<"ItemsTBL"> | number
    categoryid?: IntWithAggregatesFilter<"ItemsTBL"> | number
    itemname?: StringWithAggregatesFilter<"ItemsTBL"> | string
    itemimagurl?: StringWithAggregatesFilter<"ItemsTBL"> | string
    itemidescription?: StringWithAggregatesFilter<"ItemsTBL"> | string
  }

  export type OrdersTBLWhereInput = {
    AND?: OrdersTBLWhereInput | OrdersTBLWhereInput[]
    OR?: OrdersTBLWhereInput[]
    NOT?: OrdersTBLWhereInput | OrdersTBLWhereInput[]
    orderid?: IntFilter<"OrdersTBL"> | number
    empid?: IntFilter<"OrdersTBL"> | number
    empref?: XOR<EmployeeTBLRelationFilter, EmployeeTBLWhereInput>
    orderItems?: OrderItemsTBLListRelationFilter
  }

  export type OrdersTBLOrderByWithRelationInput = {
    orderid?: SortOrder
    empid?: SortOrder
    empref?: EmployeeTBLOrderByWithRelationInput
    orderItems?: OrderItemsTBLOrderByRelationAggregateInput
  }

  export type OrdersTBLWhereUniqueInput = Prisma.AtLeast<{
    orderid?: number
    AND?: OrdersTBLWhereInput | OrdersTBLWhereInput[]
    OR?: OrdersTBLWhereInput[]
    NOT?: OrdersTBLWhereInput | OrdersTBLWhereInput[]
    empid?: IntFilter<"OrdersTBL"> | number
    empref?: XOR<EmployeeTBLRelationFilter, EmployeeTBLWhereInput>
    orderItems?: OrderItemsTBLListRelationFilter
  }, "orderid" | "orderid">

  export type OrdersTBLOrderByWithAggregationInput = {
    orderid?: SortOrder
    empid?: SortOrder
    _count?: OrdersTBLCountOrderByAggregateInput
    _avg?: OrdersTBLAvgOrderByAggregateInput
    _max?: OrdersTBLMaxOrderByAggregateInput
    _min?: OrdersTBLMinOrderByAggregateInput
    _sum?: OrdersTBLSumOrderByAggregateInput
  }

  export type OrdersTBLScalarWhereWithAggregatesInput = {
    AND?: OrdersTBLScalarWhereWithAggregatesInput | OrdersTBLScalarWhereWithAggregatesInput[]
    OR?: OrdersTBLScalarWhereWithAggregatesInput[]
    NOT?: OrdersTBLScalarWhereWithAggregatesInput | OrdersTBLScalarWhereWithAggregatesInput[]
    orderid?: IntWithAggregatesFilter<"OrdersTBL"> | number
    empid?: IntWithAggregatesFilter<"OrdersTBL"> | number
  }

  export type OrderItemsTBLWhereInput = {
    AND?: OrderItemsTBLWhereInput | OrderItemsTBLWhereInput[]
    OR?: OrderItemsTBLWhereInput[]
    NOT?: OrderItemsTBLWhereInput | OrderItemsTBLWhereInput[]
    orderitemid?: IntFilter<"OrderItemsTBL"> | number
    itemname?: StringFilter<"OrderItemsTBL"> | string
    itemquantity?: IntFilter<"OrderItemsTBL"> | number
    itemsize?: StringFilter<"OrderItemsTBL"> | string
    orderid?: IntFilter<"OrderItemsTBL"> | number
    ordersid?: XOR<OrdersTBLRelationFilter, OrdersTBLWhereInput>
  }

  export type OrderItemsTBLOrderByWithRelationInput = {
    orderitemid?: SortOrder
    itemname?: SortOrder
    itemquantity?: SortOrder
    itemsize?: SortOrder
    orderid?: SortOrder
    ordersid?: OrdersTBLOrderByWithRelationInput
  }

  export type OrderItemsTBLWhereUniqueInput = Prisma.AtLeast<{
    orderitemid?: number
    AND?: OrderItemsTBLWhereInput | OrderItemsTBLWhereInput[]
    OR?: OrderItemsTBLWhereInput[]
    NOT?: OrderItemsTBLWhereInput | OrderItemsTBLWhereInput[]
    itemname?: StringFilter<"OrderItemsTBL"> | string
    itemquantity?: IntFilter<"OrderItemsTBL"> | number
    itemsize?: StringFilter<"OrderItemsTBL"> | string
    orderid?: IntFilter<"OrderItemsTBL"> | number
    ordersid?: XOR<OrdersTBLRelationFilter, OrdersTBLWhereInput>
  }, "orderitemid" | "orderitemid">

  export type OrderItemsTBLOrderByWithAggregationInput = {
    orderitemid?: SortOrder
    itemname?: SortOrder
    itemquantity?: SortOrder
    itemsize?: SortOrder
    orderid?: SortOrder
    _count?: OrderItemsTBLCountOrderByAggregateInput
    _avg?: OrderItemsTBLAvgOrderByAggregateInput
    _max?: OrderItemsTBLMaxOrderByAggregateInput
    _min?: OrderItemsTBLMinOrderByAggregateInput
    _sum?: OrderItemsTBLSumOrderByAggregateInput
  }

  export type OrderItemsTBLScalarWhereWithAggregatesInput = {
    AND?: OrderItemsTBLScalarWhereWithAggregatesInput | OrderItemsTBLScalarWhereWithAggregatesInput[]
    OR?: OrderItemsTBLScalarWhereWithAggregatesInput[]
    NOT?: OrderItemsTBLScalarWhereWithAggregatesInput | OrderItemsTBLScalarWhereWithAggregatesInput[]
    orderitemid?: IntWithAggregatesFilter<"OrderItemsTBL"> | number
    itemname?: StringWithAggregatesFilter<"OrderItemsTBL"> | string
    itemquantity?: IntWithAggregatesFilter<"OrderItemsTBL"> | number
    itemsize?: StringWithAggregatesFilter<"OrderItemsTBL"> | string
    orderid?: IntWithAggregatesFilter<"OrderItemsTBL"> | number
  }

  export type CartTBLWhereInput = {
    AND?: CartTBLWhereInput | CartTBLWhereInput[]
    OR?: CartTBLWhereInput[]
    NOT?: CartTBLWhereInput | CartTBLWhereInput[]
    cartid?: IntFilter<"CartTBL"> | number
    empid?: IntFilter<"CartTBL"> | number
    employeeid?: XOR<EmployeeTBLRelationFilter, EmployeeTBLWhereInput>
    CartItems?: CartItemsTBLListRelationFilter
  }

  export type CartTBLOrderByWithRelationInput = {
    cartid?: SortOrder
    empid?: SortOrder
    employeeid?: EmployeeTBLOrderByWithRelationInput
    CartItems?: CartItemsTBLOrderByRelationAggregateInput
  }

  export type CartTBLWhereUniqueInput = Prisma.AtLeast<{
    cartid?: number
    AND?: CartTBLWhereInput | CartTBLWhereInput[]
    OR?: CartTBLWhereInput[]
    NOT?: CartTBLWhereInput | CartTBLWhereInput[]
    empid?: IntFilter<"CartTBL"> | number
    employeeid?: XOR<EmployeeTBLRelationFilter, EmployeeTBLWhereInput>
    CartItems?: CartItemsTBLListRelationFilter
  }, "cartid" | "cartid">

  export type CartTBLOrderByWithAggregationInput = {
    cartid?: SortOrder
    empid?: SortOrder
    _count?: CartTBLCountOrderByAggregateInput
    _avg?: CartTBLAvgOrderByAggregateInput
    _max?: CartTBLMaxOrderByAggregateInput
    _min?: CartTBLMinOrderByAggregateInput
    _sum?: CartTBLSumOrderByAggregateInput
  }

  export type CartTBLScalarWhereWithAggregatesInput = {
    AND?: CartTBLScalarWhereWithAggregatesInput | CartTBLScalarWhereWithAggregatesInput[]
    OR?: CartTBLScalarWhereWithAggregatesInput[]
    NOT?: CartTBLScalarWhereWithAggregatesInput | CartTBLScalarWhereWithAggregatesInput[]
    cartid?: IntWithAggregatesFilter<"CartTBL"> | number
    empid?: IntWithAggregatesFilter<"CartTBL"> | number
  }

  export type CartItemsTBLWhereInput = {
    AND?: CartItemsTBLWhereInput | CartItemsTBLWhereInput[]
    OR?: CartItemsTBLWhereInput[]
    NOT?: CartItemsTBLWhereInput | CartItemsTBLWhereInput[]
    cartitemid?: IntFilter<"CartItemsTBL"> | number
    quanity?: IntFilter<"CartItemsTBL"> | number
    cartid?: IntFilter<"CartItemsTBL"> | number
    itemsize?: StringFilter<"CartItemsTBL"> | string
    notes?: StringNullableFilter<"CartItemsTBL"> | string | null
    itemid?: IntFilter<"CartItemsTBL"> | number
    carttid?: XOR<CartTBLNullableRelationFilter, CartTBLWhereInput> | null
    itemids?: XOR<ItemsTBLRelationFilter, ItemsTBLWhereInput>
  }

  export type CartItemsTBLOrderByWithRelationInput = {
    cartitemid?: SortOrder
    quanity?: SortOrder
    cartid?: SortOrder
    itemsize?: SortOrder
    notes?: SortOrderInput | SortOrder
    itemid?: SortOrder
    carttid?: CartTBLOrderByWithRelationInput
    itemids?: ItemsTBLOrderByWithRelationInput
  }

  export type CartItemsTBLWhereUniqueInput = Prisma.AtLeast<{
    cartitemid?: number
    itemsize?: string
    AND?: CartItemsTBLWhereInput | CartItemsTBLWhereInput[]
    OR?: CartItemsTBLWhereInput[]
    NOT?: CartItemsTBLWhereInput | CartItemsTBLWhereInput[]
    quanity?: IntFilter<"CartItemsTBL"> | number
    cartid?: IntFilter<"CartItemsTBL"> | number
    notes?: StringNullableFilter<"CartItemsTBL"> | string | null
    itemid?: IntFilter<"CartItemsTBL"> | number
    carttid?: XOR<CartTBLNullableRelationFilter, CartTBLWhereInput> | null
    itemids?: XOR<ItemsTBLRelationFilter, ItemsTBLWhereInput>
  }, "cartitemid" | "cartitemid" | "itemsize">

  export type CartItemsTBLOrderByWithAggregationInput = {
    cartitemid?: SortOrder
    quanity?: SortOrder
    cartid?: SortOrder
    itemsize?: SortOrder
    notes?: SortOrderInput | SortOrder
    itemid?: SortOrder
    _count?: CartItemsTBLCountOrderByAggregateInput
    _avg?: CartItemsTBLAvgOrderByAggregateInput
    _max?: CartItemsTBLMaxOrderByAggregateInput
    _min?: CartItemsTBLMinOrderByAggregateInput
    _sum?: CartItemsTBLSumOrderByAggregateInput
  }

  export type CartItemsTBLScalarWhereWithAggregatesInput = {
    AND?: CartItemsTBLScalarWhereWithAggregatesInput | CartItemsTBLScalarWhereWithAggregatesInput[]
    OR?: CartItemsTBLScalarWhereWithAggregatesInput[]
    NOT?: CartItemsTBLScalarWhereWithAggregatesInput | CartItemsTBLScalarWhereWithAggregatesInput[]
    cartitemid?: IntWithAggregatesFilter<"CartItemsTBL"> | number
    quanity?: IntWithAggregatesFilter<"CartItemsTBL"> | number
    cartid?: IntWithAggregatesFilter<"CartItemsTBL"> | number
    itemsize?: StringWithAggregatesFilter<"CartItemsTBL"> | string
    notes?: StringNullableWithAggregatesFilter<"CartItemsTBL"> | string | null
    itemid?: IntWithAggregatesFilter<"CartItemsTBL"> | number
  }

  export type TokensTBLCreateInput = {
    refreshtoken: string
    reftoken: UsersTBLCreateNestedOneWithoutTokensInput
  }

  export type TokensTBLUncheckedCreateInput = {
    tokenid?: number
    refreshtoken: string
    userid: number
  }

  export type TokensTBLUpdateInput = {
    refreshtoken?: StringFieldUpdateOperationsInput | string
    reftoken?: UsersTBLUpdateOneRequiredWithoutTokensNestedInput
  }

  export type TokensTBLUncheckedUpdateInput = {
    tokenid?: IntFieldUpdateOperationsInput | number
    refreshtoken?: StringFieldUpdateOperationsInput | string
    userid?: IntFieldUpdateOperationsInput | number
  }

  export type TokensTBLCreateManyInput = {
    tokenid?: number
    refreshtoken: string
    userid: number
  }

  export type TokensTBLUpdateManyMutationInput = {
    refreshtoken?: StringFieldUpdateOperationsInput | string
  }

  export type TokensTBLUncheckedUpdateManyInput = {
    tokenid?: IntFieldUpdateOperationsInput | number
    refreshtoken?: StringFieldUpdateOperationsInput | string
    userid?: IntFieldUpdateOperationsInput | number
  }

  export type BlacklistedTokenCreateInput = {
    token: string
    createdat?: Date | string
  }

  export type BlacklistedTokenUncheckedCreateInput = {
    id?: number
    token: string
    createdat?: Date | string
  }

  export type BlacklistedTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistedTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistedTokenCreateManyInput = {
    id?: number
    token: string
    createdat?: Date | string
  }

  export type BlacklistedTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistedTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersTBLCreateInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    role: string
    Employee?: EmployeeTBLCreateNestedManyWithoutEmpInput
    Items?: ItemsTBLCreateNestedManyWithoutCreatorInput
    Tokens?: TokensTBLCreateNestedManyWithoutReftokenInput
    Officeboy?: OfficeBoyTBLCreateNestedManyWithoutOfficeboyInput
  }

  export type UsersTBLUncheckedCreateInput = {
    userid?: number
    firstname: string
    lastname: string
    email: string
    password: string
    role: string
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutEmpInput
    Items?: ItemsTBLUncheckedCreateNestedManyWithoutCreatorInput
    Tokens?: TokensTBLUncheckedCreateNestedManyWithoutReftokenInput
    Officeboy?: OfficeBoyTBLUncheckedCreateNestedManyWithoutOfficeboyInput
  }

  export type UsersTBLUpdateInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUpdateManyWithoutEmpNestedInput
    Items?: ItemsTBLUpdateManyWithoutCreatorNestedInput
    Tokens?: TokensTBLUpdateManyWithoutReftokenNestedInput
    Officeboy?: OfficeBoyTBLUpdateManyWithoutOfficeboyNestedInput
  }

  export type UsersTBLUncheckedUpdateInput = {
    userid?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutEmpNestedInput
    Items?: ItemsTBLUncheckedUpdateManyWithoutCreatorNestedInput
    Tokens?: TokensTBLUncheckedUpdateManyWithoutReftokenNestedInput
    Officeboy?: OfficeBoyTBLUncheckedUpdateManyWithoutOfficeboyNestedInput
  }

  export type UsersTBLCreateManyInput = {
    userid?: number
    firstname: string
    lastname: string
    email: string
    password: string
    role: string
  }

  export type UsersTBLUpdateManyMutationInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UsersTBLUncheckedUpdateManyInput = {
    userid?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeTBLCreateInput = {
    emp?: UsersTBLCreateNestedOneWithoutEmployeeInput
    romid: RoomTBLCreateNestedOneWithoutEmployeeInput
    offid: OfficeTBLCreateNestedOneWithoutEmployeeInput
    sitid: SiteTBLCreateNestedOneWithoutEmployeeInput
    bulidingref: BuildingTBLCreateNestedOneWithoutEmployeeInput
    departmentref: DepartmentTBLCreateNestedOneWithoutEmployeeInput
    Cart?: CartTBLCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLUncheckedCreateInput = {
    empid?: number
    roomid: number
    officeid: number
    siteid: number
    buildingid: number
    departmentid: number
    Cart?: CartTBLUncheckedCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLUncheckedCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLUpdateInput = {
    emp?: UsersTBLUpdateOneRequiredWithoutEmployeeNestedInput
    romid?: RoomTBLUpdateOneRequiredWithoutEmployeeNestedInput
    offid?: OfficeTBLUpdateOneRequiredWithoutEmployeeNestedInput
    sitid?: SiteTBLUpdateOneRequiredWithoutEmployeeNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutEmployeeNestedInput
    departmentref?: DepartmentTBLUpdateOneRequiredWithoutEmployeeNestedInput
    Cart?: CartTBLUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateInput = {
    empid?: IntFieldUpdateOperationsInput | number
    roomid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
    Cart?: CartTBLUncheckedUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUncheckedUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLCreateManyInput = {
    empid?: number
    roomid: number
    officeid: number
    siteid: number
    buildingid: number
    departmentid: number
  }

  export type EmployeeTBLUpdateManyMutationInput = {

  }

  export type EmployeeTBLUncheckedUpdateManyInput = {
    empid?: IntFieldUpdateOperationsInput | number
    roomid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
  }

  export type OfficeBoyTBLCreateInput = {
    officeboy?: UsersTBLCreateNestedOneWithoutOfficeboyInput
    offid: OfficeTBLCreateNestedOneWithoutOfficeboyInput
    siteref: SiteTBLCreateNestedOneWithoutOfficeboyInput
  }

  export type OfficeBoyTBLUncheckedCreateInput = {
    officeboyid?: number
    officeid: number
    siteid: number
  }

  export type OfficeBoyTBLUpdateInput = {
    officeboy?: UsersTBLUpdateOneRequiredWithoutOfficeboyNestedInput
    offid?: OfficeTBLUpdateOneRequiredWithoutOfficeboyNestedInput
    siteref?: SiteTBLUpdateOneRequiredWithoutOfficeboyNestedInput
  }

  export type OfficeBoyTBLUncheckedUpdateInput = {
    officeboyid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
  }

  export type OfficeBoyTBLCreateManyInput = {
    officeboyid?: number
    officeid: number
    siteid: number
  }

  export type OfficeBoyTBLUpdateManyMutationInput = {

  }

  export type OfficeBoyTBLUncheckedUpdateManyInput = {
    officeboyid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
  }

  export type SiteTBLCreateInput = {
    sitename: string
    Employee?: EmployeeTBLCreateNestedManyWithoutSitidInput
    Building?: BuildingTBLCreateNestedManyWithoutSiterefInput
    Officeboy?: OfficeBoyTBLCreateNestedManyWithoutSiterefInput
  }

  export type SiteTBLUncheckedCreateInput = {
    siteid?: number
    sitename: string
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutSitidInput
    Building?: BuildingTBLUncheckedCreateNestedManyWithoutSiterefInput
    Officeboy?: OfficeBoyTBLUncheckedCreateNestedManyWithoutSiterefInput
  }

  export type SiteTBLUpdateInput = {
    sitename?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUpdateManyWithoutSitidNestedInput
    Building?: BuildingTBLUpdateManyWithoutSiterefNestedInput
    Officeboy?: OfficeBoyTBLUpdateManyWithoutSiterefNestedInput
  }

  export type SiteTBLUncheckedUpdateInput = {
    siteid?: IntFieldUpdateOperationsInput | number
    sitename?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutSitidNestedInput
    Building?: BuildingTBLUncheckedUpdateManyWithoutSiterefNestedInput
    Officeboy?: OfficeBoyTBLUncheckedUpdateManyWithoutSiterefNestedInput
  }

  export type SiteTBLCreateManyInput = {
    siteid?: number
    sitename: string
  }

  export type SiteTBLUpdateManyMutationInput = {
    sitename?: StringFieldUpdateOperationsInput | string
  }

  export type SiteTBLUncheckedUpdateManyInput = {
    siteid?: IntFieldUpdateOperationsInput | number
    sitename?: StringFieldUpdateOperationsInput | string
  }

  export type BuildingTBLCreateInput = {
    buildingname: string
    siteref: SiteTBLCreateNestedOneWithoutBuildingInput
    Department?: DepartmentTBLCreateNestedManyWithoutBulidingrefInput
    Office?: OfficeTBLCreateNestedManyWithoutBulidingrefInput
    Employee?: EmployeeTBLCreateNestedManyWithoutBulidingrefInput
  }

  export type BuildingTBLUncheckedCreateInput = {
    buildingid?: number
    buildingname: string
    siteid: number
    Department?: DepartmentTBLUncheckedCreateNestedManyWithoutBulidingrefInput
    Office?: OfficeTBLUncheckedCreateNestedManyWithoutBulidingrefInput
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutBulidingrefInput
  }

  export type BuildingTBLUpdateInput = {
    buildingname?: StringFieldUpdateOperationsInput | string
    siteref?: SiteTBLUpdateOneRequiredWithoutBuildingNestedInput
    Department?: DepartmentTBLUpdateManyWithoutBulidingrefNestedInput
    Office?: OfficeTBLUpdateManyWithoutBulidingrefNestedInput
    Employee?: EmployeeTBLUpdateManyWithoutBulidingrefNestedInput
  }

  export type BuildingTBLUncheckedUpdateInput = {
    buildingid?: IntFieldUpdateOperationsInput | number
    buildingname?: StringFieldUpdateOperationsInput | string
    siteid?: IntFieldUpdateOperationsInput | number
    Department?: DepartmentTBLUncheckedUpdateManyWithoutBulidingrefNestedInput
    Office?: OfficeTBLUncheckedUpdateManyWithoutBulidingrefNestedInput
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutBulidingrefNestedInput
  }

  export type BuildingTBLCreateManyInput = {
    buildingid?: number
    buildingname: string
    siteid: number
  }

  export type BuildingTBLUpdateManyMutationInput = {
    buildingname?: StringFieldUpdateOperationsInput | string
  }

  export type BuildingTBLUncheckedUpdateManyInput = {
    buildingid?: IntFieldUpdateOperationsInput | number
    buildingname?: StringFieldUpdateOperationsInput | string
    siteid?: IntFieldUpdateOperationsInput | number
  }

  export type OfficeTBLCreateInput = {
    officeno: number
    Employee?: EmployeeTBLCreateNestedManyWithoutOffidInput
    Officeboy?: OfficeBoyTBLCreateNestedManyWithoutOffidInput
    bulidingref: BuildingTBLCreateNestedOneWithoutOfficeInput
    Room?: RoomTBLCreateNestedManyWithoutOfficerefInput
  }

  export type OfficeTBLUncheckedCreateInput = {
    officeid?: number
    officeno: number
    buildingid: number
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutOffidInput
    Officeboy?: OfficeBoyTBLUncheckedCreateNestedManyWithoutOffidInput
    Room?: RoomTBLUncheckedCreateNestedManyWithoutOfficerefInput
  }

  export type OfficeTBLUpdateInput = {
    officeno?: IntFieldUpdateOperationsInput | number
    Employee?: EmployeeTBLUpdateManyWithoutOffidNestedInput
    Officeboy?: OfficeBoyTBLUpdateManyWithoutOffidNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutOfficeNestedInput
    Room?: RoomTBLUpdateManyWithoutOfficerefNestedInput
  }

  export type OfficeTBLUncheckedUpdateInput = {
    officeid?: IntFieldUpdateOperationsInput | number
    officeno?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutOffidNestedInput
    Officeboy?: OfficeBoyTBLUncheckedUpdateManyWithoutOffidNestedInput
    Room?: RoomTBLUncheckedUpdateManyWithoutOfficerefNestedInput
  }

  export type OfficeTBLCreateManyInput = {
    officeid?: number
    officeno: number
    buildingid: number
  }

  export type OfficeTBLUpdateManyMutationInput = {
    officeno?: IntFieldUpdateOperationsInput | number
  }

  export type OfficeTBLUncheckedUpdateManyInput = {
    officeid?: IntFieldUpdateOperationsInput | number
    officeno?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
  }

  export type DepartmentTBLCreateInput = {
    departmentname: string
    Room?: RoomTBLCreateNestedManyWithoutRoomdeprefInput
    Employee?: EmployeeTBLCreateNestedManyWithoutDepartmentrefInput
    bulidingref: BuildingTBLCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentTBLUncheckedCreateInput = {
    departmentid?: number
    departmentname: string
    buildingid: number
    Room?: RoomTBLUncheckedCreateNestedManyWithoutRoomdeprefInput
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutDepartmentrefInput
  }

  export type DepartmentTBLUpdateInput = {
    departmentname?: StringFieldUpdateOperationsInput | string
    Room?: RoomTBLUpdateManyWithoutRoomdeprefNestedInput
    Employee?: EmployeeTBLUpdateManyWithoutDepartmentrefNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutDepartmentNestedInput
  }

  export type DepartmentTBLUncheckedUpdateInput = {
    departmentid?: IntFieldUpdateOperationsInput | number
    departmentname?: StringFieldUpdateOperationsInput | string
    buildingid?: IntFieldUpdateOperationsInput | number
    Room?: RoomTBLUncheckedUpdateManyWithoutRoomdeprefNestedInput
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutDepartmentrefNestedInput
  }

  export type DepartmentTBLCreateManyInput = {
    departmentid?: number
    departmentname: string
    buildingid: number
  }

  export type DepartmentTBLUpdateManyMutationInput = {
    departmentname?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentTBLUncheckedUpdateManyInput = {
    departmentid?: IntFieldUpdateOperationsInput | number
    departmentname?: StringFieldUpdateOperationsInput | string
    buildingid?: IntFieldUpdateOperationsInput | number
  }

  export type RoomTBLCreateInput = {
    roomno: number
    roomname: string
    officeref: OfficeTBLCreateNestedOneWithoutRoomInput
    roomdepref: DepartmentTBLCreateNestedOneWithoutRoomInput
    Employee?: EmployeeTBLCreateNestedManyWithoutRomidInput
  }

  export type RoomTBLUncheckedCreateInput = {
    roomid?: number
    roomno: number
    roomname: string
    officeid: number
    departmentid: number
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutRomidInput
  }

  export type RoomTBLUpdateInput = {
    roomno?: IntFieldUpdateOperationsInput | number
    roomname?: StringFieldUpdateOperationsInput | string
    officeref?: OfficeTBLUpdateOneRequiredWithoutRoomNestedInput
    roomdepref?: DepartmentTBLUpdateOneRequiredWithoutRoomNestedInput
    Employee?: EmployeeTBLUpdateManyWithoutRomidNestedInput
  }

  export type RoomTBLUncheckedUpdateInput = {
    roomid?: IntFieldUpdateOperationsInput | number
    roomno?: IntFieldUpdateOperationsInput | number
    roomname?: StringFieldUpdateOperationsInput | string
    officeid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutRomidNestedInput
  }

  export type RoomTBLCreateManyInput = {
    roomid?: number
    roomno: number
    roomname: string
    officeid: number
    departmentid: number
  }

  export type RoomTBLUpdateManyMutationInput = {
    roomno?: IntFieldUpdateOperationsInput | number
    roomname?: StringFieldUpdateOperationsInput | string
  }

  export type RoomTBLUncheckedUpdateManyInput = {
    roomid?: IntFieldUpdateOperationsInput | number
    roomno?: IntFieldUpdateOperationsInput | number
    roomname?: StringFieldUpdateOperationsInput | string
    officeid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
  }

  export type CategoriesTblCreateInput = {
    categoryname: string
    Item?: ItemsTBLCreateNestedManyWithoutCatidInput
  }

  export type CategoriesTblUncheckedCreateInput = {
    categoryid?: number
    categoryname: string
    Item?: ItemsTBLUncheckedCreateNestedManyWithoutCatidInput
  }

  export type CategoriesTblUpdateInput = {
    categoryname?: StringFieldUpdateOperationsInput | string
    Item?: ItemsTBLUpdateManyWithoutCatidNestedInput
  }

  export type CategoriesTblUncheckedUpdateInput = {
    categoryid?: IntFieldUpdateOperationsInput | number
    categoryname?: StringFieldUpdateOperationsInput | string
    Item?: ItemsTBLUncheckedUpdateManyWithoutCatidNestedInput
  }

  export type CategoriesTblCreateManyInput = {
    categoryid?: number
    categoryname: string
  }

  export type CategoriesTblUpdateManyMutationInput = {
    categoryname?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesTblUncheckedUpdateManyInput = {
    categoryid?: IntFieldUpdateOperationsInput | number
    categoryname?: StringFieldUpdateOperationsInput | string
  }

  export type ItemsTBLCreateInput = {
    itemname: string
    itemimagurl: string
    itemidescription: string
    creator: UsersTBLCreateNestedOneWithoutItemsInput
    catid: CategoriesTblCreateNestedOneWithoutItemInput
    CartItems?: CartItemsTBLCreateNestedManyWithoutItemidsInput
  }

  export type ItemsTBLUncheckedCreateInput = {
    userid: number
    itemid?: number
    categoryid: number
    itemname: string
    itemimagurl: string
    itemidescription: string
    CartItems?: CartItemsTBLUncheckedCreateNestedManyWithoutItemidsInput
  }

  export type ItemsTBLUpdateInput = {
    itemname?: StringFieldUpdateOperationsInput | string
    itemimagurl?: StringFieldUpdateOperationsInput | string
    itemidescription?: StringFieldUpdateOperationsInput | string
    creator?: UsersTBLUpdateOneRequiredWithoutItemsNestedInput
    catid?: CategoriesTblUpdateOneRequiredWithoutItemNestedInput
    CartItems?: CartItemsTBLUpdateManyWithoutItemidsNestedInput
  }

  export type ItemsTBLUncheckedUpdateInput = {
    userid?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    categoryid?: IntFieldUpdateOperationsInput | number
    itemname?: StringFieldUpdateOperationsInput | string
    itemimagurl?: StringFieldUpdateOperationsInput | string
    itemidescription?: StringFieldUpdateOperationsInput | string
    CartItems?: CartItemsTBLUncheckedUpdateManyWithoutItemidsNestedInput
  }

  export type ItemsTBLCreateManyInput = {
    userid: number
    itemid?: number
    categoryid: number
    itemname: string
    itemimagurl: string
    itemidescription: string
  }

  export type ItemsTBLUpdateManyMutationInput = {
    itemname?: StringFieldUpdateOperationsInput | string
    itemimagurl?: StringFieldUpdateOperationsInput | string
    itemidescription?: StringFieldUpdateOperationsInput | string
  }

  export type ItemsTBLUncheckedUpdateManyInput = {
    userid?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    categoryid?: IntFieldUpdateOperationsInput | number
    itemname?: StringFieldUpdateOperationsInput | string
    itemimagurl?: StringFieldUpdateOperationsInput | string
    itemidescription?: StringFieldUpdateOperationsInput | string
  }

  export type OrdersTBLCreateInput = {
    empref: EmployeeTBLCreateNestedOneWithoutOrdersTBLInput
    orderItems?: OrderItemsTBLCreateNestedManyWithoutOrdersidInput
  }

  export type OrdersTBLUncheckedCreateInput = {
    orderid?: number
    empid: number
    orderItems?: OrderItemsTBLUncheckedCreateNestedManyWithoutOrdersidInput
  }

  export type OrdersTBLUpdateInput = {
    empref?: EmployeeTBLUpdateOneRequiredWithoutOrdersTBLNestedInput
    orderItems?: OrderItemsTBLUpdateManyWithoutOrdersidNestedInput
  }

  export type OrdersTBLUncheckedUpdateInput = {
    orderid?: IntFieldUpdateOperationsInput | number
    empid?: IntFieldUpdateOperationsInput | number
    orderItems?: OrderItemsTBLUncheckedUpdateManyWithoutOrdersidNestedInput
  }

  export type OrdersTBLCreateManyInput = {
    orderid?: number
    empid: number
  }

  export type OrdersTBLUpdateManyMutationInput = {

  }

  export type OrdersTBLUncheckedUpdateManyInput = {
    orderid?: IntFieldUpdateOperationsInput | number
    empid?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemsTBLCreateInput = {
    itemname: string
    itemquantity: number
    itemsize: string
    ordersid: OrdersTBLCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemsTBLUncheckedCreateInput = {
    orderitemid?: number
    itemname: string
    itemquantity: number
    itemsize: string
    orderid: number
  }

  export type OrderItemsTBLUpdateInput = {
    itemname?: StringFieldUpdateOperationsInput | string
    itemquantity?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
    ordersid?: OrdersTBLUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemsTBLUncheckedUpdateInput = {
    orderitemid?: IntFieldUpdateOperationsInput | number
    itemname?: StringFieldUpdateOperationsInput | string
    itemquantity?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
    orderid?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemsTBLCreateManyInput = {
    orderitemid?: number
    itemname: string
    itemquantity: number
    itemsize: string
    orderid: number
  }

  export type OrderItemsTBLUpdateManyMutationInput = {
    itemname?: StringFieldUpdateOperationsInput | string
    itemquantity?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemsTBLUncheckedUpdateManyInput = {
    orderitemid?: IntFieldUpdateOperationsInput | number
    itemname?: StringFieldUpdateOperationsInput | string
    itemquantity?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
    orderid?: IntFieldUpdateOperationsInput | number
  }

  export type CartTBLCreateInput = {
    employeeid: EmployeeTBLCreateNestedOneWithoutCartInput
    CartItems?: CartItemsTBLCreateNestedManyWithoutCarttidInput
  }

  export type CartTBLUncheckedCreateInput = {
    cartid?: number
    empid: number
    CartItems?: CartItemsTBLUncheckedCreateNestedManyWithoutCarttidInput
  }

  export type CartTBLUpdateInput = {
    employeeid?: EmployeeTBLUpdateOneRequiredWithoutCartNestedInput
    CartItems?: CartItemsTBLUpdateManyWithoutCarttidNestedInput
  }

  export type CartTBLUncheckedUpdateInput = {
    cartid?: IntFieldUpdateOperationsInput | number
    empid?: IntFieldUpdateOperationsInput | number
    CartItems?: CartItemsTBLUncheckedUpdateManyWithoutCarttidNestedInput
  }

  export type CartTBLCreateManyInput = {
    cartid?: number
    empid: number
  }

  export type CartTBLUpdateManyMutationInput = {

  }

  export type CartTBLUncheckedUpdateManyInput = {
    cartid?: IntFieldUpdateOperationsInput | number
    empid?: IntFieldUpdateOperationsInput | number
  }

  export type CartItemsTBLCreateInput = {
    quanity: number
    itemsize: string
    notes?: string | null
    carttid?: CartTBLCreateNestedOneWithoutCartItemsInput
    itemids: ItemsTBLCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemsTBLUncheckedCreateInput = {
    cartitemid?: number
    quanity: number
    cartid: number
    itemsize: string
    notes?: string | null
    itemid: number
  }

  export type CartItemsTBLUpdateInput = {
    quanity?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    carttid?: CartTBLUpdateOneWithoutCartItemsNestedInput
    itemids?: ItemsTBLUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemsTBLUncheckedUpdateInput = {
    cartitemid?: IntFieldUpdateOperationsInput | number
    quanity?: IntFieldUpdateOperationsInput | number
    cartid?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    itemid?: IntFieldUpdateOperationsInput | number
  }

  export type CartItemsTBLCreateManyInput = {
    cartitemid?: number
    quanity: number
    cartid: number
    itemsize: string
    notes?: string | null
    itemid: number
  }

  export type CartItemsTBLUpdateManyMutationInput = {
    quanity?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemsTBLUncheckedUpdateManyInput = {
    cartitemid?: IntFieldUpdateOperationsInput | number
    quanity?: IntFieldUpdateOperationsInput | number
    cartid?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    itemid?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UsersTBLRelationFilter = {
    is?: UsersTBLWhereInput
    isNot?: UsersTBLWhereInput
  }

  export type TokensTBLCountOrderByAggregateInput = {
    tokenid?: SortOrder
    refreshtoken?: SortOrder
    userid?: SortOrder
  }

  export type TokensTBLAvgOrderByAggregateInput = {
    tokenid?: SortOrder
    userid?: SortOrder
  }

  export type TokensTBLMaxOrderByAggregateInput = {
    tokenid?: SortOrder
    refreshtoken?: SortOrder
    userid?: SortOrder
  }

  export type TokensTBLMinOrderByAggregateInput = {
    tokenid?: SortOrder
    refreshtoken?: SortOrder
    userid?: SortOrder
  }

  export type TokensTBLSumOrderByAggregateInput = {
    tokenid?: SortOrder
    userid?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BlacklistedTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdat?: SortOrder
  }

  export type BlacklistedTokenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BlacklistedTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdat?: SortOrder
  }

  export type BlacklistedTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdat?: SortOrder
  }

  export type BlacklistedTokenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EmployeeTBLListRelationFilter = {
    every?: EmployeeTBLWhereInput
    some?: EmployeeTBLWhereInput
    none?: EmployeeTBLWhereInput
  }

  export type ItemsTBLListRelationFilter = {
    every?: ItemsTBLWhereInput
    some?: ItemsTBLWhereInput
    none?: ItemsTBLWhereInput
  }

  export type TokensTBLListRelationFilter = {
    every?: TokensTBLWhereInput
    some?: TokensTBLWhereInput
    none?: TokensTBLWhereInput
  }

  export type OfficeBoyTBLListRelationFilter = {
    every?: OfficeBoyTBLWhereInput
    some?: OfficeBoyTBLWhereInput
    none?: OfficeBoyTBLWhereInput
  }

  export type EmployeeTBLOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemsTBLOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokensTBLOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfficeBoyTBLOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersTBLCountOrderByAggregateInput = {
    userid?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UsersTBLAvgOrderByAggregateInput = {
    userid?: SortOrder
  }

  export type UsersTBLMaxOrderByAggregateInput = {
    userid?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UsersTBLMinOrderByAggregateInput = {
    userid?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UsersTBLSumOrderByAggregateInput = {
    userid?: SortOrder
  }

  export type RoomTBLRelationFilter = {
    is?: RoomTBLWhereInput
    isNot?: RoomTBLWhereInput
  }

  export type OfficeTBLRelationFilter = {
    is?: OfficeTBLWhereInput
    isNot?: OfficeTBLWhereInput
  }

  export type SiteTBLRelationFilter = {
    is?: SiteTBLWhereInput
    isNot?: SiteTBLWhereInput
  }

  export type BuildingTBLRelationFilter = {
    is?: BuildingTBLWhereInput
    isNot?: BuildingTBLWhereInput
  }

  export type DepartmentTBLRelationFilter = {
    is?: DepartmentTBLWhereInput
    isNot?: DepartmentTBLWhereInput
  }

  export type CartTBLListRelationFilter = {
    every?: CartTBLWhereInput
    some?: CartTBLWhereInput
    none?: CartTBLWhereInput
  }

  export type OrdersTBLListRelationFilter = {
    every?: OrdersTBLWhereInput
    some?: OrdersTBLWhereInput
    none?: OrdersTBLWhereInput
  }

  export type CartTBLOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdersTBLOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeTBLCountOrderByAggregateInput = {
    empid?: SortOrder
    roomid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
    buildingid?: SortOrder
    departmentid?: SortOrder
  }

  export type EmployeeTBLAvgOrderByAggregateInput = {
    empid?: SortOrder
    roomid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
    buildingid?: SortOrder
    departmentid?: SortOrder
  }

  export type EmployeeTBLMaxOrderByAggregateInput = {
    empid?: SortOrder
    roomid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
    buildingid?: SortOrder
    departmentid?: SortOrder
  }

  export type EmployeeTBLMinOrderByAggregateInput = {
    empid?: SortOrder
    roomid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
    buildingid?: SortOrder
    departmentid?: SortOrder
  }

  export type EmployeeTBLSumOrderByAggregateInput = {
    empid?: SortOrder
    roomid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
    buildingid?: SortOrder
    departmentid?: SortOrder
  }

  export type OfficeBoyTBLCountOrderByAggregateInput = {
    officeboyid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
  }

  export type OfficeBoyTBLAvgOrderByAggregateInput = {
    officeboyid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
  }

  export type OfficeBoyTBLMaxOrderByAggregateInput = {
    officeboyid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
  }

  export type OfficeBoyTBLMinOrderByAggregateInput = {
    officeboyid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
  }

  export type OfficeBoyTBLSumOrderByAggregateInput = {
    officeboyid?: SortOrder
    officeid?: SortOrder
    siteid?: SortOrder
  }

  export type BuildingTBLListRelationFilter = {
    every?: BuildingTBLWhereInput
    some?: BuildingTBLWhereInput
    none?: BuildingTBLWhereInput
  }

  export type BuildingTBLOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteTBLCountOrderByAggregateInput = {
    siteid?: SortOrder
    sitename?: SortOrder
  }

  export type SiteTBLAvgOrderByAggregateInput = {
    siteid?: SortOrder
  }

  export type SiteTBLMaxOrderByAggregateInput = {
    siteid?: SortOrder
    sitename?: SortOrder
  }

  export type SiteTBLMinOrderByAggregateInput = {
    siteid?: SortOrder
    sitename?: SortOrder
  }

  export type SiteTBLSumOrderByAggregateInput = {
    siteid?: SortOrder
  }

  export type DepartmentTBLListRelationFilter = {
    every?: DepartmentTBLWhereInput
    some?: DepartmentTBLWhereInput
    none?: DepartmentTBLWhereInput
  }

  export type OfficeTBLListRelationFilter = {
    every?: OfficeTBLWhereInput
    some?: OfficeTBLWhereInput
    none?: OfficeTBLWhereInput
  }

  export type DepartmentTBLOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfficeTBLOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildingTBLCountOrderByAggregateInput = {
    buildingid?: SortOrder
    buildingname?: SortOrder
    siteid?: SortOrder
  }

  export type BuildingTBLAvgOrderByAggregateInput = {
    buildingid?: SortOrder
    siteid?: SortOrder
  }

  export type BuildingTBLMaxOrderByAggregateInput = {
    buildingid?: SortOrder
    buildingname?: SortOrder
    siteid?: SortOrder
  }

  export type BuildingTBLMinOrderByAggregateInput = {
    buildingid?: SortOrder
    buildingname?: SortOrder
    siteid?: SortOrder
  }

  export type BuildingTBLSumOrderByAggregateInput = {
    buildingid?: SortOrder
    siteid?: SortOrder
  }

  export type RoomTBLListRelationFilter = {
    every?: RoomTBLWhereInput
    some?: RoomTBLWhereInput
    none?: RoomTBLWhereInput
  }

  export type RoomTBLOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfficeTBLCountOrderByAggregateInput = {
    officeid?: SortOrder
    officeno?: SortOrder
    buildingid?: SortOrder
  }

  export type OfficeTBLAvgOrderByAggregateInput = {
    officeid?: SortOrder
    officeno?: SortOrder
    buildingid?: SortOrder
  }

  export type OfficeTBLMaxOrderByAggregateInput = {
    officeid?: SortOrder
    officeno?: SortOrder
    buildingid?: SortOrder
  }

  export type OfficeTBLMinOrderByAggregateInput = {
    officeid?: SortOrder
    officeno?: SortOrder
    buildingid?: SortOrder
  }

  export type OfficeTBLSumOrderByAggregateInput = {
    officeid?: SortOrder
    officeno?: SortOrder
    buildingid?: SortOrder
  }

  export type DepartmentTBLCountOrderByAggregateInput = {
    departmentid?: SortOrder
    departmentname?: SortOrder
    buildingid?: SortOrder
  }

  export type DepartmentTBLAvgOrderByAggregateInput = {
    departmentid?: SortOrder
    buildingid?: SortOrder
  }

  export type DepartmentTBLMaxOrderByAggregateInput = {
    departmentid?: SortOrder
    departmentname?: SortOrder
    buildingid?: SortOrder
  }

  export type DepartmentTBLMinOrderByAggregateInput = {
    departmentid?: SortOrder
    departmentname?: SortOrder
    buildingid?: SortOrder
  }

  export type DepartmentTBLSumOrderByAggregateInput = {
    departmentid?: SortOrder
    buildingid?: SortOrder
  }

  export type RoomTBLCountOrderByAggregateInput = {
    roomid?: SortOrder
    roomno?: SortOrder
    roomname?: SortOrder
    officeid?: SortOrder
    departmentid?: SortOrder
  }

  export type RoomTBLAvgOrderByAggregateInput = {
    roomid?: SortOrder
    roomno?: SortOrder
    officeid?: SortOrder
    departmentid?: SortOrder
  }

  export type RoomTBLMaxOrderByAggregateInput = {
    roomid?: SortOrder
    roomno?: SortOrder
    roomname?: SortOrder
    officeid?: SortOrder
    departmentid?: SortOrder
  }

  export type RoomTBLMinOrderByAggregateInput = {
    roomid?: SortOrder
    roomno?: SortOrder
    roomname?: SortOrder
    officeid?: SortOrder
    departmentid?: SortOrder
  }

  export type RoomTBLSumOrderByAggregateInput = {
    roomid?: SortOrder
    roomno?: SortOrder
    officeid?: SortOrder
    departmentid?: SortOrder
  }

  export type CategoriesTblCountOrderByAggregateInput = {
    categoryid?: SortOrder
    categoryname?: SortOrder
  }

  export type CategoriesTblAvgOrderByAggregateInput = {
    categoryid?: SortOrder
  }

  export type CategoriesTblMaxOrderByAggregateInput = {
    categoryid?: SortOrder
    categoryname?: SortOrder
  }

  export type CategoriesTblMinOrderByAggregateInput = {
    categoryid?: SortOrder
    categoryname?: SortOrder
  }

  export type CategoriesTblSumOrderByAggregateInput = {
    categoryid?: SortOrder
  }

  export type CategoriesTblRelationFilter = {
    is?: CategoriesTblWhereInput
    isNot?: CategoriesTblWhereInput
  }

  export type CartItemsTBLListRelationFilter = {
    every?: CartItemsTBLWhereInput
    some?: CartItemsTBLWhereInput
    none?: CartItemsTBLWhereInput
  }

  export type CartItemsTBLOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemsTBLCountOrderByAggregateInput = {
    userid?: SortOrder
    itemid?: SortOrder
    categoryid?: SortOrder
    itemname?: SortOrder
    itemimagurl?: SortOrder
    itemidescription?: SortOrder
  }

  export type ItemsTBLAvgOrderByAggregateInput = {
    userid?: SortOrder
    itemid?: SortOrder
    categoryid?: SortOrder
  }

  export type ItemsTBLMaxOrderByAggregateInput = {
    userid?: SortOrder
    itemid?: SortOrder
    categoryid?: SortOrder
    itemname?: SortOrder
    itemimagurl?: SortOrder
    itemidescription?: SortOrder
  }

  export type ItemsTBLMinOrderByAggregateInput = {
    userid?: SortOrder
    itemid?: SortOrder
    categoryid?: SortOrder
    itemname?: SortOrder
    itemimagurl?: SortOrder
    itemidescription?: SortOrder
  }

  export type ItemsTBLSumOrderByAggregateInput = {
    userid?: SortOrder
    itemid?: SortOrder
    categoryid?: SortOrder
  }

  export type EmployeeTBLRelationFilter = {
    is?: EmployeeTBLWhereInput
    isNot?: EmployeeTBLWhereInput
  }

  export type OrderItemsTBLListRelationFilter = {
    every?: OrderItemsTBLWhereInput
    some?: OrderItemsTBLWhereInput
    none?: OrderItemsTBLWhereInput
  }

  export type OrderItemsTBLOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdersTBLCountOrderByAggregateInput = {
    orderid?: SortOrder
    empid?: SortOrder
  }

  export type OrdersTBLAvgOrderByAggregateInput = {
    orderid?: SortOrder
    empid?: SortOrder
  }

  export type OrdersTBLMaxOrderByAggregateInput = {
    orderid?: SortOrder
    empid?: SortOrder
  }

  export type OrdersTBLMinOrderByAggregateInput = {
    orderid?: SortOrder
    empid?: SortOrder
  }

  export type OrdersTBLSumOrderByAggregateInput = {
    orderid?: SortOrder
    empid?: SortOrder
  }

  export type OrdersTBLRelationFilter = {
    is?: OrdersTBLWhereInput
    isNot?: OrdersTBLWhereInput
  }

  export type OrderItemsTBLCountOrderByAggregateInput = {
    orderitemid?: SortOrder
    itemname?: SortOrder
    itemquantity?: SortOrder
    itemsize?: SortOrder
    orderid?: SortOrder
  }

  export type OrderItemsTBLAvgOrderByAggregateInput = {
    orderitemid?: SortOrder
    itemquantity?: SortOrder
    orderid?: SortOrder
  }

  export type OrderItemsTBLMaxOrderByAggregateInput = {
    orderitemid?: SortOrder
    itemname?: SortOrder
    itemquantity?: SortOrder
    itemsize?: SortOrder
    orderid?: SortOrder
  }

  export type OrderItemsTBLMinOrderByAggregateInput = {
    orderitemid?: SortOrder
    itemname?: SortOrder
    itemquantity?: SortOrder
    itemsize?: SortOrder
    orderid?: SortOrder
  }

  export type OrderItemsTBLSumOrderByAggregateInput = {
    orderitemid?: SortOrder
    itemquantity?: SortOrder
    orderid?: SortOrder
  }

  export type CartTBLCountOrderByAggregateInput = {
    cartid?: SortOrder
    empid?: SortOrder
  }

  export type CartTBLAvgOrderByAggregateInput = {
    cartid?: SortOrder
    empid?: SortOrder
  }

  export type CartTBLMaxOrderByAggregateInput = {
    cartid?: SortOrder
    empid?: SortOrder
  }

  export type CartTBLMinOrderByAggregateInput = {
    cartid?: SortOrder
    empid?: SortOrder
  }

  export type CartTBLSumOrderByAggregateInput = {
    cartid?: SortOrder
    empid?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CartTBLNullableRelationFilter = {
    is?: CartTBLWhereInput | null
    isNot?: CartTBLWhereInput | null
  }

  export type ItemsTBLRelationFilter = {
    is?: ItemsTBLWhereInput
    isNot?: ItemsTBLWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CartItemsTBLCountOrderByAggregateInput = {
    cartitemid?: SortOrder
    quanity?: SortOrder
    cartid?: SortOrder
    itemsize?: SortOrder
    notes?: SortOrder
    itemid?: SortOrder
  }

  export type CartItemsTBLAvgOrderByAggregateInput = {
    cartitemid?: SortOrder
    quanity?: SortOrder
    cartid?: SortOrder
    itemid?: SortOrder
  }

  export type CartItemsTBLMaxOrderByAggregateInput = {
    cartitemid?: SortOrder
    quanity?: SortOrder
    cartid?: SortOrder
    itemsize?: SortOrder
    notes?: SortOrder
    itemid?: SortOrder
  }

  export type CartItemsTBLMinOrderByAggregateInput = {
    cartitemid?: SortOrder
    quanity?: SortOrder
    cartid?: SortOrder
    itemsize?: SortOrder
    notes?: SortOrder
    itemid?: SortOrder
  }

  export type CartItemsTBLSumOrderByAggregateInput = {
    cartitemid?: SortOrder
    quanity?: SortOrder
    cartid?: SortOrder
    itemid?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UsersTBLCreateNestedOneWithoutTokensInput = {
    create?: XOR<UsersTBLCreateWithoutTokensInput, UsersTBLUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UsersTBLCreateOrConnectWithoutTokensInput
    connect?: UsersTBLWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UsersTBLUpdateOneRequiredWithoutTokensNestedInput = {
    create?: XOR<UsersTBLCreateWithoutTokensInput, UsersTBLUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UsersTBLCreateOrConnectWithoutTokensInput
    upsert?: UsersTBLUpsertWithoutTokensInput
    connect?: UsersTBLWhereUniqueInput
    update?: XOR<XOR<UsersTBLUpdateToOneWithWhereWithoutTokensInput, UsersTBLUpdateWithoutTokensInput>, UsersTBLUncheckedUpdateWithoutTokensInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EmployeeTBLCreateNestedManyWithoutEmpInput = {
    create?: XOR<EmployeeTBLCreateWithoutEmpInput, EmployeeTBLUncheckedCreateWithoutEmpInput> | EmployeeTBLCreateWithoutEmpInput[] | EmployeeTBLUncheckedCreateWithoutEmpInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutEmpInput | EmployeeTBLCreateOrConnectWithoutEmpInput[]
    createMany?: EmployeeTBLCreateManyEmpInputEnvelope
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
  }

  export type ItemsTBLCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ItemsTBLCreateWithoutCreatorInput, ItemsTBLUncheckedCreateWithoutCreatorInput> | ItemsTBLCreateWithoutCreatorInput[] | ItemsTBLUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ItemsTBLCreateOrConnectWithoutCreatorInput | ItemsTBLCreateOrConnectWithoutCreatorInput[]
    createMany?: ItemsTBLCreateManyCreatorInputEnvelope
    connect?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
  }

  export type TokensTBLCreateNestedManyWithoutReftokenInput = {
    create?: XOR<TokensTBLCreateWithoutReftokenInput, TokensTBLUncheckedCreateWithoutReftokenInput> | TokensTBLCreateWithoutReftokenInput[] | TokensTBLUncheckedCreateWithoutReftokenInput[]
    connectOrCreate?: TokensTBLCreateOrConnectWithoutReftokenInput | TokensTBLCreateOrConnectWithoutReftokenInput[]
    createMany?: TokensTBLCreateManyReftokenInputEnvelope
    connect?: TokensTBLWhereUniqueInput | TokensTBLWhereUniqueInput[]
  }

  export type OfficeBoyTBLCreateNestedManyWithoutOfficeboyInput = {
    create?: XOR<OfficeBoyTBLCreateWithoutOfficeboyInput, OfficeBoyTBLUncheckedCreateWithoutOfficeboyInput> | OfficeBoyTBLCreateWithoutOfficeboyInput[] | OfficeBoyTBLUncheckedCreateWithoutOfficeboyInput[]
    connectOrCreate?: OfficeBoyTBLCreateOrConnectWithoutOfficeboyInput | OfficeBoyTBLCreateOrConnectWithoutOfficeboyInput[]
    createMany?: OfficeBoyTBLCreateManyOfficeboyInputEnvelope
    connect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
  }

  export type EmployeeTBLUncheckedCreateNestedManyWithoutEmpInput = {
    create?: XOR<EmployeeTBLCreateWithoutEmpInput, EmployeeTBLUncheckedCreateWithoutEmpInput> | EmployeeTBLCreateWithoutEmpInput[] | EmployeeTBLUncheckedCreateWithoutEmpInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutEmpInput | EmployeeTBLCreateOrConnectWithoutEmpInput[]
    createMany?: EmployeeTBLCreateManyEmpInputEnvelope
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
  }

  export type ItemsTBLUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ItemsTBLCreateWithoutCreatorInput, ItemsTBLUncheckedCreateWithoutCreatorInput> | ItemsTBLCreateWithoutCreatorInput[] | ItemsTBLUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ItemsTBLCreateOrConnectWithoutCreatorInput | ItemsTBLCreateOrConnectWithoutCreatorInput[]
    createMany?: ItemsTBLCreateManyCreatorInputEnvelope
    connect?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
  }

  export type TokensTBLUncheckedCreateNestedManyWithoutReftokenInput = {
    create?: XOR<TokensTBLCreateWithoutReftokenInput, TokensTBLUncheckedCreateWithoutReftokenInput> | TokensTBLCreateWithoutReftokenInput[] | TokensTBLUncheckedCreateWithoutReftokenInput[]
    connectOrCreate?: TokensTBLCreateOrConnectWithoutReftokenInput | TokensTBLCreateOrConnectWithoutReftokenInput[]
    createMany?: TokensTBLCreateManyReftokenInputEnvelope
    connect?: TokensTBLWhereUniqueInput | TokensTBLWhereUniqueInput[]
  }

  export type OfficeBoyTBLUncheckedCreateNestedManyWithoutOfficeboyInput = {
    create?: XOR<OfficeBoyTBLCreateWithoutOfficeboyInput, OfficeBoyTBLUncheckedCreateWithoutOfficeboyInput> | OfficeBoyTBLCreateWithoutOfficeboyInput[] | OfficeBoyTBLUncheckedCreateWithoutOfficeboyInput[]
    connectOrCreate?: OfficeBoyTBLCreateOrConnectWithoutOfficeboyInput | OfficeBoyTBLCreateOrConnectWithoutOfficeboyInput[]
    createMany?: OfficeBoyTBLCreateManyOfficeboyInputEnvelope
    connect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
  }

  export type EmployeeTBLUpdateManyWithoutEmpNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutEmpInput, EmployeeTBLUncheckedCreateWithoutEmpInput> | EmployeeTBLCreateWithoutEmpInput[] | EmployeeTBLUncheckedCreateWithoutEmpInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutEmpInput | EmployeeTBLCreateOrConnectWithoutEmpInput[]
    upsert?: EmployeeTBLUpsertWithWhereUniqueWithoutEmpInput | EmployeeTBLUpsertWithWhereUniqueWithoutEmpInput[]
    createMany?: EmployeeTBLCreateManyEmpInputEnvelope
    set?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    disconnect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    delete?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    update?: EmployeeTBLUpdateWithWhereUniqueWithoutEmpInput | EmployeeTBLUpdateWithWhereUniqueWithoutEmpInput[]
    updateMany?: EmployeeTBLUpdateManyWithWhereWithoutEmpInput | EmployeeTBLUpdateManyWithWhereWithoutEmpInput[]
    deleteMany?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
  }

  export type ItemsTBLUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ItemsTBLCreateWithoutCreatorInput, ItemsTBLUncheckedCreateWithoutCreatorInput> | ItemsTBLCreateWithoutCreatorInput[] | ItemsTBLUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ItemsTBLCreateOrConnectWithoutCreatorInput | ItemsTBLCreateOrConnectWithoutCreatorInput[]
    upsert?: ItemsTBLUpsertWithWhereUniqueWithoutCreatorInput | ItemsTBLUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ItemsTBLCreateManyCreatorInputEnvelope
    set?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    disconnect?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    delete?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    connect?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    update?: ItemsTBLUpdateWithWhereUniqueWithoutCreatorInput | ItemsTBLUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ItemsTBLUpdateManyWithWhereWithoutCreatorInput | ItemsTBLUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ItemsTBLScalarWhereInput | ItemsTBLScalarWhereInput[]
  }

  export type TokensTBLUpdateManyWithoutReftokenNestedInput = {
    create?: XOR<TokensTBLCreateWithoutReftokenInput, TokensTBLUncheckedCreateWithoutReftokenInput> | TokensTBLCreateWithoutReftokenInput[] | TokensTBLUncheckedCreateWithoutReftokenInput[]
    connectOrCreate?: TokensTBLCreateOrConnectWithoutReftokenInput | TokensTBLCreateOrConnectWithoutReftokenInput[]
    upsert?: TokensTBLUpsertWithWhereUniqueWithoutReftokenInput | TokensTBLUpsertWithWhereUniqueWithoutReftokenInput[]
    createMany?: TokensTBLCreateManyReftokenInputEnvelope
    set?: TokensTBLWhereUniqueInput | TokensTBLWhereUniqueInput[]
    disconnect?: TokensTBLWhereUniqueInput | TokensTBLWhereUniqueInput[]
    delete?: TokensTBLWhereUniqueInput | TokensTBLWhereUniqueInput[]
    connect?: TokensTBLWhereUniqueInput | TokensTBLWhereUniqueInput[]
    update?: TokensTBLUpdateWithWhereUniqueWithoutReftokenInput | TokensTBLUpdateWithWhereUniqueWithoutReftokenInput[]
    updateMany?: TokensTBLUpdateManyWithWhereWithoutReftokenInput | TokensTBLUpdateManyWithWhereWithoutReftokenInput[]
    deleteMany?: TokensTBLScalarWhereInput | TokensTBLScalarWhereInput[]
  }

  export type OfficeBoyTBLUpdateManyWithoutOfficeboyNestedInput = {
    create?: XOR<OfficeBoyTBLCreateWithoutOfficeboyInput, OfficeBoyTBLUncheckedCreateWithoutOfficeboyInput> | OfficeBoyTBLCreateWithoutOfficeboyInput[] | OfficeBoyTBLUncheckedCreateWithoutOfficeboyInput[]
    connectOrCreate?: OfficeBoyTBLCreateOrConnectWithoutOfficeboyInput | OfficeBoyTBLCreateOrConnectWithoutOfficeboyInput[]
    upsert?: OfficeBoyTBLUpsertWithWhereUniqueWithoutOfficeboyInput | OfficeBoyTBLUpsertWithWhereUniqueWithoutOfficeboyInput[]
    createMany?: OfficeBoyTBLCreateManyOfficeboyInputEnvelope
    set?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    disconnect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    delete?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    connect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    update?: OfficeBoyTBLUpdateWithWhereUniqueWithoutOfficeboyInput | OfficeBoyTBLUpdateWithWhereUniqueWithoutOfficeboyInput[]
    updateMany?: OfficeBoyTBLUpdateManyWithWhereWithoutOfficeboyInput | OfficeBoyTBLUpdateManyWithWhereWithoutOfficeboyInput[]
    deleteMany?: OfficeBoyTBLScalarWhereInput | OfficeBoyTBLScalarWhereInput[]
  }

  export type EmployeeTBLUncheckedUpdateManyWithoutEmpNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutEmpInput, EmployeeTBLUncheckedCreateWithoutEmpInput> | EmployeeTBLCreateWithoutEmpInput[] | EmployeeTBLUncheckedCreateWithoutEmpInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutEmpInput | EmployeeTBLCreateOrConnectWithoutEmpInput[]
    upsert?: EmployeeTBLUpsertWithWhereUniqueWithoutEmpInput | EmployeeTBLUpsertWithWhereUniqueWithoutEmpInput[]
    createMany?: EmployeeTBLCreateManyEmpInputEnvelope
    set?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    disconnect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    delete?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    update?: EmployeeTBLUpdateWithWhereUniqueWithoutEmpInput | EmployeeTBLUpdateWithWhereUniqueWithoutEmpInput[]
    updateMany?: EmployeeTBLUpdateManyWithWhereWithoutEmpInput | EmployeeTBLUpdateManyWithWhereWithoutEmpInput[]
    deleteMany?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
  }

  export type ItemsTBLUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ItemsTBLCreateWithoutCreatorInput, ItemsTBLUncheckedCreateWithoutCreatorInput> | ItemsTBLCreateWithoutCreatorInput[] | ItemsTBLUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ItemsTBLCreateOrConnectWithoutCreatorInput | ItemsTBLCreateOrConnectWithoutCreatorInput[]
    upsert?: ItemsTBLUpsertWithWhereUniqueWithoutCreatorInput | ItemsTBLUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ItemsTBLCreateManyCreatorInputEnvelope
    set?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    disconnect?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    delete?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    connect?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    update?: ItemsTBLUpdateWithWhereUniqueWithoutCreatorInput | ItemsTBLUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ItemsTBLUpdateManyWithWhereWithoutCreatorInput | ItemsTBLUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ItemsTBLScalarWhereInput | ItemsTBLScalarWhereInput[]
  }

  export type TokensTBLUncheckedUpdateManyWithoutReftokenNestedInput = {
    create?: XOR<TokensTBLCreateWithoutReftokenInput, TokensTBLUncheckedCreateWithoutReftokenInput> | TokensTBLCreateWithoutReftokenInput[] | TokensTBLUncheckedCreateWithoutReftokenInput[]
    connectOrCreate?: TokensTBLCreateOrConnectWithoutReftokenInput | TokensTBLCreateOrConnectWithoutReftokenInput[]
    upsert?: TokensTBLUpsertWithWhereUniqueWithoutReftokenInput | TokensTBLUpsertWithWhereUniqueWithoutReftokenInput[]
    createMany?: TokensTBLCreateManyReftokenInputEnvelope
    set?: TokensTBLWhereUniqueInput | TokensTBLWhereUniqueInput[]
    disconnect?: TokensTBLWhereUniqueInput | TokensTBLWhereUniqueInput[]
    delete?: TokensTBLWhereUniqueInput | TokensTBLWhereUniqueInput[]
    connect?: TokensTBLWhereUniqueInput | TokensTBLWhereUniqueInput[]
    update?: TokensTBLUpdateWithWhereUniqueWithoutReftokenInput | TokensTBLUpdateWithWhereUniqueWithoutReftokenInput[]
    updateMany?: TokensTBLUpdateManyWithWhereWithoutReftokenInput | TokensTBLUpdateManyWithWhereWithoutReftokenInput[]
    deleteMany?: TokensTBLScalarWhereInput | TokensTBLScalarWhereInput[]
  }

  export type OfficeBoyTBLUncheckedUpdateManyWithoutOfficeboyNestedInput = {
    create?: XOR<OfficeBoyTBLCreateWithoutOfficeboyInput, OfficeBoyTBLUncheckedCreateWithoutOfficeboyInput> | OfficeBoyTBLCreateWithoutOfficeboyInput[] | OfficeBoyTBLUncheckedCreateWithoutOfficeboyInput[]
    connectOrCreate?: OfficeBoyTBLCreateOrConnectWithoutOfficeboyInput | OfficeBoyTBLCreateOrConnectWithoutOfficeboyInput[]
    upsert?: OfficeBoyTBLUpsertWithWhereUniqueWithoutOfficeboyInput | OfficeBoyTBLUpsertWithWhereUniqueWithoutOfficeboyInput[]
    createMany?: OfficeBoyTBLCreateManyOfficeboyInputEnvelope
    set?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    disconnect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    delete?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    connect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    update?: OfficeBoyTBLUpdateWithWhereUniqueWithoutOfficeboyInput | OfficeBoyTBLUpdateWithWhereUniqueWithoutOfficeboyInput[]
    updateMany?: OfficeBoyTBLUpdateManyWithWhereWithoutOfficeboyInput | OfficeBoyTBLUpdateManyWithWhereWithoutOfficeboyInput[]
    deleteMany?: OfficeBoyTBLScalarWhereInput | OfficeBoyTBLScalarWhereInput[]
  }

  export type UsersTBLCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UsersTBLCreateWithoutEmployeeInput, UsersTBLUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UsersTBLCreateOrConnectWithoutEmployeeInput
    connect?: UsersTBLWhereUniqueInput
  }

  export type RoomTBLCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<RoomTBLCreateWithoutEmployeeInput, RoomTBLUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: RoomTBLCreateOrConnectWithoutEmployeeInput
    connect?: RoomTBLWhereUniqueInput
  }

  export type OfficeTBLCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<OfficeTBLCreateWithoutEmployeeInput, OfficeTBLUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: OfficeTBLCreateOrConnectWithoutEmployeeInput
    connect?: OfficeTBLWhereUniqueInput
  }

  export type SiteTBLCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<SiteTBLCreateWithoutEmployeeInput, SiteTBLUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: SiteTBLCreateOrConnectWithoutEmployeeInput
    connect?: SiteTBLWhereUniqueInput
  }

  export type BuildingTBLCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<BuildingTBLCreateWithoutEmployeeInput, BuildingTBLUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: BuildingTBLCreateOrConnectWithoutEmployeeInput
    connect?: BuildingTBLWhereUniqueInput
  }

  export type DepartmentTBLCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<DepartmentTBLCreateWithoutEmployeeInput, DepartmentTBLUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: DepartmentTBLCreateOrConnectWithoutEmployeeInput
    connect?: DepartmentTBLWhereUniqueInput
  }

  export type CartTBLCreateNestedManyWithoutEmployeeidInput = {
    create?: XOR<CartTBLCreateWithoutEmployeeidInput, CartTBLUncheckedCreateWithoutEmployeeidInput> | CartTBLCreateWithoutEmployeeidInput[] | CartTBLUncheckedCreateWithoutEmployeeidInput[]
    connectOrCreate?: CartTBLCreateOrConnectWithoutEmployeeidInput | CartTBLCreateOrConnectWithoutEmployeeidInput[]
    createMany?: CartTBLCreateManyEmployeeidInputEnvelope
    connect?: CartTBLWhereUniqueInput | CartTBLWhereUniqueInput[]
  }

  export type OrdersTBLCreateNestedManyWithoutEmprefInput = {
    create?: XOR<OrdersTBLCreateWithoutEmprefInput, OrdersTBLUncheckedCreateWithoutEmprefInput> | OrdersTBLCreateWithoutEmprefInput[] | OrdersTBLUncheckedCreateWithoutEmprefInput[]
    connectOrCreate?: OrdersTBLCreateOrConnectWithoutEmprefInput | OrdersTBLCreateOrConnectWithoutEmprefInput[]
    createMany?: OrdersTBLCreateManyEmprefInputEnvelope
    connect?: OrdersTBLWhereUniqueInput | OrdersTBLWhereUniqueInput[]
  }

  export type CartTBLUncheckedCreateNestedManyWithoutEmployeeidInput = {
    create?: XOR<CartTBLCreateWithoutEmployeeidInput, CartTBLUncheckedCreateWithoutEmployeeidInput> | CartTBLCreateWithoutEmployeeidInput[] | CartTBLUncheckedCreateWithoutEmployeeidInput[]
    connectOrCreate?: CartTBLCreateOrConnectWithoutEmployeeidInput | CartTBLCreateOrConnectWithoutEmployeeidInput[]
    createMany?: CartTBLCreateManyEmployeeidInputEnvelope
    connect?: CartTBLWhereUniqueInput | CartTBLWhereUniqueInput[]
  }

  export type OrdersTBLUncheckedCreateNestedManyWithoutEmprefInput = {
    create?: XOR<OrdersTBLCreateWithoutEmprefInput, OrdersTBLUncheckedCreateWithoutEmprefInput> | OrdersTBLCreateWithoutEmprefInput[] | OrdersTBLUncheckedCreateWithoutEmprefInput[]
    connectOrCreate?: OrdersTBLCreateOrConnectWithoutEmprefInput | OrdersTBLCreateOrConnectWithoutEmprefInput[]
    createMany?: OrdersTBLCreateManyEmprefInputEnvelope
    connect?: OrdersTBLWhereUniqueInput | OrdersTBLWhereUniqueInput[]
  }

  export type UsersTBLUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<UsersTBLCreateWithoutEmployeeInput, UsersTBLUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UsersTBLCreateOrConnectWithoutEmployeeInput
    upsert?: UsersTBLUpsertWithoutEmployeeInput
    connect?: UsersTBLWhereUniqueInput
    update?: XOR<XOR<UsersTBLUpdateToOneWithWhereWithoutEmployeeInput, UsersTBLUpdateWithoutEmployeeInput>, UsersTBLUncheckedUpdateWithoutEmployeeInput>
  }

  export type RoomTBLUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<RoomTBLCreateWithoutEmployeeInput, RoomTBLUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: RoomTBLCreateOrConnectWithoutEmployeeInput
    upsert?: RoomTBLUpsertWithoutEmployeeInput
    connect?: RoomTBLWhereUniqueInput
    update?: XOR<XOR<RoomTBLUpdateToOneWithWhereWithoutEmployeeInput, RoomTBLUpdateWithoutEmployeeInput>, RoomTBLUncheckedUpdateWithoutEmployeeInput>
  }

  export type OfficeTBLUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<OfficeTBLCreateWithoutEmployeeInput, OfficeTBLUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: OfficeTBLCreateOrConnectWithoutEmployeeInput
    upsert?: OfficeTBLUpsertWithoutEmployeeInput
    connect?: OfficeTBLWhereUniqueInput
    update?: XOR<XOR<OfficeTBLUpdateToOneWithWhereWithoutEmployeeInput, OfficeTBLUpdateWithoutEmployeeInput>, OfficeTBLUncheckedUpdateWithoutEmployeeInput>
  }

  export type SiteTBLUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<SiteTBLCreateWithoutEmployeeInput, SiteTBLUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: SiteTBLCreateOrConnectWithoutEmployeeInput
    upsert?: SiteTBLUpsertWithoutEmployeeInput
    connect?: SiteTBLWhereUniqueInput
    update?: XOR<XOR<SiteTBLUpdateToOneWithWhereWithoutEmployeeInput, SiteTBLUpdateWithoutEmployeeInput>, SiteTBLUncheckedUpdateWithoutEmployeeInput>
  }

  export type BuildingTBLUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<BuildingTBLCreateWithoutEmployeeInput, BuildingTBLUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: BuildingTBLCreateOrConnectWithoutEmployeeInput
    upsert?: BuildingTBLUpsertWithoutEmployeeInput
    connect?: BuildingTBLWhereUniqueInput
    update?: XOR<XOR<BuildingTBLUpdateToOneWithWhereWithoutEmployeeInput, BuildingTBLUpdateWithoutEmployeeInput>, BuildingTBLUncheckedUpdateWithoutEmployeeInput>
  }

  export type DepartmentTBLUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<DepartmentTBLCreateWithoutEmployeeInput, DepartmentTBLUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: DepartmentTBLCreateOrConnectWithoutEmployeeInput
    upsert?: DepartmentTBLUpsertWithoutEmployeeInput
    connect?: DepartmentTBLWhereUniqueInput
    update?: XOR<XOR<DepartmentTBLUpdateToOneWithWhereWithoutEmployeeInput, DepartmentTBLUpdateWithoutEmployeeInput>, DepartmentTBLUncheckedUpdateWithoutEmployeeInput>
  }

  export type CartTBLUpdateManyWithoutEmployeeidNestedInput = {
    create?: XOR<CartTBLCreateWithoutEmployeeidInput, CartTBLUncheckedCreateWithoutEmployeeidInput> | CartTBLCreateWithoutEmployeeidInput[] | CartTBLUncheckedCreateWithoutEmployeeidInput[]
    connectOrCreate?: CartTBLCreateOrConnectWithoutEmployeeidInput | CartTBLCreateOrConnectWithoutEmployeeidInput[]
    upsert?: CartTBLUpsertWithWhereUniqueWithoutEmployeeidInput | CartTBLUpsertWithWhereUniqueWithoutEmployeeidInput[]
    createMany?: CartTBLCreateManyEmployeeidInputEnvelope
    set?: CartTBLWhereUniqueInput | CartTBLWhereUniqueInput[]
    disconnect?: CartTBLWhereUniqueInput | CartTBLWhereUniqueInput[]
    delete?: CartTBLWhereUniqueInput | CartTBLWhereUniqueInput[]
    connect?: CartTBLWhereUniqueInput | CartTBLWhereUniqueInput[]
    update?: CartTBLUpdateWithWhereUniqueWithoutEmployeeidInput | CartTBLUpdateWithWhereUniqueWithoutEmployeeidInput[]
    updateMany?: CartTBLUpdateManyWithWhereWithoutEmployeeidInput | CartTBLUpdateManyWithWhereWithoutEmployeeidInput[]
    deleteMany?: CartTBLScalarWhereInput | CartTBLScalarWhereInput[]
  }

  export type OrdersTBLUpdateManyWithoutEmprefNestedInput = {
    create?: XOR<OrdersTBLCreateWithoutEmprefInput, OrdersTBLUncheckedCreateWithoutEmprefInput> | OrdersTBLCreateWithoutEmprefInput[] | OrdersTBLUncheckedCreateWithoutEmprefInput[]
    connectOrCreate?: OrdersTBLCreateOrConnectWithoutEmprefInput | OrdersTBLCreateOrConnectWithoutEmprefInput[]
    upsert?: OrdersTBLUpsertWithWhereUniqueWithoutEmprefInput | OrdersTBLUpsertWithWhereUniqueWithoutEmprefInput[]
    createMany?: OrdersTBLCreateManyEmprefInputEnvelope
    set?: OrdersTBLWhereUniqueInput | OrdersTBLWhereUniqueInput[]
    disconnect?: OrdersTBLWhereUniqueInput | OrdersTBLWhereUniqueInput[]
    delete?: OrdersTBLWhereUniqueInput | OrdersTBLWhereUniqueInput[]
    connect?: OrdersTBLWhereUniqueInput | OrdersTBLWhereUniqueInput[]
    update?: OrdersTBLUpdateWithWhereUniqueWithoutEmprefInput | OrdersTBLUpdateWithWhereUniqueWithoutEmprefInput[]
    updateMany?: OrdersTBLUpdateManyWithWhereWithoutEmprefInput | OrdersTBLUpdateManyWithWhereWithoutEmprefInput[]
    deleteMany?: OrdersTBLScalarWhereInput | OrdersTBLScalarWhereInput[]
  }

  export type CartTBLUncheckedUpdateManyWithoutEmployeeidNestedInput = {
    create?: XOR<CartTBLCreateWithoutEmployeeidInput, CartTBLUncheckedCreateWithoutEmployeeidInput> | CartTBLCreateWithoutEmployeeidInput[] | CartTBLUncheckedCreateWithoutEmployeeidInput[]
    connectOrCreate?: CartTBLCreateOrConnectWithoutEmployeeidInput | CartTBLCreateOrConnectWithoutEmployeeidInput[]
    upsert?: CartTBLUpsertWithWhereUniqueWithoutEmployeeidInput | CartTBLUpsertWithWhereUniqueWithoutEmployeeidInput[]
    createMany?: CartTBLCreateManyEmployeeidInputEnvelope
    set?: CartTBLWhereUniqueInput | CartTBLWhereUniqueInput[]
    disconnect?: CartTBLWhereUniqueInput | CartTBLWhereUniqueInput[]
    delete?: CartTBLWhereUniqueInput | CartTBLWhereUniqueInput[]
    connect?: CartTBLWhereUniqueInput | CartTBLWhereUniqueInput[]
    update?: CartTBLUpdateWithWhereUniqueWithoutEmployeeidInput | CartTBLUpdateWithWhereUniqueWithoutEmployeeidInput[]
    updateMany?: CartTBLUpdateManyWithWhereWithoutEmployeeidInput | CartTBLUpdateManyWithWhereWithoutEmployeeidInput[]
    deleteMany?: CartTBLScalarWhereInput | CartTBLScalarWhereInput[]
  }

  export type OrdersTBLUncheckedUpdateManyWithoutEmprefNestedInput = {
    create?: XOR<OrdersTBLCreateWithoutEmprefInput, OrdersTBLUncheckedCreateWithoutEmprefInput> | OrdersTBLCreateWithoutEmprefInput[] | OrdersTBLUncheckedCreateWithoutEmprefInput[]
    connectOrCreate?: OrdersTBLCreateOrConnectWithoutEmprefInput | OrdersTBLCreateOrConnectWithoutEmprefInput[]
    upsert?: OrdersTBLUpsertWithWhereUniqueWithoutEmprefInput | OrdersTBLUpsertWithWhereUniqueWithoutEmprefInput[]
    createMany?: OrdersTBLCreateManyEmprefInputEnvelope
    set?: OrdersTBLWhereUniqueInput | OrdersTBLWhereUniqueInput[]
    disconnect?: OrdersTBLWhereUniqueInput | OrdersTBLWhereUniqueInput[]
    delete?: OrdersTBLWhereUniqueInput | OrdersTBLWhereUniqueInput[]
    connect?: OrdersTBLWhereUniqueInput | OrdersTBLWhereUniqueInput[]
    update?: OrdersTBLUpdateWithWhereUniqueWithoutEmprefInput | OrdersTBLUpdateWithWhereUniqueWithoutEmprefInput[]
    updateMany?: OrdersTBLUpdateManyWithWhereWithoutEmprefInput | OrdersTBLUpdateManyWithWhereWithoutEmprefInput[]
    deleteMany?: OrdersTBLScalarWhereInput | OrdersTBLScalarWhereInput[]
  }

  export type UsersTBLCreateNestedOneWithoutOfficeboyInput = {
    create?: XOR<UsersTBLCreateWithoutOfficeboyInput, UsersTBLUncheckedCreateWithoutOfficeboyInput>
    connectOrCreate?: UsersTBLCreateOrConnectWithoutOfficeboyInput
    connect?: UsersTBLWhereUniqueInput
  }

  export type OfficeTBLCreateNestedOneWithoutOfficeboyInput = {
    create?: XOR<OfficeTBLCreateWithoutOfficeboyInput, OfficeTBLUncheckedCreateWithoutOfficeboyInput>
    connectOrCreate?: OfficeTBLCreateOrConnectWithoutOfficeboyInput
    connect?: OfficeTBLWhereUniqueInput
  }

  export type SiteTBLCreateNestedOneWithoutOfficeboyInput = {
    create?: XOR<SiteTBLCreateWithoutOfficeboyInput, SiteTBLUncheckedCreateWithoutOfficeboyInput>
    connectOrCreate?: SiteTBLCreateOrConnectWithoutOfficeboyInput
    connect?: SiteTBLWhereUniqueInput
  }

  export type UsersTBLUpdateOneRequiredWithoutOfficeboyNestedInput = {
    create?: XOR<UsersTBLCreateWithoutOfficeboyInput, UsersTBLUncheckedCreateWithoutOfficeboyInput>
    connectOrCreate?: UsersTBLCreateOrConnectWithoutOfficeboyInput
    upsert?: UsersTBLUpsertWithoutOfficeboyInput
    connect?: UsersTBLWhereUniqueInput
    update?: XOR<XOR<UsersTBLUpdateToOneWithWhereWithoutOfficeboyInput, UsersTBLUpdateWithoutOfficeboyInput>, UsersTBLUncheckedUpdateWithoutOfficeboyInput>
  }

  export type OfficeTBLUpdateOneRequiredWithoutOfficeboyNestedInput = {
    create?: XOR<OfficeTBLCreateWithoutOfficeboyInput, OfficeTBLUncheckedCreateWithoutOfficeboyInput>
    connectOrCreate?: OfficeTBLCreateOrConnectWithoutOfficeboyInput
    upsert?: OfficeTBLUpsertWithoutOfficeboyInput
    connect?: OfficeTBLWhereUniqueInput
    update?: XOR<XOR<OfficeTBLUpdateToOneWithWhereWithoutOfficeboyInput, OfficeTBLUpdateWithoutOfficeboyInput>, OfficeTBLUncheckedUpdateWithoutOfficeboyInput>
  }

  export type SiteTBLUpdateOneRequiredWithoutOfficeboyNestedInput = {
    create?: XOR<SiteTBLCreateWithoutOfficeboyInput, SiteTBLUncheckedCreateWithoutOfficeboyInput>
    connectOrCreate?: SiteTBLCreateOrConnectWithoutOfficeboyInput
    upsert?: SiteTBLUpsertWithoutOfficeboyInput
    connect?: SiteTBLWhereUniqueInput
    update?: XOR<XOR<SiteTBLUpdateToOneWithWhereWithoutOfficeboyInput, SiteTBLUpdateWithoutOfficeboyInput>, SiteTBLUncheckedUpdateWithoutOfficeboyInput>
  }

  export type EmployeeTBLCreateNestedManyWithoutSitidInput = {
    create?: XOR<EmployeeTBLCreateWithoutSitidInput, EmployeeTBLUncheckedCreateWithoutSitidInput> | EmployeeTBLCreateWithoutSitidInput[] | EmployeeTBLUncheckedCreateWithoutSitidInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutSitidInput | EmployeeTBLCreateOrConnectWithoutSitidInput[]
    createMany?: EmployeeTBLCreateManySitidInputEnvelope
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
  }

  export type BuildingTBLCreateNestedManyWithoutSiterefInput = {
    create?: XOR<BuildingTBLCreateWithoutSiterefInput, BuildingTBLUncheckedCreateWithoutSiterefInput> | BuildingTBLCreateWithoutSiterefInput[] | BuildingTBLUncheckedCreateWithoutSiterefInput[]
    connectOrCreate?: BuildingTBLCreateOrConnectWithoutSiterefInput | BuildingTBLCreateOrConnectWithoutSiterefInput[]
    createMany?: BuildingTBLCreateManySiterefInputEnvelope
    connect?: BuildingTBLWhereUniqueInput | BuildingTBLWhereUniqueInput[]
  }

  export type OfficeBoyTBLCreateNestedManyWithoutSiterefInput = {
    create?: XOR<OfficeBoyTBLCreateWithoutSiterefInput, OfficeBoyTBLUncheckedCreateWithoutSiterefInput> | OfficeBoyTBLCreateWithoutSiterefInput[] | OfficeBoyTBLUncheckedCreateWithoutSiterefInput[]
    connectOrCreate?: OfficeBoyTBLCreateOrConnectWithoutSiterefInput | OfficeBoyTBLCreateOrConnectWithoutSiterefInput[]
    createMany?: OfficeBoyTBLCreateManySiterefInputEnvelope
    connect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
  }

  export type EmployeeTBLUncheckedCreateNestedManyWithoutSitidInput = {
    create?: XOR<EmployeeTBLCreateWithoutSitidInput, EmployeeTBLUncheckedCreateWithoutSitidInput> | EmployeeTBLCreateWithoutSitidInput[] | EmployeeTBLUncheckedCreateWithoutSitidInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutSitidInput | EmployeeTBLCreateOrConnectWithoutSitidInput[]
    createMany?: EmployeeTBLCreateManySitidInputEnvelope
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
  }

  export type BuildingTBLUncheckedCreateNestedManyWithoutSiterefInput = {
    create?: XOR<BuildingTBLCreateWithoutSiterefInput, BuildingTBLUncheckedCreateWithoutSiterefInput> | BuildingTBLCreateWithoutSiterefInput[] | BuildingTBLUncheckedCreateWithoutSiterefInput[]
    connectOrCreate?: BuildingTBLCreateOrConnectWithoutSiterefInput | BuildingTBLCreateOrConnectWithoutSiterefInput[]
    createMany?: BuildingTBLCreateManySiterefInputEnvelope
    connect?: BuildingTBLWhereUniqueInput | BuildingTBLWhereUniqueInput[]
  }

  export type OfficeBoyTBLUncheckedCreateNestedManyWithoutSiterefInput = {
    create?: XOR<OfficeBoyTBLCreateWithoutSiterefInput, OfficeBoyTBLUncheckedCreateWithoutSiterefInput> | OfficeBoyTBLCreateWithoutSiterefInput[] | OfficeBoyTBLUncheckedCreateWithoutSiterefInput[]
    connectOrCreate?: OfficeBoyTBLCreateOrConnectWithoutSiterefInput | OfficeBoyTBLCreateOrConnectWithoutSiterefInput[]
    createMany?: OfficeBoyTBLCreateManySiterefInputEnvelope
    connect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
  }

  export type EmployeeTBLUpdateManyWithoutSitidNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutSitidInput, EmployeeTBLUncheckedCreateWithoutSitidInput> | EmployeeTBLCreateWithoutSitidInput[] | EmployeeTBLUncheckedCreateWithoutSitidInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutSitidInput | EmployeeTBLCreateOrConnectWithoutSitidInput[]
    upsert?: EmployeeTBLUpsertWithWhereUniqueWithoutSitidInput | EmployeeTBLUpsertWithWhereUniqueWithoutSitidInput[]
    createMany?: EmployeeTBLCreateManySitidInputEnvelope
    set?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    disconnect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    delete?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    update?: EmployeeTBLUpdateWithWhereUniqueWithoutSitidInput | EmployeeTBLUpdateWithWhereUniqueWithoutSitidInput[]
    updateMany?: EmployeeTBLUpdateManyWithWhereWithoutSitidInput | EmployeeTBLUpdateManyWithWhereWithoutSitidInput[]
    deleteMany?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
  }

  export type BuildingTBLUpdateManyWithoutSiterefNestedInput = {
    create?: XOR<BuildingTBLCreateWithoutSiterefInput, BuildingTBLUncheckedCreateWithoutSiterefInput> | BuildingTBLCreateWithoutSiterefInput[] | BuildingTBLUncheckedCreateWithoutSiterefInput[]
    connectOrCreate?: BuildingTBLCreateOrConnectWithoutSiterefInput | BuildingTBLCreateOrConnectWithoutSiterefInput[]
    upsert?: BuildingTBLUpsertWithWhereUniqueWithoutSiterefInput | BuildingTBLUpsertWithWhereUniqueWithoutSiterefInput[]
    createMany?: BuildingTBLCreateManySiterefInputEnvelope
    set?: BuildingTBLWhereUniqueInput | BuildingTBLWhereUniqueInput[]
    disconnect?: BuildingTBLWhereUniqueInput | BuildingTBLWhereUniqueInput[]
    delete?: BuildingTBLWhereUniqueInput | BuildingTBLWhereUniqueInput[]
    connect?: BuildingTBLWhereUniqueInput | BuildingTBLWhereUniqueInput[]
    update?: BuildingTBLUpdateWithWhereUniqueWithoutSiterefInput | BuildingTBLUpdateWithWhereUniqueWithoutSiterefInput[]
    updateMany?: BuildingTBLUpdateManyWithWhereWithoutSiterefInput | BuildingTBLUpdateManyWithWhereWithoutSiterefInput[]
    deleteMany?: BuildingTBLScalarWhereInput | BuildingTBLScalarWhereInput[]
  }

  export type OfficeBoyTBLUpdateManyWithoutSiterefNestedInput = {
    create?: XOR<OfficeBoyTBLCreateWithoutSiterefInput, OfficeBoyTBLUncheckedCreateWithoutSiterefInput> | OfficeBoyTBLCreateWithoutSiterefInput[] | OfficeBoyTBLUncheckedCreateWithoutSiterefInput[]
    connectOrCreate?: OfficeBoyTBLCreateOrConnectWithoutSiterefInput | OfficeBoyTBLCreateOrConnectWithoutSiterefInput[]
    upsert?: OfficeBoyTBLUpsertWithWhereUniqueWithoutSiterefInput | OfficeBoyTBLUpsertWithWhereUniqueWithoutSiterefInput[]
    createMany?: OfficeBoyTBLCreateManySiterefInputEnvelope
    set?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    disconnect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    delete?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    connect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    update?: OfficeBoyTBLUpdateWithWhereUniqueWithoutSiterefInput | OfficeBoyTBLUpdateWithWhereUniqueWithoutSiterefInput[]
    updateMany?: OfficeBoyTBLUpdateManyWithWhereWithoutSiterefInput | OfficeBoyTBLUpdateManyWithWhereWithoutSiterefInput[]
    deleteMany?: OfficeBoyTBLScalarWhereInput | OfficeBoyTBLScalarWhereInput[]
  }

  export type EmployeeTBLUncheckedUpdateManyWithoutSitidNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutSitidInput, EmployeeTBLUncheckedCreateWithoutSitidInput> | EmployeeTBLCreateWithoutSitidInput[] | EmployeeTBLUncheckedCreateWithoutSitidInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutSitidInput | EmployeeTBLCreateOrConnectWithoutSitidInput[]
    upsert?: EmployeeTBLUpsertWithWhereUniqueWithoutSitidInput | EmployeeTBLUpsertWithWhereUniqueWithoutSitidInput[]
    createMany?: EmployeeTBLCreateManySitidInputEnvelope
    set?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    disconnect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    delete?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    update?: EmployeeTBLUpdateWithWhereUniqueWithoutSitidInput | EmployeeTBLUpdateWithWhereUniqueWithoutSitidInput[]
    updateMany?: EmployeeTBLUpdateManyWithWhereWithoutSitidInput | EmployeeTBLUpdateManyWithWhereWithoutSitidInput[]
    deleteMany?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
  }

  export type BuildingTBLUncheckedUpdateManyWithoutSiterefNestedInput = {
    create?: XOR<BuildingTBLCreateWithoutSiterefInput, BuildingTBLUncheckedCreateWithoutSiterefInput> | BuildingTBLCreateWithoutSiterefInput[] | BuildingTBLUncheckedCreateWithoutSiterefInput[]
    connectOrCreate?: BuildingTBLCreateOrConnectWithoutSiterefInput | BuildingTBLCreateOrConnectWithoutSiterefInput[]
    upsert?: BuildingTBLUpsertWithWhereUniqueWithoutSiterefInput | BuildingTBLUpsertWithWhereUniqueWithoutSiterefInput[]
    createMany?: BuildingTBLCreateManySiterefInputEnvelope
    set?: BuildingTBLWhereUniqueInput | BuildingTBLWhereUniqueInput[]
    disconnect?: BuildingTBLWhereUniqueInput | BuildingTBLWhereUniqueInput[]
    delete?: BuildingTBLWhereUniqueInput | BuildingTBLWhereUniqueInput[]
    connect?: BuildingTBLWhereUniqueInput | BuildingTBLWhereUniqueInput[]
    update?: BuildingTBLUpdateWithWhereUniqueWithoutSiterefInput | BuildingTBLUpdateWithWhereUniqueWithoutSiterefInput[]
    updateMany?: BuildingTBLUpdateManyWithWhereWithoutSiterefInput | BuildingTBLUpdateManyWithWhereWithoutSiterefInput[]
    deleteMany?: BuildingTBLScalarWhereInput | BuildingTBLScalarWhereInput[]
  }

  export type OfficeBoyTBLUncheckedUpdateManyWithoutSiterefNestedInput = {
    create?: XOR<OfficeBoyTBLCreateWithoutSiterefInput, OfficeBoyTBLUncheckedCreateWithoutSiterefInput> | OfficeBoyTBLCreateWithoutSiterefInput[] | OfficeBoyTBLUncheckedCreateWithoutSiterefInput[]
    connectOrCreate?: OfficeBoyTBLCreateOrConnectWithoutSiterefInput | OfficeBoyTBLCreateOrConnectWithoutSiterefInput[]
    upsert?: OfficeBoyTBLUpsertWithWhereUniqueWithoutSiterefInput | OfficeBoyTBLUpsertWithWhereUniqueWithoutSiterefInput[]
    createMany?: OfficeBoyTBLCreateManySiterefInputEnvelope
    set?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    disconnect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    delete?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    connect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    update?: OfficeBoyTBLUpdateWithWhereUniqueWithoutSiterefInput | OfficeBoyTBLUpdateWithWhereUniqueWithoutSiterefInput[]
    updateMany?: OfficeBoyTBLUpdateManyWithWhereWithoutSiterefInput | OfficeBoyTBLUpdateManyWithWhereWithoutSiterefInput[]
    deleteMany?: OfficeBoyTBLScalarWhereInput | OfficeBoyTBLScalarWhereInput[]
  }

  export type SiteTBLCreateNestedOneWithoutBuildingInput = {
    create?: XOR<SiteTBLCreateWithoutBuildingInput, SiteTBLUncheckedCreateWithoutBuildingInput>
    connectOrCreate?: SiteTBLCreateOrConnectWithoutBuildingInput
    connect?: SiteTBLWhereUniqueInput
  }

  export type DepartmentTBLCreateNestedManyWithoutBulidingrefInput = {
    create?: XOR<DepartmentTBLCreateWithoutBulidingrefInput, DepartmentTBLUncheckedCreateWithoutBulidingrefInput> | DepartmentTBLCreateWithoutBulidingrefInput[] | DepartmentTBLUncheckedCreateWithoutBulidingrefInput[]
    connectOrCreate?: DepartmentTBLCreateOrConnectWithoutBulidingrefInput | DepartmentTBLCreateOrConnectWithoutBulidingrefInput[]
    createMany?: DepartmentTBLCreateManyBulidingrefInputEnvelope
    connect?: DepartmentTBLWhereUniqueInput | DepartmentTBLWhereUniqueInput[]
  }

  export type OfficeTBLCreateNestedManyWithoutBulidingrefInput = {
    create?: XOR<OfficeTBLCreateWithoutBulidingrefInput, OfficeTBLUncheckedCreateWithoutBulidingrefInput> | OfficeTBLCreateWithoutBulidingrefInput[] | OfficeTBLUncheckedCreateWithoutBulidingrefInput[]
    connectOrCreate?: OfficeTBLCreateOrConnectWithoutBulidingrefInput | OfficeTBLCreateOrConnectWithoutBulidingrefInput[]
    createMany?: OfficeTBLCreateManyBulidingrefInputEnvelope
    connect?: OfficeTBLWhereUniqueInput | OfficeTBLWhereUniqueInput[]
  }

  export type EmployeeTBLCreateNestedManyWithoutBulidingrefInput = {
    create?: XOR<EmployeeTBLCreateWithoutBulidingrefInput, EmployeeTBLUncheckedCreateWithoutBulidingrefInput> | EmployeeTBLCreateWithoutBulidingrefInput[] | EmployeeTBLUncheckedCreateWithoutBulidingrefInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutBulidingrefInput | EmployeeTBLCreateOrConnectWithoutBulidingrefInput[]
    createMany?: EmployeeTBLCreateManyBulidingrefInputEnvelope
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
  }

  export type DepartmentTBLUncheckedCreateNestedManyWithoutBulidingrefInput = {
    create?: XOR<DepartmentTBLCreateWithoutBulidingrefInput, DepartmentTBLUncheckedCreateWithoutBulidingrefInput> | DepartmentTBLCreateWithoutBulidingrefInput[] | DepartmentTBLUncheckedCreateWithoutBulidingrefInput[]
    connectOrCreate?: DepartmentTBLCreateOrConnectWithoutBulidingrefInput | DepartmentTBLCreateOrConnectWithoutBulidingrefInput[]
    createMany?: DepartmentTBLCreateManyBulidingrefInputEnvelope
    connect?: DepartmentTBLWhereUniqueInput | DepartmentTBLWhereUniqueInput[]
  }

  export type OfficeTBLUncheckedCreateNestedManyWithoutBulidingrefInput = {
    create?: XOR<OfficeTBLCreateWithoutBulidingrefInput, OfficeTBLUncheckedCreateWithoutBulidingrefInput> | OfficeTBLCreateWithoutBulidingrefInput[] | OfficeTBLUncheckedCreateWithoutBulidingrefInput[]
    connectOrCreate?: OfficeTBLCreateOrConnectWithoutBulidingrefInput | OfficeTBLCreateOrConnectWithoutBulidingrefInput[]
    createMany?: OfficeTBLCreateManyBulidingrefInputEnvelope
    connect?: OfficeTBLWhereUniqueInput | OfficeTBLWhereUniqueInput[]
  }

  export type EmployeeTBLUncheckedCreateNestedManyWithoutBulidingrefInput = {
    create?: XOR<EmployeeTBLCreateWithoutBulidingrefInput, EmployeeTBLUncheckedCreateWithoutBulidingrefInput> | EmployeeTBLCreateWithoutBulidingrefInput[] | EmployeeTBLUncheckedCreateWithoutBulidingrefInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutBulidingrefInput | EmployeeTBLCreateOrConnectWithoutBulidingrefInput[]
    createMany?: EmployeeTBLCreateManyBulidingrefInputEnvelope
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
  }

  export type SiteTBLUpdateOneRequiredWithoutBuildingNestedInput = {
    create?: XOR<SiteTBLCreateWithoutBuildingInput, SiteTBLUncheckedCreateWithoutBuildingInput>
    connectOrCreate?: SiteTBLCreateOrConnectWithoutBuildingInput
    upsert?: SiteTBLUpsertWithoutBuildingInput
    connect?: SiteTBLWhereUniqueInput
    update?: XOR<XOR<SiteTBLUpdateToOneWithWhereWithoutBuildingInput, SiteTBLUpdateWithoutBuildingInput>, SiteTBLUncheckedUpdateWithoutBuildingInput>
  }

  export type DepartmentTBLUpdateManyWithoutBulidingrefNestedInput = {
    create?: XOR<DepartmentTBLCreateWithoutBulidingrefInput, DepartmentTBLUncheckedCreateWithoutBulidingrefInput> | DepartmentTBLCreateWithoutBulidingrefInput[] | DepartmentTBLUncheckedCreateWithoutBulidingrefInput[]
    connectOrCreate?: DepartmentTBLCreateOrConnectWithoutBulidingrefInput | DepartmentTBLCreateOrConnectWithoutBulidingrefInput[]
    upsert?: DepartmentTBLUpsertWithWhereUniqueWithoutBulidingrefInput | DepartmentTBLUpsertWithWhereUniqueWithoutBulidingrefInput[]
    createMany?: DepartmentTBLCreateManyBulidingrefInputEnvelope
    set?: DepartmentTBLWhereUniqueInput | DepartmentTBLWhereUniqueInput[]
    disconnect?: DepartmentTBLWhereUniqueInput | DepartmentTBLWhereUniqueInput[]
    delete?: DepartmentTBLWhereUniqueInput | DepartmentTBLWhereUniqueInput[]
    connect?: DepartmentTBLWhereUniqueInput | DepartmentTBLWhereUniqueInput[]
    update?: DepartmentTBLUpdateWithWhereUniqueWithoutBulidingrefInput | DepartmentTBLUpdateWithWhereUniqueWithoutBulidingrefInput[]
    updateMany?: DepartmentTBLUpdateManyWithWhereWithoutBulidingrefInput | DepartmentTBLUpdateManyWithWhereWithoutBulidingrefInput[]
    deleteMany?: DepartmentTBLScalarWhereInput | DepartmentTBLScalarWhereInput[]
  }

  export type OfficeTBLUpdateManyWithoutBulidingrefNestedInput = {
    create?: XOR<OfficeTBLCreateWithoutBulidingrefInput, OfficeTBLUncheckedCreateWithoutBulidingrefInput> | OfficeTBLCreateWithoutBulidingrefInput[] | OfficeTBLUncheckedCreateWithoutBulidingrefInput[]
    connectOrCreate?: OfficeTBLCreateOrConnectWithoutBulidingrefInput | OfficeTBLCreateOrConnectWithoutBulidingrefInput[]
    upsert?: OfficeTBLUpsertWithWhereUniqueWithoutBulidingrefInput | OfficeTBLUpsertWithWhereUniqueWithoutBulidingrefInput[]
    createMany?: OfficeTBLCreateManyBulidingrefInputEnvelope
    set?: OfficeTBLWhereUniqueInput | OfficeTBLWhereUniqueInput[]
    disconnect?: OfficeTBLWhereUniqueInput | OfficeTBLWhereUniqueInput[]
    delete?: OfficeTBLWhereUniqueInput | OfficeTBLWhereUniqueInput[]
    connect?: OfficeTBLWhereUniqueInput | OfficeTBLWhereUniqueInput[]
    update?: OfficeTBLUpdateWithWhereUniqueWithoutBulidingrefInput | OfficeTBLUpdateWithWhereUniqueWithoutBulidingrefInput[]
    updateMany?: OfficeTBLUpdateManyWithWhereWithoutBulidingrefInput | OfficeTBLUpdateManyWithWhereWithoutBulidingrefInput[]
    deleteMany?: OfficeTBLScalarWhereInput | OfficeTBLScalarWhereInput[]
  }

  export type EmployeeTBLUpdateManyWithoutBulidingrefNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutBulidingrefInput, EmployeeTBLUncheckedCreateWithoutBulidingrefInput> | EmployeeTBLCreateWithoutBulidingrefInput[] | EmployeeTBLUncheckedCreateWithoutBulidingrefInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutBulidingrefInput | EmployeeTBLCreateOrConnectWithoutBulidingrefInput[]
    upsert?: EmployeeTBLUpsertWithWhereUniqueWithoutBulidingrefInput | EmployeeTBLUpsertWithWhereUniqueWithoutBulidingrefInput[]
    createMany?: EmployeeTBLCreateManyBulidingrefInputEnvelope
    set?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    disconnect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    delete?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    update?: EmployeeTBLUpdateWithWhereUniqueWithoutBulidingrefInput | EmployeeTBLUpdateWithWhereUniqueWithoutBulidingrefInput[]
    updateMany?: EmployeeTBLUpdateManyWithWhereWithoutBulidingrefInput | EmployeeTBLUpdateManyWithWhereWithoutBulidingrefInput[]
    deleteMany?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
  }

  export type DepartmentTBLUncheckedUpdateManyWithoutBulidingrefNestedInput = {
    create?: XOR<DepartmentTBLCreateWithoutBulidingrefInput, DepartmentTBLUncheckedCreateWithoutBulidingrefInput> | DepartmentTBLCreateWithoutBulidingrefInput[] | DepartmentTBLUncheckedCreateWithoutBulidingrefInput[]
    connectOrCreate?: DepartmentTBLCreateOrConnectWithoutBulidingrefInput | DepartmentTBLCreateOrConnectWithoutBulidingrefInput[]
    upsert?: DepartmentTBLUpsertWithWhereUniqueWithoutBulidingrefInput | DepartmentTBLUpsertWithWhereUniqueWithoutBulidingrefInput[]
    createMany?: DepartmentTBLCreateManyBulidingrefInputEnvelope
    set?: DepartmentTBLWhereUniqueInput | DepartmentTBLWhereUniqueInput[]
    disconnect?: DepartmentTBLWhereUniqueInput | DepartmentTBLWhereUniqueInput[]
    delete?: DepartmentTBLWhereUniqueInput | DepartmentTBLWhereUniqueInput[]
    connect?: DepartmentTBLWhereUniqueInput | DepartmentTBLWhereUniqueInput[]
    update?: DepartmentTBLUpdateWithWhereUniqueWithoutBulidingrefInput | DepartmentTBLUpdateWithWhereUniqueWithoutBulidingrefInput[]
    updateMany?: DepartmentTBLUpdateManyWithWhereWithoutBulidingrefInput | DepartmentTBLUpdateManyWithWhereWithoutBulidingrefInput[]
    deleteMany?: DepartmentTBLScalarWhereInput | DepartmentTBLScalarWhereInput[]
  }

  export type OfficeTBLUncheckedUpdateManyWithoutBulidingrefNestedInput = {
    create?: XOR<OfficeTBLCreateWithoutBulidingrefInput, OfficeTBLUncheckedCreateWithoutBulidingrefInput> | OfficeTBLCreateWithoutBulidingrefInput[] | OfficeTBLUncheckedCreateWithoutBulidingrefInput[]
    connectOrCreate?: OfficeTBLCreateOrConnectWithoutBulidingrefInput | OfficeTBLCreateOrConnectWithoutBulidingrefInput[]
    upsert?: OfficeTBLUpsertWithWhereUniqueWithoutBulidingrefInput | OfficeTBLUpsertWithWhereUniqueWithoutBulidingrefInput[]
    createMany?: OfficeTBLCreateManyBulidingrefInputEnvelope
    set?: OfficeTBLWhereUniqueInput | OfficeTBLWhereUniqueInput[]
    disconnect?: OfficeTBLWhereUniqueInput | OfficeTBLWhereUniqueInput[]
    delete?: OfficeTBLWhereUniqueInput | OfficeTBLWhereUniqueInput[]
    connect?: OfficeTBLWhereUniqueInput | OfficeTBLWhereUniqueInput[]
    update?: OfficeTBLUpdateWithWhereUniqueWithoutBulidingrefInput | OfficeTBLUpdateWithWhereUniqueWithoutBulidingrefInput[]
    updateMany?: OfficeTBLUpdateManyWithWhereWithoutBulidingrefInput | OfficeTBLUpdateManyWithWhereWithoutBulidingrefInput[]
    deleteMany?: OfficeTBLScalarWhereInput | OfficeTBLScalarWhereInput[]
  }

  export type EmployeeTBLUncheckedUpdateManyWithoutBulidingrefNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutBulidingrefInput, EmployeeTBLUncheckedCreateWithoutBulidingrefInput> | EmployeeTBLCreateWithoutBulidingrefInput[] | EmployeeTBLUncheckedCreateWithoutBulidingrefInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutBulidingrefInput | EmployeeTBLCreateOrConnectWithoutBulidingrefInput[]
    upsert?: EmployeeTBLUpsertWithWhereUniqueWithoutBulidingrefInput | EmployeeTBLUpsertWithWhereUniqueWithoutBulidingrefInput[]
    createMany?: EmployeeTBLCreateManyBulidingrefInputEnvelope
    set?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    disconnect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    delete?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    update?: EmployeeTBLUpdateWithWhereUniqueWithoutBulidingrefInput | EmployeeTBLUpdateWithWhereUniqueWithoutBulidingrefInput[]
    updateMany?: EmployeeTBLUpdateManyWithWhereWithoutBulidingrefInput | EmployeeTBLUpdateManyWithWhereWithoutBulidingrefInput[]
    deleteMany?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
  }

  export type EmployeeTBLCreateNestedManyWithoutOffidInput = {
    create?: XOR<EmployeeTBLCreateWithoutOffidInput, EmployeeTBLUncheckedCreateWithoutOffidInput> | EmployeeTBLCreateWithoutOffidInput[] | EmployeeTBLUncheckedCreateWithoutOffidInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutOffidInput | EmployeeTBLCreateOrConnectWithoutOffidInput[]
    createMany?: EmployeeTBLCreateManyOffidInputEnvelope
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
  }

  export type OfficeBoyTBLCreateNestedManyWithoutOffidInput = {
    create?: XOR<OfficeBoyTBLCreateWithoutOffidInput, OfficeBoyTBLUncheckedCreateWithoutOffidInput> | OfficeBoyTBLCreateWithoutOffidInput[] | OfficeBoyTBLUncheckedCreateWithoutOffidInput[]
    connectOrCreate?: OfficeBoyTBLCreateOrConnectWithoutOffidInput | OfficeBoyTBLCreateOrConnectWithoutOffidInput[]
    createMany?: OfficeBoyTBLCreateManyOffidInputEnvelope
    connect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
  }

  export type BuildingTBLCreateNestedOneWithoutOfficeInput = {
    create?: XOR<BuildingTBLCreateWithoutOfficeInput, BuildingTBLUncheckedCreateWithoutOfficeInput>
    connectOrCreate?: BuildingTBLCreateOrConnectWithoutOfficeInput
    connect?: BuildingTBLWhereUniqueInput
  }

  export type RoomTBLCreateNestedManyWithoutOfficerefInput = {
    create?: XOR<RoomTBLCreateWithoutOfficerefInput, RoomTBLUncheckedCreateWithoutOfficerefInput> | RoomTBLCreateWithoutOfficerefInput[] | RoomTBLUncheckedCreateWithoutOfficerefInput[]
    connectOrCreate?: RoomTBLCreateOrConnectWithoutOfficerefInput | RoomTBLCreateOrConnectWithoutOfficerefInput[]
    createMany?: RoomTBLCreateManyOfficerefInputEnvelope
    connect?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
  }

  export type EmployeeTBLUncheckedCreateNestedManyWithoutOffidInput = {
    create?: XOR<EmployeeTBLCreateWithoutOffidInput, EmployeeTBLUncheckedCreateWithoutOffidInput> | EmployeeTBLCreateWithoutOffidInput[] | EmployeeTBLUncheckedCreateWithoutOffidInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutOffidInput | EmployeeTBLCreateOrConnectWithoutOffidInput[]
    createMany?: EmployeeTBLCreateManyOffidInputEnvelope
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
  }

  export type OfficeBoyTBLUncheckedCreateNestedManyWithoutOffidInput = {
    create?: XOR<OfficeBoyTBLCreateWithoutOffidInput, OfficeBoyTBLUncheckedCreateWithoutOffidInput> | OfficeBoyTBLCreateWithoutOffidInput[] | OfficeBoyTBLUncheckedCreateWithoutOffidInput[]
    connectOrCreate?: OfficeBoyTBLCreateOrConnectWithoutOffidInput | OfficeBoyTBLCreateOrConnectWithoutOffidInput[]
    createMany?: OfficeBoyTBLCreateManyOffidInputEnvelope
    connect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
  }

  export type RoomTBLUncheckedCreateNestedManyWithoutOfficerefInput = {
    create?: XOR<RoomTBLCreateWithoutOfficerefInput, RoomTBLUncheckedCreateWithoutOfficerefInput> | RoomTBLCreateWithoutOfficerefInput[] | RoomTBLUncheckedCreateWithoutOfficerefInput[]
    connectOrCreate?: RoomTBLCreateOrConnectWithoutOfficerefInput | RoomTBLCreateOrConnectWithoutOfficerefInput[]
    createMany?: RoomTBLCreateManyOfficerefInputEnvelope
    connect?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
  }

  export type EmployeeTBLUpdateManyWithoutOffidNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutOffidInput, EmployeeTBLUncheckedCreateWithoutOffidInput> | EmployeeTBLCreateWithoutOffidInput[] | EmployeeTBLUncheckedCreateWithoutOffidInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutOffidInput | EmployeeTBLCreateOrConnectWithoutOffidInput[]
    upsert?: EmployeeTBLUpsertWithWhereUniqueWithoutOffidInput | EmployeeTBLUpsertWithWhereUniqueWithoutOffidInput[]
    createMany?: EmployeeTBLCreateManyOffidInputEnvelope
    set?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    disconnect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    delete?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    update?: EmployeeTBLUpdateWithWhereUniqueWithoutOffidInput | EmployeeTBLUpdateWithWhereUniqueWithoutOffidInput[]
    updateMany?: EmployeeTBLUpdateManyWithWhereWithoutOffidInput | EmployeeTBLUpdateManyWithWhereWithoutOffidInput[]
    deleteMany?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
  }

  export type OfficeBoyTBLUpdateManyWithoutOffidNestedInput = {
    create?: XOR<OfficeBoyTBLCreateWithoutOffidInput, OfficeBoyTBLUncheckedCreateWithoutOffidInput> | OfficeBoyTBLCreateWithoutOffidInput[] | OfficeBoyTBLUncheckedCreateWithoutOffidInput[]
    connectOrCreate?: OfficeBoyTBLCreateOrConnectWithoutOffidInput | OfficeBoyTBLCreateOrConnectWithoutOffidInput[]
    upsert?: OfficeBoyTBLUpsertWithWhereUniqueWithoutOffidInput | OfficeBoyTBLUpsertWithWhereUniqueWithoutOffidInput[]
    createMany?: OfficeBoyTBLCreateManyOffidInputEnvelope
    set?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    disconnect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    delete?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    connect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    update?: OfficeBoyTBLUpdateWithWhereUniqueWithoutOffidInput | OfficeBoyTBLUpdateWithWhereUniqueWithoutOffidInput[]
    updateMany?: OfficeBoyTBLUpdateManyWithWhereWithoutOffidInput | OfficeBoyTBLUpdateManyWithWhereWithoutOffidInput[]
    deleteMany?: OfficeBoyTBLScalarWhereInput | OfficeBoyTBLScalarWhereInput[]
  }

  export type BuildingTBLUpdateOneRequiredWithoutOfficeNestedInput = {
    create?: XOR<BuildingTBLCreateWithoutOfficeInput, BuildingTBLUncheckedCreateWithoutOfficeInput>
    connectOrCreate?: BuildingTBLCreateOrConnectWithoutOfficeInput
    upsert?: BuildingTBLUpsertWithoutOfficeInput
    connect?: BuildingTBLWhereUniqueInput
    update?: XOR<XOR<BuildingTBLUpdateToOneWithWhereWithoutOfficeInput, BuildingTBLUpdateWithoutOfficeInput>, BuildingTBLUncheckedUpdateWithoutOfficeInput>
  }

  export type RoomTBLUpdateManyWithoutOfficerefNestedInput = {
    create?: XOR<RoomTBLCreateWithoutOfficerefInput, RoomTBLUncheckedCreateWithoutOfficerefInput> | RoomTBLCreateWithoutOfficerefInput[] | RoomTBLUncheckedCreateWithoutOfficerefInput[]
    connectOrCreate?: RoomTBLCreateOrConnectWithoutOfficerefInput | RoomTBLCreateOrConnectWithoutOfficerefInput[]
    upsert?: RoomTBLUpsertWithWhereUniqueWithoutOfficerefInput | RoomTBLUpsertWithWhereUniqueWithoutOfficerefInput[]
    createMany?: RoomTBLCreateManyOfficerefInputEnvelope
    set?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    disconnect?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    delete?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    connect?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    update?: RoomTBLUpdateWithWhereUniqueWithoutOfficerefInput | RoomTBLUpdateWithWhereUniqueWithoutOfficerefInput[]
    updateMany?: RoomTBLUpdateManyWithWhereWithoutOfficerefInput | RoomTBLUpdateManyWithWhereWithoutOfficerefInput[]
    deleteMany?: RoomTBLScalarWhereInput | RoomTBLScalarWhereInput[]
  }

  export type EmployeeTBLUncheckedUpdateManyWithoutOffidNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutOffidInput, EmployeeTBLUncheckedCreateWithoutOffidInput> | EmployeeTBLCreateWithoutOffidInput[] | EmployeeTBLUncheckedCreateWithoutOffidInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutOffidInput | EmployeeTBLCreateOrConnectWithoutOffidInput[]
    upsert?: EmployeeTBLUpsertWithWhereUniqueWithoutOffidInput | EmployeeTBLUpsertWithWhereUniqueWithoutOffidInput[]
    createMany?: EmployeeTBLCreateManyOffidInputEnvelope
    set?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    disconnect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    delete?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    update?: EmployeeTBLUpdateWithWhereUniqueWithoutOffidInput | EmployeeTBLUpdateWithWhereUniqueWithoutOffidInput[]
    updateMany?: EmployeeTBLUpdateManyWithWhereWithoutOffidInput | EmployeeTBLUpdateManyWithWhereWithoutOffidInput[]
    deleteMany?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
  }

  export type OfficeBoyTBLUncheckedUpdateManyWithoutOffidNestedInput = {
    create?: XOR<OfficeBoyTBLCreateWithoutOffidInput, OfficeBoyTBLUncheckedCreateWithoutOffidInput> | OfficeBoyTBLCreateWithoutOffidInput[] | OfficeBoyTBLUncheckedCreateWithoutOffidInput[]
    connectOrCreate?: OfficeBoyTBLCreateOrConnectWithoutOffidInput | OfficeBoyTBLCreateOrConnectWithoutOffidInput[]
    upsert?: OfficeBoyTBLUpsertWithWhereUniqueWithoutOffidInput | OfficeBoyTBLUpsertWithWhereUniqueWithoutOffidInput[]
    createMany?: OfficeBoyTBLCreateManyOffidInputEnvelope
    set?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    disconnect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    delete?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    connect?: OfficeBoyTBLWhereUniqueInput | OfficeBoyTBLWhereUniqueInput[]
    update?: OfficeBoyTBLUpdateWithWhereUniqueWithoutOffidInput | OfficeBoyTBLUpdateWithWhereUniqueWithoutOffidInput[]
    updateMany?: OfficeBoyTBLUpdateManyWithWhereWithoutOffidInput | OfficeBoyTBLUpdateManyWithWhereWithoutOffidInput[]
    deleteMany?: OfficeBoyTBLScalarWhereInput | OfficeBoyTBLScalarWhereInput[]
  }

  export type RoomTBLUncheckedUpdateManyWithoutOfficerefNestedInput = {
    create?: XOR<RoomTBLCreateWithoutOfficerefInput, RoomTBLUncheckedCreateWithoutOfficerefInput> | RoomTBLCreateWithoutOfficerefInput[] | RoomTBLUncheckedCreateWithoutOfficerefInput[]
    connectOrCreate?: RoomTBLCreateOrConnectWithoutOfficerefInput | RoomTBLCreateOrConnectWithoutOfficerefInput[]
    upsert?: RoomTBLUpsertWithWhereUniqueWithoutOfficerefInput | RoomTBLUpsertWithWhereUniqueWithoutOfficerefInput[]
    createMany?: RoomTBLCreateManyOfficerefInputEnvelope
    set?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    disconnect?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    delete?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    connect?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    update?: RoomTBLUpdateWithWhereUniqueWithoutOfficerefInput | RoomTBLUpdateWithWhereUniqueWithoutOfficerefInput[]
    updateMany?: RoomTBLUpdateManyWithWhereWithoutOfficerefInput | RoomTBLUpdateManyWithWhereWithoutOfficerefInput[]
    deleteMany?: RoomTBLScalarWhereInput | RoomTBLScalarWhereInput[]
  }

  export type RoomTBLCreateNestedManyWithoutRoomdeprefInput = {
    create?: XOR<RoomTBLCreateWithoutRoomdeprefInput, RoomTBLUncheckedCreateWithoutRoomdeprefInput> | RoomTBLCreateWithoutRoomdeprefInput[] | RoomTBLUncheckedCreateWithoutRoomdeprefInput[]
    connectOrCreate?: RoomTBLCreateOrConnectWithoutRoomdeprefInput | RoomTBLCreateOrConnectWithoutRoomdeprefInput[]
    createMany?: RoomTBLCreateManyRoomdeprefInputEnvelope
    connect?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
  }

  export type EmployeeTBLCreateNestedManyWithoutDepartmentrefInput = {
    create?: XOR<EmployeeTBLCreateWithoutDepartmentrefInput, EmployeeTBLUncheckedCreateWithoutDepartmentrefInput> | EmployeeTBLCreateWithoutDepartmentrefInput[] | EmployeeTBLUncheckedCreateWithoutDepartmentrefInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutDepartmentrefInput | EmployeeTBLCreateOrConnectWithoutDepartmentrefInput[]
    createMany?: EmployeeTBLCreateManyDepartmentrefInputEnvelope
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
  }

  export type BuildingTBLCreateNestedOneWithoutDepartmentInput = {
    create?: XOR<BuildingTBLCreateWithoutDepartmentInput, BuildingTBLUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: BuildingTBLCreateOrConnectWithoutDepartmentInput
    connect?: BuildingTBLWhereUniqueInput
  }

  export type RoomTBLUncheckedCreateNestedManyWithoutRoomdeprefInput = {
    create?: XOR<RoomTBLCreateWithoutRoomdeprefInput, RoomTBLUncheckedCreateWithoutRoomdeprefInput> | RoomTBLCreateWithoutRoomdeprefInput[] | RoomTBLUncheckedCreateWithoutRoomdeprefInput[]
    connectOrCreate?: RoomTBLCreateOrConnectWithoutRoomdeprefInput | RoomTBLCreateOrConnectWithoutRoomdeprefInput[]
    createMany?: RoomTBLCreateManyRoomdeprefInputEnvelope
    connect?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
  }

  export type EmployeeTBLUncheckedCreateNestedManyWithoutDepartmentrefInput = {
    create?: XOR<EmployeeTBLCreateWithoutDepartmentrefInput, EmployeeTBLUncheckedCreateWithoutDepartmentrefInput> | EmployeeTBLCreateWithoutDepartmentrefInput[] | EmployeeTBLUncheckedCreateWithoutDepartmentrefInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutDepartmentrefInput | EmployeeTBLCreateOrConnectWithoutDepartmentrefInput[]
    createMany?: EmployeeTBLCreateManyDepartmentrefInputEnvelope
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
  }

  export type RoomTBLUpdateManyWithoutRoomdeprefNestedInput = {
    create?: XOR<RoomTBLCreateWithoutRoomdeprefInput, RoomTBLUncheckedCreateWithoutRoomdeprefInput> | RoomTBLCreateWithoutRoomdeprefInput[] | RoomTBLUncheckedCreateWithoutRoomdeprefInput[]
    connectOrCreate?: RoomTBLCreateOrConnectWithoutRoomdeprefInput | RoomTBLCreateOrConnectWithoutRoomdeprefInput[]
    upsert?: RoomTBLUpsertWithWhereUniqueWithoutRoomdeprefInput | RoomTBLUpsertWithWhereUniqueWithoutRoomdeprefInput[]
    createMany?: RoomTBLCreateManyRoomdeprefInputEnvelope
    set?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    disconnect?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    delete?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    connect?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    update?: RoomTBLUpdateWithWhereUniqueWithoutRoomdeprefInput | RoomTBLUpdateWithWhereUniqueWithoutRoomdeprefInput[]
    updateMany?: RoomTBLUpdateManyWithWhereWithoutRoomdeprefInput | RoomTBLUpdateManyWithWhereWithoutRoomdeprefInput[]
    deleteMany?: RoomTBLScalarWhereInput | RoomTBLScalarWhereInput[]
  }

  export type EmployeeTBLUpdateManyWithoutDepartmentrefNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutDepartmentrefInput, EmployeeTBLUncheckedCreateWithoutDepartmentrefInput> | EmployeeTBLCreateWithoutDepartmentrefInput[] | EmployeeTBLUncheckedCreateWithoutDepartmentrefInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutDepartmentrefInput | EmployeeTBLCreateOrConnectWithoutDepartmentrefInput[]
    upsert?: EmployeeTBLUpsertWithWhereUniqueWithoutDepartmentrefInput | EmployeeTBLUpsertWithWhereUniqueWithoutDepartmentrefInput[]
    createMany?: EmployeeTBLCreateManyDepartmentrefInputEnvelope
    set?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    disconnect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    delete?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    update?: EmployeeTBLUpdateWithWhereUniqueWithoutDepartmentrefInput | EmployeeTBLUpdateWithWhereUniqueWithoutDepartmentrefInput[]
    updateMany?: EmployeeTBLUpdateManyWithWhereWithoutDepartmentrefInput | EmployeeTBLUpdateManyWithWhereWithoutDepartmentrefInput[]
    deleteMany?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
  }

  export type BuildingTBLUpdateOneRequiredWithoutDepartmentNestedInput = {
    create?: XOR<BuildingTBLCreateWithoutDepartmentInput, BuildingTBLUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: BuildingTBLCreateOrConnectWithoutDepartmentInput
    upsert?: BuildingTBLUpsertWithoutDepartmentInput
    connect?: BuildingTBLWhereUniqueInput
    update?: XOR<XOR<BuildingTBLUpdateToOneWithWhereWithoutDepartmentInput, BuildingTBLUpdateWithoutDepartmentInput>, BuildingTBLUncheckedUpdateWithoutDepartmentInput>
  }

  export type RoomTBLUncheckedUpdateManyWithoutRoomdeprefNestedInput = {
    create?: XOR<RoomTBLCreateWithoutRoomdeprefInput, RoomTBLUncheckedCreateWithoutRoomdeprefInput> | RoomTBLCreateWithoutRoomdeprefInput[] | RoomTBLUncheckedCreateWithoutRoomdeprefInput[]
    connectOrCreate?: RoomTBLCreateOrConnectWithoutRoomdeprefInput | RoomTBLCreateOrConnectWithoutRoomdeprefInput[]
    upsert?: RoomTBLUpsertWithWhereUniqueWithoutRoomdeprefInput | RoomTBLUpsertWithWhereUniqueWithoutRoomdeprefInput[]
    createMany?: RoomTBLCreateManyRoomdeprefInputEnvelope
    set?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    disconnect?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    delete?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    connect?: RoomTBLWhereUniqueInput | RoomTBLWhereUniqueInput[]
    update?: RoomTBLUpdateWithWhereUniqueWithoutRoomdeprefInput | RoomTBLUpdateWithWhereUniqueWithoutRoomdeprefInput[]
    updateMany?: RoomTBLUpdateManyWithWhereWithoutRoomdeprefInput | RoomTBLUpdateManyWithWhereWithoutRoomdeprefInput[]
    deleteMany?: RoomTBLScalarWhereInput | RoomTBLScalarWhereInput[]
  }

  export type EmployeeTBLUncheckedUpdateManyWithoutDepartmentrefNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutDepartmentrefInput, EmployeeTBLUncheckedCreateWithoutDepartmentrefInput> | EmployeeTBLCreateWithoutDepartmentrefInput[] | EmployeeTBLUncheckedCreateWithoutDepartmentrefInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutDepartmentrefInput | EmployeeTBLCreateOrConnectWithoutDepartmentrefInput[]
    upsert?: EmployeeTBLUpsertWithWhereUniqueWithoutDepartmentrefInput | EmployeeTBLUpsertWithWhereUniqueWithoutDepartmentrefInput[]
    createMany?: EmployeeTBLCreateManyDepartmentrefInputEnvelope
    set?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    disconnect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    delete?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    update?: EmployeeTBLUpdateWithWhereUniqueWithoutDepartmentrefInput | EmployeeTBLUpdateWithWhereUniqueWithoutDepartmentrefInput[]
    updateMany?: EmployeeTBLUpdateManyWithWhereWithoutDepartmentrefInput | EmployeeTBLUpdateManyWithWhereWithoutDepartmentrefInput[]
    deleteMany?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
  }

  export type OfficeTBLCreateNestedOneWithoutRoomInput = {
    create?: XOR<OfficeTBLCreateWithoutRoomInput, OfficeTBLUncheckedCreateWithoutRoomInput>
    connectOrCreate?: OfficeTBLCreateOrConnectWithoutRoomInput
    connect?: OfficeTBLWhereUniqueInput
  }

  export type DepartmentTBLCreateNestedOneWithoutRoomInput = {
    create?: XOR<DepartmentTBLCreateWithoutRoomInput, DepartmentTBLUncheckedCreateWithoutRoomInput>
    connectOrCreate?: DepartmentTBLCreateOrConnectWithoutRoomInput
    connect?: DepartmentTBLWhereUniqueInput
  }

  export type EmployeeTBLCreateNestedManyWithoutRomidInput = {
    create?: XOR<EmployeeTBLCreateWithoutRomidInput, EmployeeTBLUncheckedCreateWithoutRomidInput> | EmployeeTBLCreateWithoutRomidInput[] | EmployeeTBLUncheckedCreateWithoutRomidInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutRomidInput | EmployeeTBLCreateOrConnectWithoutRomidInput[]
    createMany?: EmployeeTBLCreateManyRomidInputEnvelope
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
  }

  export type EmployeeTBLUncheckedCreateNestedManyWithoutRomidInput = {
    create?: XOR<EmployeeTBLCreateWithoutRomidInput, EmployeeTBLUncheckedCreateWithoutRomidInput> | EmployeeTBLCreateWithoutRomidInput[] | EmployeeTBLUncheckedCreateWithoutRomidInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutRomidInput | EmployeeTBLCreateOrConnectWithoutRomidInput[]
    createMany?: EmployeeTBLCreateManyRomidInputEnvelope
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
  }

  export type OfficeTBLUpdateOneRequiredWithoutRoomNestedInput = {
    create?: XOR<OfficeTBLCreateWithoutRoomInput, OfficeTBLUncheckedCreateWithoutRoomInput>
    connectOrCreate?: OfficeTBLCreateOrConnectWithoutRoomInput
    upsert?: OfficeTBLUpsertWithoutRoomInput
    connect?: OfficeTBLWhereUniqueInput
    update?: XOR<XOR<OfficeTBLUpdateToOneWithWhereWithoutRoomInput, OfficeTBLUpdateWithoutRoomInput>, OfficeTBLUncheckedUpdateWithoutRoomInput>
  }

  export type DepartmentTBLUpdateOneRequiredWithoutRoomNestedInput = {
    create?: XOR<DepartmentTBLCreateWithoutRoomInput, DepartmentTBLUncheckedCreateWithoutRoomInput>
    connectOrCreate?: DepartmentTBLCreateOrConnectWithoutRoomInput
    upsert?: DepartmentTBLUpsertWithoutRoomInput
    connect?: DepartmentTBLWhereUniqueInput
    update?: XOR<XOR<DepartmentTBLUpdateToOneWithWhereWithoutRoomInput, DepartmentTBLUpdateWithoutRoomInput>, DepartmentTBLUncheckedUpdateWithoutRoomInput>
  }

  export type EmployeeTBLUpdateManyWithoutRomidNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutRomidInput, EmployeeTBLUncheckedCreateWithoutRomidInput> | EmployeeTBLCreateWithoutRomidInput[] | EmployeeTBLUncheckedCreateWithoutRomidInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutRomidInput | EmployeeTBLCreateOrConnectWithoutRomidInput[]
    upsert?: EmployeeTBLUpsertWithWhereUniqueWithoutRomidInput | EmployeeTBLUpsertWithWhereUniqueWithoutRomidInput[]
    createMany?: EmployeeTBLCreateManyRomidInputEnvelope
    set?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    disconnect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    delete?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    update?: EmployeeTBLUpdateWithWhereUniqueWithoutRomidInput | EmployeeTBLUpdateWithWhereUniqueWithoutRomidInput[]
    updateMany?: EmployeeTBLUpdateManyWithWhereWithoutRomidInput | EmployeeTBLUpdateManyWithWhereWithoutRomidInput[]
    deleteMany?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
  }

  export type EmployeeTBLUncheckedUpdateManyWithoutRomidNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutRomidInput, EmployeeTBLUncheckedCreateWithoutRomidInput> | EmployeeTBLCreateWithoutRomidInput[] | EmployeeTBLUncheckedCreateWithoutRomidInput[]
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutRomidInput | EmployeeTBLCreateOrConnectWithoutRomidInput[]
    upsert?: EmployeeTBLUpsertWithWhereUniqueWithoutRomidInput | EmployeeTBLUpsertWithWhereUniqueWithoutRomidInput[]
    createMany?: EmployeeTBLCreateManyRomidInputEnvelope
    set?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    disconnect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    delete?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    connect?: EmployeeTBLWhereUniqueInput | EmployeeTBLWhereUniqueInput[]
    update?: EmployeeTBLUpdateWithWhereUniqueWithoutRomidInput | EmployeeTBLUpdateWithWhereUniqueWithoutRomidInput[]
    updateMany?: EmployeeTBLUpdateManyWithWhereWithoutRomidInput | EmployeeTBLUpdateManyWithWhereWithoutRomidInput[]
    deleteMany?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
  }

  export type ItemsTBLCreateNestedManyWithoutCatidInput = {
    create?: XOR<ItemsTBLCreateWithoutCatidInput, ItemsTBLUncheckedCreateWithoutCatidInput> | ItemsTBLCreateWithoutCatidInput[] | ItemsTBLUncheckedCreateWithoutCatidInput[]
    connectOrCreate?: ItemsTBLCreateOrConnectWithoutCatidInput | ItemsTBLCreateOrConnectWithoutCatidInput[]
    createMany?: ItemsTBLCreateManyCatidInputEnvelope
    connect?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
  }

  export type ItemsTBLUncheckedCreateNestedManyWithoutCatidInput = {
    create?: XOR<ItemsTBLCreateWithoutCatidInput, ItemsTBLUncheckedCreateWithoutCatidInput> | ItemsTBLCreateWithoutCatidInput[] | ItemsTBLUncheckedCreateWithoutCatidInput[]
    connectOrCreate?: ItemsTBLCreateOrConnectWithoutCatidInput | ItemsTBLCreateOrConnectWithoutCatidInput[]
    createMany?: ItemsTBLCreateManyCatidInputEnvelope
    connect?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
  }

  export type ItemsTBLUpdateManyWithoutCatidNestedInput = {
    create?: XOR<ItemsTBLCreateWithoutCatidInput, ItemsTBLUncheckedCreateWithoutCatidInput> | ItemsTBLCreateWithoutCatidInput[] | ItemsTBLUncheckedCreateWithoutCatidInput[]
    connectOrCreate?: ItemsTBLCreateOrConnectWithoutCatidInput | ItemsTBLCreateOrConnectWithoutCatidInput[]
    upsert?: ItemsTBLUpsertWithWhereUniqueWithoutCatidInput | ItemsTBLUpsertWithWhereUniqueWithoutCatidInput[]
    createMany?: ItemsTBLCreateManyCatidInputEnvelope
    set?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    disconnect?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    delete?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    connect?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    update?: ItemsTBLUpdateWithWhereUniqueWithoutCatidInput | ItemsTBLUpdateWithWhereUniqueWithoutCatidInput[]
    updateMany?: ItemsTBLUpdateManyWithWhereWithoutCatidInput | ItemsTBLUpdateManyWithWhereWithoutCatidInput[]
    deleteMany?: ItemsTBLScalarWhereInput | ItemsTBLScalarWhereInput[]
  }

  export type ItemsTBLUncheckedUpdateManyWithoutCatidNestedInput = {
    create?: XOR<ItemsTBLCreateWithoutCatidInput, ItemsTBLUncheckedCreateWithoutCatidInput> | ItemsTBLCreateWithoutCatidInput[] | ItemsTBLUncheckedCreateWithoutCatidInput[]
    connectOrCreate?: ItemsTBLCreateOrConnectWithoutCatidInput | ItemsTBLCreateOrConnectWithoutCatidInput[]
    upsert?: ItemsTBLUpsertWithWhereUniqueWithoutCatidInput | ItemsTBLUpsertWithWhereUniqueWithoutCatidInput[]
    createMany?: ItemsTBLCreateManyCatidInputEnvelope
    set?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    disconnect?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    delete?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    connect?: ItemsTBLWhereUniqueInput | ItemsTBLWhereUniqueInput[]
    update?: ItemsTBLUpdateWithWhereUniqueWithoutCatidInput | ItemsTBLUpdateWithWhereUniqueWithoutCatidInput[]
    updateMany?: ItemsTBLUpdateManyWithWhereWithoutCatidInput | ItemsTBLUpdateManyWithWhereWithoutCatidInput[]
    deleteMany?: ItemsTBLScalarWhereInput | ItemsTBLScalarWhereInput[]
  }

  export type UsersTBLCreateNestedOneWithoutItemsInput = {
    create?: XOR<UsersTBLCreateWithoutItemsInput, UsersTBLUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UsersTBLCreateOrConnectWithoutItemsInput
    connect?: UsersTBLWhereUniqueInput
  }

  export type CategoriesTblCreateNestedOneWithoutItemInput = {
    create?: XOR<CategoriesTblCreateWithoutItemInput, CategoriesTblUncheckedCreateWithoutItemInput>
    connectOrCreate?: CategoriesTblCreateOrConnectWithoutItemInput
    connect?: CategoriesTblWhereUniqueInput
  }

  export type CartItemsTBLCreateNestedManyWithoutItemidsInput = {
    create?: XOR<CartItemsTBLCreateWithoutItemidsInput, CartItemsTBLUncheckedCreateWithoutItemidsInput> | CartItemsTBLCreateWithoutItemidsInput[] | CartItemsTBLUncheckedCreateWithoutItemidsInput[]
    connectOrCreate?: CartItemsTBLCreateOrConnectWithoutItemidsInput | CartItemsTBLCreateOrConnectWithoutItemidsInput[]
    createMany?: CartItemsTBLCreateManyItemidsInputEnvelope
    connect?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
  }

  export type CartItemsTBLUncheckedCreateNestedManyWithoutItemidsInput = {
    create?: XOR<CartItemsTBLCreateWithoutItemidsInput, CartItemsTBLUncheckedCreateWithoutItemidsInput> | CartItemsTBLCreateWithoutItemidsInput[] | CartItemsTBLUncheckedCreateWithoutItemidsInput[]
    connectOrCreate?: CartItemsTBLCreateOrConnectWithoutItemidsInput | CartItemsTBLCreateOrConnectWithoutItemidsInput[]
    createMany?: CartItemsTBLCreateManyItemidsInputEnvelope
    connect?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
  }

  export type UsersTBLUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<UsersTBLCreateWithoutItemsInput, UsersTBLUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UsersTBLCreateOrConnectWithoutItemsInput
    upsert?: UsersTBLUpsertWithoutItemsInput
    connect?: UsersTBLWhereUniqueInput
    update?: XOR<XOR<UsersTBLUpdateToOneWithWhereWithoutItemsInput, UsersTBLUpdateWithoutItemsInput>, UsersTBLUncheckedUpdateWithoutItemsInput>
  }

  export type CategoriesTblUpdateOneRequiredWithoutItemNestedInput = {
    create?: XOR<CategoriesTblCreateWithoutItemInput, CategoriesTblUncheckedCreateWithoutItemInput>
    connectOrCreate?: CategoriesTblCreateOrConnectWithoutItemInput
    upsert?: CategoriesTblUpsertWithoutItemInput
    connect?: CategoriesTblWhereUniqueInput
    update?: XOR<XOR<CategoriesTblUpdateToOneWithWhereWithoutItemInput, CategoriesTblUpdateWithoutItemInput>, CategoriesTblUncheckedUpdateWithoutItemInput>
  }

  export type CartItemsTBLUpdateManyWithoutItemidsNestedInput = {
    create?: XOR<CartItemsTBLCreateWithoutItemidsInput, CartItemsTBLUncheckedCreateWithoutItemidsInput> | CartItemsTBLCreateWithoutItemidsInput[] | CartItemsTBLUncheckedCreateWithoutItemidsInput[]
    connectOrCreate?: CartItemsTBLCreateOrConnectWithoutItemidsInput | CartItemsTBLCreateOrConnectWithoutItemidsInput[]
    upsert?: CartItemsTBLUpsertWithWhereUniqueWithoutItemidsInput | CartItemsTBLUpsertWithWhereUniqueWithoutItemidsInput[]
    createMany?: CartItemsTBLCreateManyItemidsInputEnvelope
    set?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    disconnect?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    delete?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    connect?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    update?: CartItemsTBLUpdateWithWhereUniqueWithoutItemidsInput | CartItemsTBLUpdateWithWhereUniqueWithoutItemidsInput[]
    updateMany?: CartItemsTBLUpdateManyWithWhereWithoutItemidsInput | CartItemsTBLUpdateManyWithWhereWithoutItemidsInput[]
    deleteMany?: CartItemsTBLScalarWhereInput | CartItemsTBLScalarWhereInput[]
  }

  export type CartItemsTBLUncheckedUpdateManyWithoutItemidsNestedInput = {
    create?: XOR<CartItemsTBLCreateWithoutItemidsInput, CartItemsTBLUncheckedCreateWithoutItemidsInput> | CartItemsTBLCreateWithoutItemidsInput[] | CartItemsTBLUncheckedCreateWithoutItemidsInput[]
    connectOrCreate?: CartItemsTBLCreateOrConnectWithoutItemidsInput | CartItemsTBLCreateOrConnectWithoutItemidsInput[]
    upsert?: CartItemsTBLUpsertWithWhereUniqueWithoutItemidsInput | CartItemsTBLUpsertWithWhereUniqueWithoutItemidsInput[]
    createMany?: CartItemsTBLCreateManyItemidsInputEnvelope
    set?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    disconnect?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    delete?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    connect?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    update?: CartItemsTBLUpdateWithWhereUniqueWithoutItemidsInput | CartItemsTBLUpdateWithWhereUniqueWithoutItemidsInput[]
    updateMany?: CartItemsTBLUpdateManyWithWhereWithoutItemidsInput | CartItemsTBLUpdateManyWithWhereWithoutItemidsInput[]
    deleteMany?: CartItemsTBLScalarWhereInput | CartItemsTBLScalarWhereInput[]
  }

  export type EmployeeTBLCreateNestedOneWithoutOrdersTBLInput = {
    create?: XOR<EmployeeTBLCreateWithoutOrdersTBLInput, EmployeeTBLUncheckedCreateWithoutOrdersTBLInput>
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutOrdersTBLInput
    connect?: EmployeeTBLWhereUniqueInput
  }

  export type OrderItemsTBLCreateNestedManyWithoutOrdersidInput = {
    create?: XOR<OrderItemsTBLCreateWithoutOrdersidInput, OrderItemsTBLUncheckedCreateWithoutOrdersidInput> | OrderItemsTBLCreateWithoutOrdersidInput[] | OrderItemsTBLUncheckedCreateWithoutOrdersidInput[]
    connectOrCreate?: OrderItemsTBLCreateOrConnectWithoutOrdersidInput | OrderItemsTBLCreateOrConnectWithoutOrdersidInput[]
    createMany?: OrderItemsTBLCreateManyOrdersidInputEnvelope
    connect?: OrderItemsTBLWhereUniqueInput | OrderItemsTBLWhereUniqueInput[]
  }

  export type OrderItemsTBLUncheckedCreateNestedManyWithoutOrdersidInput = {
    create?: XOR<OrderItemsTBLCreateWithoutOrdersidInput, OrderItemsTBLUncheckedCreateWithoutOrdersidInput> | OrderItemsTBLCreateWithoutOrdersidInput[] | OrderItemsTBLUncheckedCreateWithoutOrdersidInput[]
    connectOrCreate?: OrderItemsTBLCreateOrConnectWithoutOrdersidInput | OrderItemsTBLCreateOrConnectWithoutOrdersidInput[]
    createMany?: OrderItemsTBLCreateManyOrdersidInputEnvelope
    connect?: OrderItemsTBLWhereUniqueInput | OrderItemsTBLWhereUniqueInput[]
  }

  export type EmployeeTBLUpdateOneRequiredWithoutOrdersTBLNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutOrdersTBLInput, EmployeeTBLUncheckedCreateWithoutOrdersTBLInput>
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutOrdersTBLInput
    upsert?: EmployeeTBLUpsertWithoutOrdersTBLInput
    connect?: EmployeeTBLWhereUniqueInput
    update?: XOR<XOR<EmployeeTBLUpdateToOneWithWhereWithoutOrdersTBLInput, EmployeeTBLUpdateWithoutOrdersTBLInput>, EmployeeTBLUncheckedUpdateWithoutOrdersTBLInput>
  }

  export type OrderItemsTBLUpdateManyWithoutOrdersidNestedInput = {
    create?: XOR<OrderItemsTBLCreateWithoutOrdersidInput, OrderItemsTBLUncheckedCreateWithoutOrdersidInput> | OrderItemsTBLCreateWithoutOrdersidInput[] | OrderItemsTBLUncheckedCreateWithoutOrdersidInput[]
    connectOrCreate?: OrderItemsTBLCreateOrConnectWithoutOrdersidInput | OrderItemsTBLCreateOrConnectWithoutOrdersidInput[]
    upsert?: OrderItemsTBLUpsertWithWhereUniqueWithoutOrdersidInput | OrderItemsTBLUpsertWithWhereUniqueWithoutOrdersidInput[]
    createMany?: OrderItemsTBLCreateManyOrdersidInputEnvelope
    set?: OrderItemsTBLWhereUniqueInput | OrderItemsTBLWhereUniqueInput[]
    disconnect?: OrderItemsTBLWhereUniqueInput | OrderItemsTBLWhereUniqueInput[]
    delete?: OrderItemsTBLWhereUniqueInput | OrderItemsTBLWhereUniqueInput[]
    connect?: OrderItemsTBLWhereUniqueInput | OrderItemsTBLWhereUniqueInput[]
    update?: OrderItemsTBLUpdateWithWhereUniqueWithoutOrdersidInput | OrderItemsTBLUpdateWithWhereUniqueWithoutOrdersidInput[]
    updateMany?: OrderItemsTBLUpdateManyWithWhereWithoutOrdersidInput | OrderItemsTBLUpdateManyWithWhereWithoutOrdersidInput[]
    deleteMany?: OrderItemsTBLScalarWhereInput | OrderItemsTBLScalarWhereInput[]
  }

  export type OrderItemsTBLUncheckedUpdateManyWithoutOrdersidNestedInput = {
    create?: XOR<OrderItemsTBLCreateWithoutOrdersidInput, OrderItemsTBLUncheckedCreateWithoutOrdersidInput> | OrderItemsTBLCreateWithoutOrdersidInput[] | OrderItemsTBLUncheckedCreateWithoutOrdersidInput[]
    connectOrCreate?: OrderItemsTBLCreateOrConnectWithoutOrdersidInput | OrderItemsTBLCreateOrConnectWithoutOrdersidInput[]
    upsert?: OrderItemsTBLUpsertWithWhereUniqueWithoutOrdersidInput | OrderItemsTBLUpsertWithWhereUniqueWithoutOrdersidInput[]
    createMany?: OrderItemsTBLCreateManyOrdersidInputEnvelope
    set?: OrderItemsTBLWhereUniqueInput | OrderItemsTBLWhereUniqueInput[]
    disconnect?: OrderItemsTBLWhereUniqueInput | OrderItemsTBLWhereUniqueInput[]
    delete?: OrderItemsTBLWhereUniqueInput | OrderItemsTBLWhereUniqueInput[]
    connect?: OrderItemsTBLWhereUniqueInput | OrderItemsTBLWhereUniqueInput[]
    update?: OrderItemsTBLUpdateWithWhereUniqueWithoutOrdersidInput | OrderItemsTBLUpdateWithWhereUniqueWithoutOrdersidInput[]
    updateMany?: OrderItemsTBLUpdateManyWithWhereWithoutOrdersidInput | OrderItemsTBLUpdateManyWithWhereWithoutOrdersidInput[]
    deleteMany?: OrderItemsTBLScalarWhereInput | OrderItemsTBLScalarWhereInput[]
  }

  export type OrdersTBLCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrdersTBLCreateWithoutOrderItemsInput, OrdersTBLUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrdersTBLCreateOrConnectWithoutOrderItemsInput
    connect?: OrdersTBLWhereUniqueInput
  }

  export type OrdersTBLUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<OrdersTBLCreateWithoutOrderItemsInput, OrdersTBLUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrdersTBLCreateOrConnectWithoutOrderItemsInput
    upsert?: OrdersTBLUpsertWithoutOrderItemsInput
    connect?: OrdersTBLWhereUniqueInput
    update?: XOR<XOR<OrdersTBLUpdateToOneWithWhereWithoutOrderItemsInput, OrdersTBLUpdateWithoutOrderItemsInput>, OrdersTBLUncheckedUpdateWithoutOrderItemsInput>
  }

  export type EmployeeTBLCreateNestedOneWithoutCartInput = {
    create?: XOR<EmployeeTBLCreateWithoutCartInput, EmployeeTBLUncheckedCreateWithoutCartInput>
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutCartInput
    connect?: EmployeeTBLWhereUniqueInput
  }

  export type CartItemsTBLCreateNestedManyWithoutCarttidInput = {
    create?: XOR<CartItemsTBLCreateWithoutCarttidInput, CartItemsTBLUncheckedCreateWithoutCarttidInput> | CartItemsTBLCreateWithoutCarttidInput[] | CartItemsTBLUncheckedCreateWithoutCarttidInput[]
    connectOrCreate?: CartItemsTBLCreateOrConnectWithoutCarttidInput | CartItemsTBLCreateOrConnectWithoutCarttidInput[]
    createMany?: CartItemsTBLCreateManyCarttidInputEnvelope
    connect?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
  }

  export type CartItemsTBLUncheckedCreateNestedManyWithoutCarttidInput = {
    create?: XOR<CartItemsTBLCreateWithoutCarttidInput, CartItemsTBLUncheckedCreateWithoutCarttidInput> | CartItemsTBLCreateWithoutCarttidInput[] | CartItemsTBLUncheckedCreateWithoutCarttidInput[]
    connectOrCreate?: CartItemsTBLCreateOrConnectWithoutCarttidInput | CartItemsTBLCreateOrConnectWithoutCarttidInput[]
    createMany?: CartItemsTBLCreateManyCarttidInputEnvelope
    connect?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
  }

  export type EmployeeTBLUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<EmployeeTBLCreateWithoutCartInput, EmployeeTBLUncheckedCreateWithoutCartInput>
    connectOrCreate?: EmployeeTBLCreateOrConnectWithoutCartInput
    upsert?: EmployeeTBLUpsertWithoutCartInput
    connect?: EmployeeTBLWhereUniqueInput
    update?: XOR<XOR<EmployeeTBLUpdateToOneWithWhereWithoutCartInput, EmployeeTBLUpdateWithoutCartInput>, EmployeeTBLUncheckedUpdateWithoutCartInput>
  }

  export type CartItemsTBLUpdateManyWithoutCarttidNestedInput = {
    create?: XOR<CartItemsTBLCreateWithoutCarttidInput, CartItemsTBLUncheckedCreateWithoutCarttidInput> | CartItemsTBLCreateWithoutCarttidInput[] | CartItemsTBLUncheckedCreateWithoutCarttidInput[]
    connectOrCreate?: CartItemsTBLCreateOrConnectWithoutCarttidInput | CartItemsTBLCreateOrConnectWithoutCarttidInput[]
    upsert?: CartItemsTBLUpsertWithWhereUniqueWithoutCarttidInput | CartItemsTBLUpsertWithWhereUniqueWithoutCarttidInput[]
    createMany?: CartItemsTBLCreateManyCarttidInputEnvelope
    set?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    disconnect?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    delete?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    connect?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    update?: CartItemsTBLUpdateWithWhereUniqueWithoutCarttidInput | CartItemsTBLUpdateWithWhereUniqueWithoutCarttidInput[]
    updateMany?: CartItemsTBLUpdateManyWithWhereWithoutCarttidInput | CartItemsTBLUpdateManyWithWhereWithoutCarttidInput[]
    deleteMany?: CartItemsTBLScalarWhereInput | CartItemsTBLScalarWhereInput[]
  }

  export type CartItemsTBLUncheckedUpdateManyWithoutCarttidNestedInput = {
    create?: XOR<CartItemsTBLCreateWithoutCarttidInput, CartItemsTBLUncheckedCreateWithoutCarttidInput> | CartItemsTBLCreateWithoutCarttidInput[] | CartItemsTBLUncheckedCreateWithoutCarttidInput[]
    connectOrCreate?: CartItemsTBLCreateOrConnectWithoutCarttidInput | CartItemsTBLCreateOrConnectWithoutCarttidInput[]
    upsert?: CartItemsTBLUpsertWithWhereUniqueWithoutCarttidInput | CartItemsTBLUpsertWithWhereUniqueWithoutCarttidInput[]
    createMany?: CartItemsTBLCreateManyCarttidInputEnvelope
    set?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    disconnect?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    delete?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    connect?: CartItemsTBLWhereUniqueInput | CartItemsTBLWhereUniqueInput[]
    update?: CartItemsTBLUpdateWithWhereUniqueWithoutCarttidInput | CartItemsTBLUpdateWithWhereUniqueWithoutCarttidInput[]
    updateMany?: CartItemsTBLUpdateManyWithWhereWithoutCarttidInput | CartItemsTBLUpdateManyWithWhereWithoutCarttidInput[]
    deleteMany?: CartItemsTBLScalarWhereInput | CartItemsTBLScalarWhereInput[]
  }

  export type CartTBLCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<CartTBLCreateWithoutCartItemsInput, CartTBLUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: CartTBLCreateOrConnectWithoutCartItemsInput
    connect?: CartTBLWhereUniqueInput
  }

  export type ItemsTBLCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<ItemsTBLCreateWithoutCartItemsInput, ItemsTBLUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ItemsTBLCreateOrConnectWithoutCartItemsInput
    connect?: ItemsTBLWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CartTBLUpdateOneWithoutCartItemsNestedInput = {
    create?: XOR<CartTBLCreateWithoutCartItemsInput, CartTBLUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: CartTBLCreateOrConnectWithoutCartItemsInput
    upsert?: CartTBLUpsertWithoutCartItemsInput
    disconnect?: CartTBLWhereInput | boolean
    delete?: CartTBLWhereInput | boolean
    connect?: CartTBLWhereUniqueInput
    update?: XOR<XOR<CartTBLUpdateToOneWithWhereWithoutCartItemsInput, CartTBLUpdateWithoutCartItemsInput>, CartTBLUncheckedUpdateWithoutCartItemsInput>
  }

  export type ItemsTBLUpdateOneRequiredWithoutCartItemsNestedInput = {
    create?: XOR<ItemsTBLCreateWithoutCartItemsInput, ItemsTBLUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ItemsTBLCreateOrConnectWithoutCartItemsInput
    upsert?: ItemsTBLUpsertWithoutCartItemsInput
    connect?: ItemsTBLWhereUniqueInput
    update?: XOR<XOR<ItemsTBLUpdateToOneWithWhereWithoutCartItemsInput, ItemsTBLUpdateWithoutCartItemsInput>, ItemsTBLUncheckedUpdateWithoutCartItemsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UsersTBLCreateWithoutTokensInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    role: string
    Employee?: EmployeeTBLCreateNestedManyWithoutEmpInput
    Items?: ItemsTBLCreateNestedManyWithoutCreatorInput
    Officeboy?: OfficeBoyTBLCreateNestedManyWithoutOfficeboyInput
  }

  export type UsersTBLUncheckedCreateWithoutTokensInput = {
    userid?: number
    firstname: string
    lastname: string
    email: string
    password: string
    role: string
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutEmpInput
    Items?: ItemsTBLUncheckedCreateNestedManyWithoutCreatorInput
    Officeboy?: OfficeBoyTBLUncheckedCreateNestedManyWithoutOfficeboyInput
  }

  export type UsersTBLCreateOrConnectWithoutTokensInput = {
    where: UsersTBLWhereUniqueInput
    create: XOR<UsersTBLCreateWithoutTokensInput, UsersTBLUncheckedCreateWithoutTokensInput>
  }

  export type UsersTBLUpsertWithoutTokensInput = {
    update: XOR<UsersTBLUpdateWithoutTokensInput, UsersTBLUncheckedUpdateWithoutTokensInput>
    create: XOR<UsersTBLCreateWithoutTokensInput, UsersTBLUncheckedCreateWithoutTokensInput>
    where?: UsersTBLWhereInput
  }

  export type UsersTBLUpdateToOneWithWhereWithoutTokensInput = {
    where?: UsersTBLWhereInput
    data: XOR<UsersTBLUpdateWithoutTokensInput, UsersTBLUncheckedUpdateWithoutTokensInput>
  }

  export type UsersTBLUpdateWithoutTokensInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUpdateManyWithoutEmpNestedInput
    Items?: ItemsTBLUpdateManyWithoutCreatorNestedInput
    Officeboy?: OfficeBoyTBLUpdateManyWithoutOfficeboyNestedInput
  }

  export type UsersTBLUncheckedUpdateWithoutTokensInput = {
    userid?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutEmpNestedInput
    Items?: ItemsTBLUncheckedUpdateManyWithoutCreatorNestedInput
    Officeboy?: OfficeBoyTBLUncheckedUpdateManyWithoutOfficeboyNestedInput
  }

  export type EmployeeTBLCreateWithoutEmpInput = {
    romid: RoomTBLCreateNestedOneWithoutEmployeeInput
    offid: OfficeTBLCreateNestedOneWithoutEmployeeInput
    sitid: SiteTBLCreateNestedOneWithoutEmployeeInput
    bulidingref: BuildingTBLCreateNestedOneWithoutEmployeeInput
    departmentref: DepartmentTBLCreateNestedOneWithoutEmployeeInput
    Cart?: CartTBLCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLUncheckedCreateWithoutEmpInput = {
    roomid: number
    officeid: number
    siteid: number
    buildingid: number
    departmentid: number
    Cart?: CartTBLUncheckedCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLUncheckedCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLCreateOrConnectWithoutEmpInput = {
    where: EmployeeTBLWhereUniqueInput
    create: XOR<EmployeeTBLCreateWithoutEmpInput, EmployeeTBLUncheckedCreateWithoutEmpInput>
  }

  export type EmployeeTBLCreateManyEmpInputEnvelope = {
    data: EmployeeTBLCreateManyEmpInput | EmployeeTBLCreateManyEmpInput[]
    skipDuplicates?: boolean
  }

  export type ItemsTBLCreateWithoutCreatorInput = {
    itemname: string
    itemimagurl: string
    itemidescription: string
    catid: CategoriesTblCreateNestedOneWithoutItemInput
    CartItems?: CartItemsTBLCreateNestedManyWithoutItemidsInput
  }

  export type ItemsTBLUncheckedCreateWithoutCreatorInput = {
    itemid?: number
    categoryid: number
    itemname: string
    itemimagurl: string
    itemidescription: string
    CartItems?: CartItemsTBLUncheckedCreateNestedManyWithoutItemidsInput
  }

  export type ItemsTBLCreateOrConnectWithoutCreatorInput = {
    where: ItemsTBLWhereUniqueInput
    create: XOR<ItemsTBLCreateWithoutCreatorInput, ItemsTBLUncheckedCreateWithoutCreatorInput>
  }

  export type ItemsTBLCreateManyCreatorInputEnvelope = {
    data: ItemsTBLCreateManyCreatorInput | ItemsTBLCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type TokensTBLCreateWithoutReftokenInput = {
    refreshtoken: string
  }

  export type TokensTBLUncheckedCreateWithoutReftokenInput = {
    tokenid?: number
    refreshtoken: string
  }

  export type TokensTBLCreateOrConnectWithoutReftokenInput = {
    where: TokensTBLWhereUniqueInput
    create: XOR<TokensTBLCreateWithoutReftokenInput, TokensTBLUncheckedCreateWithoutReftokenInput>
  }

  export type TokensTBLCreateManyReftokenInputEnvelope = {
    data: TokensTBLCreateManyReftokenInput | TokensTBLCreateManyReftokenInput[]
    skipDuplicates?: boolean
  }

  export type OfficeBoyTBLCreateWithoutOfficeboyInput = {
    offid: OfficeTBLCreateNestedOneWithoutOfficeboyInput
    siteref: SiteTBLCreateNestedOneWithoutOfficeboyInput
  }

  export type OfficeBoyTBLUncheckedCreateWithoutOfficeboyInput = {
    officeid: number
    siteid: number
  }

  export type OfficeBoyTBLCreateOrConnectWithoutOfficeboyInput = {
    where: OfficeBoyTBLWhereUniqueInput
    create: XOR<OfficeBoyTBLCreateWithoutOfficeboyInput, OfficeBoyTBLUncheckedCreateWithoutOfficeboyInput>
  }

  export type OfficeBoyTBLCreateManyOfficeboyInputEnvelope = {
    data: OfficeBoyTBLCreateManyOfficeboyInput | OfficeBoyTBLCreateManyOfficeboyInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTBLUpsertWithWhereUniqueWithoutEmpInput = {
    where: EmployeeTBLWhereUniqueInput
    update: XOR<EmployeeTBLUpdateWithoutEmpInput, EmployeeTBLUncheckedUpdateWithoutEmpInput>
    create: XOR<EmployeeTBLCreateWithoutEmpInput, EmployeeTBLUncheckedCreateWithoutEmpInput>
  }

  export type EmployeeTBLUpdateWithWhereUniqueWithoutEmpInput = {
    where: EmployeeTBLWhereUniqueInput
    data: XOR<EmployeeTBLUpdateWithoutEmpInput, EmployeeTBLUncheckedUpdateWithoutEmpInput>
  }

  export type EmployeeTBLUpdateManyWithWhereWithoutEmpInput = {
    where: EmployeeTBLScalarWhereInput
    data: XOR<EmployeeTBLUpdateManyMutationInput, EmployeeTBLUncheckedUpdateManyWithoutEmpInput>
  }

  export type EmployeeTBLScalarWhereInput = {
    AND?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
    OR?: EmployeeTBLScalarWhereInput[]
    NOT?: EmployeeTBLScalarWhereInput | EmployeeTBLScalarWhereInput[]
    empid?: IntFilter<"EmployeeTBL"> | number
    roomid?: IntFilter<"EmployeeTBL"> | number
    officeid?: IntFilter<"EmployeeTBL"> | number
    siteid?: IntFilter<"EmployeeTBL"> | number
    buildingid?: IntFilter<"EmployeeTBL"> | number
    departmentid?: IntFilter<"EmployeeTBL"> | number
  }

  export type ItemsTBLUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ItemsTBLWhereUniqueInput
    update: XOR<ItemsTBLUpdateWithoutCreatorInput, ItemsTBLUncheckedUpdateWithoutCreatorInput>
    create: XOR<ItemsTBLCreateWithoutCreatorInput, ItemsTBLUncheckedCreateWithoutCreatorInput>
  }

  export type ItemsTBLUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ItemsTBLWhereUniqueInput
    data: XOR<ItemsTBLUpdateWithoutCreatorInput, ItemsTBLUncheckedUpdateWithoutCreatorInput>
  }

  export type ItemsTBLUpdateManyWithWhereWithoutCreatorInput = {
    where: ItemsTBLScalarWhereInput
    data: XOR<ItemsTBLUpdateManyMutationInput, ItemsTBLUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ItemsTBLScalarWhereInput = {
    AND?: ItemsTBLScalarWhereInput | ItemsTBLScalarWhereInput[]
    OR?: ItemsTBLScalarWhereInput[]
    NOT?: ItemsTBLScalarWhereInput | ItemsTBLScalarWhereInput[]
    userid?: IntFilter<"ItemsTBL"> | number
    itemid?: IntFilter<"ItemsTBL"> | number
    categoryid?: IntFilter<"ItemsTBL"> | number
    itemname?: StringFilter<"ItemsTBL"> | string
    itemimagurl?: StringFilter<"ItemsTBL"> | string
    itemidescription?: StringFilter<"ItemsTBL"> | string
  }

  export type TokensTBLUpsertWithWhereUniqueWithoutReftokenInput = {
    where: TokensTBLWhereUniqueInput
    update: XOR<TokensTBLUpdateWithoutReftokenInput, TokensTBLUncheckedUpdateWithoutReftokenInput>
    create: XOR<TokensTBLCreateWithoutReftokenInput, TokensTBLUncheckedCreateWithoutReftokenInput>
  }

  export type TokensTBLUpdateWithWhereUniqueWithoutReftokenInput = {
    where: TokensTBLWhereUniqueInput
    data: XOR<TokensTBLUpdateWithoutReftokenInput, TokensTBLUncheckedUpdateWithoutReftokenInput>
  }

  export type TokensTBLUpdateManyWithWhereWithoutReftokenInput = {
    where: TokensTBLScalarWhereInput
    data: XOR<TokensTBLUpdateManyMutationInput, TokensTBLUncheckedUpdateManyWithoutReftokenInput>
  }

  export type TokensTBLScalarWhereInput = {
    AND?: TokensTBLScalarWhereInput | TokensTBLScalarWhereInput[]
    OR?: TokensTBLScalarWhereInput[]
    NOT?: TokensTBLScalarWhereInput | TokensTBLScalarWhereInput[]
    tokenid?: IntFilter<"TokensTBL"> | number
    refreshtoken?: StringFilter<"TokensTBL"> | string
    userid?: IntFilter<"TokensTBL"> | number
  }

  export type OfficeBoyTBLUpsertWithWhereUniqueWithoutOfficeboyInput = {
    where: OfficeBoyTBLWhereUniqueInput
    update: XOR<OfficeBoyTBLUpdateWithoutOfficeboyInput, OfficeBoyTBLUncheckedUpdateWithoutOfficeboyInput>
    create: XOR<OfficeBoyTBLCreateWithoutOfficeboyInput, OfficeBoyTBLUncheckedCreateWithoutOfficeboyInput>
  }

  export type OfficeBoyTBLUpdateWithWhereUniqueWithoutOfficeboyInput = {
    where: OfficeBoyTBLWhereUniqueInput
    data: XOR<OfficeBoyTBLUpdateWithoutOfficeboyInput, OfficeBoyTBLUncheckedUpdateWithoutOfficeboyInput>
  }

  export type OfficeBoyTBLUpdateManyWithWhereWithoutOfficeboyInput = {
    where: OfficeBoyTBLScalarWhereInput
    data: XOR<OfficeBoyTBLUpdateManyMutationInput, OfficeBoyTBLUncheckedUpdateManyWithoutOfficeboyInput>
  }

  export type OfficeBoyTBLScalarWhereInput = {
    AND?: OfficeBoyTBLScalarWhereInput | OfficeBoyTBLScalarWhereInput[]
    OR?: OfficeBoyTBLScalarWhereInput[]
    NOT?: OfficeBoyTBLScalarWhereInput | OfficeBoyTBLScalarWhereInput[]
    officeboyid?: IntFilter<"OfficeBoyTBL"> | number
    officeid?: IntFilter<"OfficeBoyTBL"> | number
    siteid?: IntFilter<"OfficeBoyTBL"> | number
  }

  export type UsersTBLCreateWithoutEmployeeInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    role: string
    Items?: ItemsTBLCreateNestedManyWithoutCreatorInput
    Tokens?: TokensTBLCreateNestedManyWithoutReftokenInput
    Officeboy?: OfficeBoyTBLCreateNestedManyWithoutOfficeboyInput
  }

  export type UsersTBLUncheckedCreateWithoutEmployeeInput = {
    userid?: number
    firstname: string
    lastname: string
    email: string
    password: string
    role: string
    Items?: ItemsTBLUncheckedCreateNestedManyWithoutCreatorInput
    Tokens?: TokensTBLUncheckedCreateNestedManyWithoutReftokenInput
    Officeboy?: OfficeBoyTBLUncheckedCreateNestedManyWithoutOfficeboyInput
  }

  export type UsersTBLCreateOrConnectWithoutEmployeeInput = {
    where: UsersTBLWhereUniqueInput
    create: XOR<UsersTBLCreateWithoutEmployeeInput, UsersTBLUncheckedCreateWithoutEmployeeInput>
  }

  export type RoomTBLCreateWithoutEmployeeInput = {
    roomno: number
    roomname: string
    officeref: OfficeTBLCreateNestedOneWithoutRoomInput
    roomdepref: DepartmentTBLCreateNestedOneWithoutRoomInput
  }

  export type RoomTBLUncheckedCreateWithoutEmployeeInput = {
    roomid?: number
    roomno: number
    roomname: string
    officeid: number
    departmentid: number
  }

  export type RoomTBLCreateOrConnectWithoutEmployeeInput = {
    where: RoomTBLWhereUniqueInput
    create: XOR<RoomTBLCreateWithoutEmployeeInput, RoomTBLUncheckedCreateWithoutEmployeeInput>
  }

  export type OfficeTBLCreateWithoutEmployeeInput = {
    officeno: number
    Officeboy?: OfficeBoyTBLCreateNestedManyWithoutOffidInput
    bulidingref: BuildingTBLCreateNestedOneWithoutOfficeInput
    Room?: RoomTBLCreateNestedManyWithoutOfficerefInput
  }

  export type OfficeTBLUncheckedCreateWithoutEmployeeInput = {
    officeid?: number
    officeno: number
    buildingid: number
    Officeboy?: OfficeBoyTBLUncheckedCreateNestedManyWithoutOffidInput
    Room?: RoomTBLUncheckedCreateNestedManyWithoutOfficerefInput
  }

  export type OfficeTBLCreateOrConnectWithoutEmployeeInput = {
    where: OfficeTBLWhereUniqueInput
    create: XOR<OfficeTBLCreateWithoutEmployeeInput, OfficeTBLUncheckedCreateWithoutEmployeeInput>
  }

  export type SiteTBLCreateWithoutEmployeeInput = {
    sitename: string
    Building?: BuildingTBLCreateNestedManyWithoutSiterefInput
    Officeboy?: OfficeBoyTBLCreateNestedManyWithoutSiterefInput
  }

  export type SiteTBLUncheckedCreateWithoutEmployeeInput = {
    siteid?: number
    sitename: string
    Building?: BuildingTBLUncheckedCreateNestedManyWithoutSiterefInput
    Officeboy?: OfficeBoyTBLUncheckedCreateNestedManyWithoutSiterefInput
  }

  export type SiteTBLCreateOrConnectWithoutEmployeeInput = {
    where: SiteTBLWhereUniqueInput
    create: XOR<SiteTBLCreateWithoutEmployeeInput, SiteTBLUncheckedCreateWithoutEmployeeInput>
  }

  export type BuildingTBLCreateWithoutEmployeeInput = {
    buildingname: string
    siteref: SiteTBLCreateNestedOneWithoutBuildingInput
    Department?: DepartmentTBLCreateNestedManyWithoutBulidingrefInput
    Office?: OfficeTBLCreateNestedManyWithoutBulidingrefInput
  }

  export type BuildingTBLUncheckedCreateWithoutEmployeeInput = {
    buildingid?: number
    buildingname: string
    siteid: number
    Department?: DepartmentTBLUncheckedCreateNestedManyWithoutBulidingrefInput
    Office?: OfficeTBLUncheckedCreateNestedManyWithoutBulidingrefInput
  }

  export type BuildingTBLCreateOrConnectWithoutEmployeeInput = {
    where: BuildingTBLWhereUniqueInput
    create: XOR<BuildingTBLCreateWithoutEmployeeInput, BuildingTBLUncheckedCreateWithoutEmployeeInput>
  }

  export type DepartmentTBLCreateWithoutEmployeeInput = {
    departmentname: string
    Room?: RoomTBLCreateNestedManyWithoutRoomdeprefInput
    bulidingref: BuildingTBLCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentTBLUncheckedCreateWithoutEmployeeInput = {
    departmentid?: number
    departmentname: string
    buildingid: number
    Room?: RoomTBLUncheckedCreateNestedManyWithoutRoomdeprefInput
  }

  export type DepartmentTBLCreateOrConnectWithoutEmployeeInput = {
    where: DepartmentTBLWhereUniqueInput
    create: XOR<DepartmentTBLCreateWithoutEmployeeInput, DepartmentTBLUncheckedCreateWithoutEmployeeInput>
  }

  export type CartTBLCreateWithoutEmployeeidInput = {
    CartItems?: CartItemsTBLCreateNestedManyWithoutCarttidInput
  }

  export type CartTBLUncheckedCreateWithoutEmployeeidInput = {
    cartid?: number
    CartItems?: CartItemsTBLUncheckedCreateNestedManyWithoutCarttidInput
  }

  export type CartTBLCreateOrConnectWithoutEmployeeidInput = {
    where: CartTBLWhereUniqueInput
    create: XOR<CartTBLCreateWithoutEmployeeidInput, CartTBLUncheckedCreateWithoutEmployeeidInput>
  }

  export type CartTBLCreateManyEmployeeidInputEnvelope = {
    data: CartTBLCreateManyEmployeeidInput | CartTBLCreateManyEmployeeidInput[]
    skipDuplicates?: boolean
  }

  export type OrdersTBLCreateWithoutEmprefInput = {
    orderItems?: OrderItemsTBLCreateNestedManyWithoutOrdersidInput
  }

  export type OrdersTBLUncheckedCreateWithoutEmprefInput = {
    orderid?: number
    orderItems?: OrderItemsTBLUncheckedCreateNestedManyWithoutOrdersidInput
  }

  export type OrdersTBLCreateOrConnectWithoutEmprefInput = {
    where: OrdersTBLWhereUniqueInput
    create: XOR<OrdersTBLCreateWithoutEmprefInput, OrdersTBLUncheckedCreateWithoutEmprefInput>
  }

  export type OrdersTBLCreateManyEmprefInputEnvelope = {
    data: OrdersTBLCreateManyEmprefInput | OrdersTBLCreateManyEmprefInput[]
    skipDuplicates?: boolean
  }

  export type UsersTBLUpsertWithoutEmployeeInput = {
    update: XOR<UsersTBLUpdateWithoutEmployeeInput, UsersTBLUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UsersTBLCreateWithoutEmployeeInput, UsersTBLUncheckedCreateWithoutEmployeeInput>
    where?: UsersTBLWhereInput
  }

  export type UsersTBLUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UsersTBLWhereInput
    data: XOR<UsersTBLUpdateWithoutEmployeeInput, UsersTBLUncheckedUpdateWithoutEmployeeInput>
  }

  export type UsersTBLUpdateWithoutEmployeeInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Items?: ItemsTBLUpdateManyWithoutCreatorNestedInput
    Tokens?: TokensTBLUpdateManyWithoutReftokenNestedInput
    Officeboy?: OfficeBoyTBLUpdateManyWithoutOfficeboyNestedInput
  }

  export type UsersTBLUncheckedUpdateWithoutEmployeeInput = {
    userid?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Items?: ItemsTBLUncheckedUpdateManyWithoutCreatorNestedInput
    Tokens?: TokensTBLUncheckedUpdateManyWithoutReftokenNestedInput
    Officeboy?: OfficeBoyTBLUncheckedUpdateManyWithoutOfficeboyNestedInput
  }

  export type RoomTBLUpsertWithoutEmployeeInput = {
    update: XOR<RoomTBLUpdateWithoutEmployeeInput, RoomTBLUncheckedUpdateWithoutEmployeeInput>
    create: XOR<RoomTBLCreateWithoutEmployeeInput, RoomTBLUncheckedCreateWithoutEmployeeInput>
    where?: RoomTBLWhereInput
  }

  export type RoomTBLUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: RoomTBLWhereInput
    data: XOR<RoomTBLUpdateWithoutEmployeeInput, RoomTBLUncheckedUpdateWithoutEmployeeInput>
  }

  export type RoomTBLUpdateWithoutEmployeeInput = {
    roomno?: IntFieldUpdateOperationsInput | number
    roomname?: StringFieldUpdateOperationsInput | string
    officeref?: OfficeTBLUpdateOneRequiredWithoutRoomNestedInput
    roomdepref?: DepartmentTBLUpdateOneRequiredWithoutRoomNestedInput
  }

  export type RoomTBLUncheckedUpdateWithoutEmployeeInput = {
    roomid?: IntFieldUpdateOperationsInput | number
    roomno?: IntFieldUpdateOperationsInput | number
    roomname?: StringFieldUpdateOperationsInput | string
    officeid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
  }

  export type OfficeTBLUpsertWithoutEmployeeInput = {
    update: XOR<OfficeTBLUpdateWithoutEmployeeInput, OfficeTBLUncheckedUpdateWithoutEmployeeInput>
    create: XOR<OfficeTBLCreateWithoutEmployeeInput, OfficeTBLUncheckedCreateWithoutEmployeeInput>
    where?: OfficeTBLWhereInput
  }

  export type OfficeTBLUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: OfficeTBLWhereInput
    data: XOR<OfficeTBLUpdateWithoutEmployeeInput, OfficeTBLUncheckedUpdateWithoutEmployeeInput>
  }

  export type OfficeTBLUpdateWithoutEmployeeInput = {
    officeno?: IntFieldUpdateOperationsInput | number
    Officeboy?: OfficeBoyTBLUpdateManyWithoutOffidNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutOfficeNestedInput
    Room?: RoomTBLUpdateManyWithoutOfficerefNestedInput
  }

  export type OfficeTBLUncheckedUpdateWithoutEmployeeInput = {
    officeid?: IntFieldUpdateOperationsInput | number
    officeno?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    Officeboy?: OfficeBoyTBLUncheckedUpdateManyWithoutOffidNestedInput
    Room?: RoomTBLUncheckedUpdateManyWithoutOfficerefNestedInput
  }

  export type SiteTBLUpsertWithoutEmployeeInput = {
    update: XOR<SiteTBLUpdateWithoutEmployeeInput, SiteTBLUncheckedUpdateWithoutEmployeeInput>
    create: XOR<SiteTBLCreateWithoutEmployeeInput, SiteTBLUncheckedCreateWithoutEmployeeInput>
    where?: SiteTBLWhereInput
  }

  export type SiteTBLUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: SiteTBLWhereInput
    data: XOR<SiteTBLUpdateWithoutEmployeeInput, SiteTBLUncheckedUpdateWithoutEmployeeInput>
  }

  export type SiteTBLUpdateWithoutEmployeeInput = {
    sitename?: StringFieldUpdateOperationsInput | string
    Building?: BuildingTBLUpdateManyWithoutSiterefNestedInput
    Officeboy?: OfficeBoyTBLUpdateManyWithoutSiterefNestedInput
  }

  export type SiteTBLUncheckedUpdateWithoutEmployeeInput = {
    siteid?: IntFieldUpdateOperationsInput | number
    sitename?: StringFieldUpdateOperationsInput | string
    Building?: BuildingTBLUncheckedUpdateManyWithoutSiterefNestedInput
    Officeboy?: OfficeBoyTBLUncheckedUpdateManyWithoutSiterefNestedInput
  }

  export type BuildingTBLUpsertWithoutEmployeeInput = {
    update: XOR<BuildingTBLUpdateWithoutEmployeeInput, BuildingTBLUncheckedUpdateWithoutEmployeeInput>
    create: XOR<BuildingTBLCreateWithoutEmployeeInput, BuildingTBLUncheckedCreateWithoutEmployeeInput>
    where?: BuildingTBLWhereInput
  }

  export type BuildingTBLUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: BuildingTBLWhereInput
    data: XOR<BuildingTBLUpdateWithoutEmployeeInput, BuildingTBLUncheckedUpdateWithoutEmployeeInput>
  }

  export type BuildingTBLUpdateWithoutEmployeeInput = {
    buildingname?: StringFieldUpdateOperationsInput | string
    siteref?: SiteTBLUpdateOneRequiredWithoutBuildingNestedInput
    Department?: DepartmentTBLUpdateManyWithoutBulidingrefNestedInput
    Office?: OfficeTBLUpdateManyWithoutBulidingrefNestedInput
  }

  export type BuildingTBLUncheckedUpdateWithoutEmployeeInput = {
    buildingid?: IntFieldUpdateOperationsInput | number
    buildingname?: StringFieldUpdateOperationsInput | string
    siteid?: IntFieldUpdateOperationsInput | number
    Department?: DepartmentTBLUncheckedUpdateManyWithoutBulidingrefNestedInput
    Office?: OfficeTBLUncheckedUpdateManyWithoutBulidingrefNestedInput
  }

  export type DepartmentTBLUpsertWithoutEmployeeInput = {
    update: XOR<DepartmentTBLUpdateWithoutEmployeeInput, DepartmentTBLUncheckedUpdateWithoutEmployeeInput>
    create: XOR<DepartmentTBLCreateWithoutEmployeeInput, DepartmentTBLUncheckedCreateWithoutEmployeeInput>
    where?: DepartmentTBLWhereInput
  }

  export type DepartmentTBLUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: DepartmentTBLWhereInput
    data: XOR<DepartmentTBLUpdateWithoutEmployeeInput, DepartmentTBLUncheckedUpdateWithoutEmployeeInput>
  }

  export type DepartmentTBLUpdateWithoutEmployeeInput = {
    departmentname?: StringFieldUpdateOperationsInput | string
    Room?: RoomTBLUpdateManyWithoutRoomdeprefNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutDepartmentNestedInput
  }

  export type DepartmentTBLUncheckedUpdateWithoutEmployeeInput = {
    departmentid?: IntFieldUpdateOperationsInput | number
    departmentname?: StringFieldUpdateOperationsInput | string
    buildingid?: IntFieldUpdateOperationsInput | number
    Room?: RoomTBLUncheckedUpdateManyWithoutRoomdeprefNestedInput
  }

  export type CartTBLUpsertWithWhereUniqueWithoutEmployeeidInput = {
    where: CartTBLWhereUniqueInput
    update: XOR<CartTBLUpdateWithoutEmployeeidInput, CartTBLUncheckedUpdateWithoutEmployeeidInput>
    create: XOR<CartTBLCreateWithoutEmployeeidInput, CartTBLUncheckedCreateWithoutEmployeeidInput>
  }

  export type CartTBLUpdateWithWhereUniqueWithoutEmployeeidInput = {
    where: CartTBLWhereUniqueInput
    data: XOR<CartTBLUpdateWithoutEmployeeidInput, CartTBLUncheckedUpdateWithoutEmployeeidInput>
  }

  export type CartTBLUpdateManyWithWhereWithoutEmployeeidInput = {
    where: CartTBLScalarWhereInput
    data: XOR<CartTBLUpdateManyMutationInput, CartTBLUncheckedUpdateManyWithoutEmployeeidInput>
  }

  export type CartTBLScalarWhereInput = {
    AND?: CartTBLScalarWhereInput | CartTBLScalarWhereInput[]
    OR?: CartTBLScalarWhereInput[]
    NOT?: CartTBLScalarWhereInput | CartTBLScalarWhereInput[]
    cartid?: IntFilter<"CartTBL"> | number
    empid?: IntFilter<"CartTBL"> | number
  }

  export type OrdersTBLUpsertWithWhereUniqueWithoutEmprefInput = {
    where: OrdersTBLWhereUniqueInput
    update: XOR<OrdersTBLUpdateWithoutEmprefInput, OrdersTBLUncheckedUpdateWithoutEmprefInput>
    create: XOR<OrdersTBLCreateWithoutEmprefInput, OrdersTBLUncheckedCreateWithoutEmprefInput>
  }

  export type OrdersTBLUpdateWithWhereUniqueWithoutEmprefInput = {
    where: OrdersTBLWhereUniqueInput
    data: XOR<OrdersTBLUpdateWithoutEmprefInput, OrdersTBLUncheckedUpdateWithoutEmprefInput>
  }

  export type OrdersTBLUpdateManyWithWhereWithoutEmprefInput = {
    where: OrdersTBLScalarWhereInput
    data: XOR<OrdersTBLUpdateManyMutationInput, OrdersTBLUncheckedUpdateManyWithoutEmprefInput>
  }

  export type OrdersTBLScalarWhereInput = {
    AND?: OrdersTBLScalarWhereInput | OrdersTBLScalarWhereInput[]
    OR?: OrdersTBLScalarWhereInput[]
    NOT?: OrdersTBLScalarWhereInput | OrdersTBLScalarWhereInput[]
    orderid?: IntFilter<"OrdersTBL"> | number
    empid?: IntFilter<"OrdersTBL"> | number
  }

  export type UsersTBLCreateWithoutOfficeboyInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    role: string
    Employee?: EmployeeTBLCreateNestedManyWithoutEmpInput
    Items?: ItemsTBLCreateNestedManyWithoutCreatorInput
    Tokens?: TokensTBLCreateNestedManyWithoutReftokenInput
  }

  export type UsersTBLUncheckedCreateWithoutOfficeboyInput = {
    userid?: number
    firstname: string
    lastname: string
    email: string
    password: string
    role: string
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutEmpInput
    Items?: ItemsTBLUncheckedCreateNestedManyWithoutCreatorInput
    Tokens?: TokensTBLUncheckedCreateNestedManyWithoutReftokenInput
  }

  export type UsersTBLCreateOrConnectWithoutOfficeboyInput = {
    where: UsersTBLWhereUniqueInput
    create: XOR<UsersTBLCreateWithoutOfficeboyInput, UsersTBLUncheckedCreateWithoutOfficeboyInput>
  }

  export type OfficeTBLCreateWithoutOfficeboyInput = {
    officeno: number
    Employee?: EmployeeTBLCreateNestedManyWithoutOffidInput
    bulidingref: BuildingTBLCreateNestedOneWithoutOfficeInput
    Room?: RoomTBLCreateNestedManyWithoutOfficerefInput
  }

  export type OfficeTBLUncheckedCreateWithoutOfficeboyInput = {
    officeid?: number
    officeno: number
    buildingid: number
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutOffidInput
    Room?: RoomTBLUncheckedCreateNestedManyWithoutOfficerefInput
  }

  export type OfficeTBLCreateOrConnectWithoutOfficeboyInput = {
    where: OfficeTBLWhereUniqueInput
    create: XOR<OfficeTBLCreateWithoutOfficeboyInput, OfficeTBLUncheckedCreateWithoutOfficeboyInput>
  }

  export type SiteTBLCreateWithoutOfficeboyInput = {
    sitename: string
    Employee?: EmployeeTBLCreateNestedManyWithoutSitidInput
    Building?: BuildingTBLCreateNestedManyWithoutSiterefInput
  }

  export type SiteTBLUncheckedCreateWithoutOfficeboyInput = {
    siteid?: number
    sitename: string
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutSitidInput
    Building?: BuildingTBLUncheckedCreateNestedManyWithoutSiterefInput
  }

  export type SiteTBLCreateOrConnectWithoutOfficeboyInput = {
    where: SiteTBLWhereUniqueInput
    create: XOR<SiteTBLCreateWithoutOfficeboyInput, SiteTBLUncheckedCreateWithoutOfficeboyInput>
  }

  export type UsersTBLUpsertWithoutOfficeboyInput = {
    update: XOR<UsersTBLUpdateWithoutOfficeboyInput, UsersTBLUncheckedUpdateWithoutOfficeboyInput>
    create: XOR<UsersTBLCreateWithoutOfficeboyInput, UsersTBLUncheckedCreateWithoutOfficeboyInput>
    where?: UsersTBLWhereInput
  }

  export type UsersTBLUpdateToOneWithWhereWithoutOfficeboyInput = {
    where?: UsersTBLWhereInput
    data: XOR<UsersTBLUpdateWithoutOfficeboyInput, UsersTBLUncheckedUpdateWithoutOfficeboyInput>
  }

  export type UsersTBLUpdateWithoutOfficeboyInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUpdateManyWithoutEmpNestedInput
    Items?: ItemsTBLUpdateManyWithoutCreatorNestedInput
    Tokens?: TokensTBLUpdateManyWithoutReftokenNestedInput
  }

  export type UsersTBLUncheckedUpdateWithoutOfficeboyInput = {
    userid?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutEmpNestedInput
    Items?: ItemsTBLUncheckedUpdateManyWithoutCreatorNestedInput
    Tokens?: TokensTBLUncheckedUpdateManyWithoutReftokenNestedInput
  }

  export type OfficeTBLUpsertWithoutOfficeboyInput = {
    update: XOR<OfficeTBLUpdateWithoutOfficeboyInput, OfficeTBLUncheckedUpdateWithoutOfficeboyInput>
    create: XOR<OfficeTBLCreateWithoutOfficeboyInput, OfficeTBLUncheckedCreateWithoutOfficeboyInput>
    where?: OfficeTBLWhereInput
  }

  export type OfficeTBLUpdateToOneWithWhereWithoutOfficeboyInput = {
    where?: OfficeTBLWhereInput
    data: XOR<OfficeTBLUpdateWithoutOfficeboyInput, OfficeTBLUncheckedUpdateWithoutOfficeboyInput>
  }

  export type OfficeTBLUpdateWithoutOfficeboyInput = {
    officeno?: IntFieldUpdateOperationsInput | number
    Employee?: EmployeeTBLUpdateManyWithoutOffidNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutOfficeNestedInput
    Room?: RoomTBLUpdateManyWithoutOfficerefNestedInput
  }

  export type OfficeTBLUncheckedUpdateWithoutOfficeboyInput = {
    officeid?: IntFieldUpdateOperationsInput | number
    officeno?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutOffidNestedInput
    Room?: RoomTBLUncheckedUpdateManyWithoutOfficerefNestedInput
  }

  export type SiteTBLUpsertWithoutOfficeboyInput = {
    update: XOR<SiteTBLUpdateWithoutOfficeboyInput, SiteTBLUncheckedUpdateWithoutOfficeboyInput>
    create: XOR<SiteTBLCreateWithoutOfficeboyInput, SiteTBLUncheckedCreateWithoutOfficeboyInput>
    where?: SiteTBLWhereInput
  }

  export type SiteTBLUpdateToOneWithWhereWithoutOfficeboyInput = {
    where?: SiteTBLWhereInput
    data: XOR<SiteTBLUpdateWithoutOfficeboyInput, SiteTBLUncheckedUpdateWithoutOfficeboyInput>
  }

  export type SiteTBLUpdateWithoutOfficeboyInput = {
    sitename?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUpdateManyWithoutSitidNestedInput
    Building?: BuildingTBLUpdateManyWithoutSiterefNestedInput
  }

  export type SiteTBLUncheckedUpdateWithoutOfficeboyInput = {
    siteid?: IntFieldUpdateOperationsInput | number
    sitename?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutSitidNestedInput
    Building?: BuildingTBLUncheckedUpdateManyWithoutSiterefNestedInput
  }

  export type EmployeeTBLCreateWithoutSitidInput = {
    emp?: UsersTBLCreateNestedOneWithoutEmployeeInput
    romid: RoomTBLCreateNestedOneWithoutEmployeeInput
    offid: OfficeTBLCreateNestedOneWithoutEmployeeInput
    bulidingref: BuildingTBLCreateNestedOneWithoutEmployeeInput
    departmentref: DepartmentTBLCreateNestedOneWithoutEmployeeInput
    Cart?: CartTBLCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLUncheckedCreateWithoutSitidInput = {
    empid?: number
    roomid: number
    officeid: number
    buildingid: number
    departmentid: number
    Cart?: CartTBLUncheckedCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLUncheckedCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLCreateOrConnectWithoutSitidInput = {
    where: EmployeeTBLWhereUniqueInput
    create: XOR<EmployeeTBLCreateWithoutSitidInput, EmployeeTBLUncheckedCreateWithoutSitidInput>
  }

  export type EmployeeTBLCreateManySitidInputEnvelope = {
    data: EmployeeTBLCreateManySitidInput | EmployeeTBLCreateManySitidInput[]
    skipDuplicates?: boolean
  }

  export type BuildingTBLCreateWithoutSiterefInput = {
    buildingname: string
    Department?: DepartmentTBLCreateNestedManyWithoutBulidingrefInput
    Office?: OfficeTBLCreateNestedManyWithoutBulidingrefInput
    Employee?: EmployeeTBLCreateNestedManyWithoutBulidingrefInput
  }

  export type BuildingTBLUncheckedCreateWithoutSiterefInput = {
    buildingid?: number
    buildingname: string
    Department?: DepartmentTBLUncheckedCreateNestedManyWithoutBulidingrefInput
    Office?: OfficeTBLUncheckedCreateNestedManyWithoutBulidingrefInput
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutBulidingrefInput
  }

  export type BuildingTBLCreateOrConnectWithoutSiterefInput = {
    where: BuildingTBLWhereUniqueInput
    create: XOR<BuildingTBLCreateWithoutSiterefInput, BuildingTBLUncheckedCreateWithoutSiterefInput>
  }

  export type BuildingTBLCreateManySiterefInputEnvelope = {
    data: BuildingTBLCreateManySiterefInput | BuildingTBLCreateManySiterefInput[]
    skipDuplicates?: boolean
  }

  export type OfficeBoyTBLCreateWithoutSiterefInput = {
    officeboy?: UsersTBLCreateNestedOneWithoutOfficeboyInput
    offid: OfficeTBLCreateNestedOneWithoutOfficeboyInput
  }

  export type OfficeBoyTBLUncheckedCreateWithoutSiterefInput = {
    officeboyid?: number
    officeid: number
  }

  export type OfficeBoyTBLCreateOrConnectWithoutSiterefInput = {
    where: OfficeBoyTBLWhereUniqueInput
    create: XOR<OfficeBoyTBLCreateWithoutSiterefInput, OfficeBoyTBLUncheckedCreateWithoutSiterefInput>
  }

  export type OfficeBoyTBLCreateManySiterefInputEnvelope = {
    data: OfficeBoyTBLCreateManySiterefInput | OfficeBoyTBLCreateManySiterefInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTBLUpsertWithWhereUniqueWithoutSitidInput = {
    where: EmployeeTBLWhereUniqueInput
    update: XOR<EmployeeTBLUpdateWithoutSitidInput, EmployeeTBLUncheckedUpdateWithoutSitidInput>
    create: XOR<EmployeeTBLCreateWithoutSitidInput, EmployeeTBLUncheckedCreateWithoutSitidInput>
  }

  export type EmployeeTBLUpdateWithWhereUniqueWithoutSitidInput = {
    where: EmployeeTBLWhereUniqueInput
    data: XOR<EmployeeTBLUpdateWithoutSitidInput, EmployeeTBLUncheckedUpdateWithoutSitidInput>
  }

  export type EmployeeTBLUpdateManyWithWhereWithoutSitidInput = {
    where: EmployeeTBLScalarWhereInput
    data: XOR<EmployeeTBLUpdateManyMutationInput, EmployeeTBLUncheckedUpdateManyWithoutSitidInput>
  }

  export type BuildingTBLUpsertWithWhereUniqueWithoutSiterefInput = {
    where: BuildingTBLWhereUniqueInput
    update: XOR<BuildingTBLUpdateWithoutSiterefInput, BuildingTBLUncheckedUpdateWithoutSiterefInput>
    create: XOR<BuildingTBLCreateWithoutSiterefInput, BuildingTBLUncheckedCreateWithoutSiterefInput>
  }

  export type BuildingTBLUpdateWithWhereUniqueWithoutSiterefInput = {
    where: BuildingTBLWhereUniqueInput
    data: XOR<BuildingTBLUpdateWithoutSiterefInput, BuildingTBLUncheckedUpdateWithoutSiterefInput>
  }

  export type BuildingTBLUpdateManyWithWhereWithoutSiterefInput = {
    where: BuildingTBLScalarWhereInput
    data: XOR<BuildingTBLUpdateManyMutationInput, BuildingTBLUncheckedUpdateManyWithoutSiterefInput>
  }

  export type BuildingTBLScalarWhereInput = {
    AND?: BuildingTBLScalarWhereInput | BuildingTBLScalarWhereInput[]
    OR?: BuildingTBLScalarWhereInput[]
    NOT?: BuildingTBLScalarWhereInput | BuildingTBLScalarWhereInput[]
    buildingid?: IntFilter<"BuildingTBL"> | number
    buildingname?: StringFilter<"BuildingTBL"> | string
    siteid?: IntFilter<"BuildingTBL"> | number
  }

  export type OfficeBoyTBLUpsertWithWhereUniqueWithoutSiterefInput = {
    where: OfficeBoyTBLWhereUniqueInput
    update: XOR<OfficeBoyTBLUpdateWithoutSiterefInput, OfficeBoyTBLUncheckedUpdateWithoutSiterefInput>
    create: XOR<OfficeBoyTBLCreateWithoutSiterefInput, OfficeBoyTBLUncheckedCreateWithoutSiterefInput>
  }

  export type OfficeBoyTBLUpdateWithWhereUniqueWithoutSiterefInput = {
    where: OfficeBoyTBLWhereUniqueInput
    data: XOR<OfficeBoyTBLUpdateWithoutSiterefInput, OfficeBoyTBLUncheckedUpdateWithoutSiterefInput>
  }

  export type OfficeBoyTBLUpdateManyWithWhereWithoutSiterefInput = {
    where: OfficeBoyTBLScalarWhereInput
    data: XOR<OfficeBoyTBLUpdateManyMutationInput, OfficeBoyTBLUncheckedUpdateManyWithoutSiterefInput>
  }

  export type SiteTBLCreateWithoutBuildingInput = {
    sitename: string
    Employee?: EmployeeTBLCreateNestedManyWithoutSitidInput
    Officeboy?: OfficeBoyTBLCreateNestedManyWithoutSiterefInput
  }

  export type SiteTBLUncheckedCreateWithoutBuildingInput = {
    siteid?: number
    sitename: string
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutSitidInput
    Officeboy?: OfficeBoyTBLUncheckedCreateNestedManyWithoutSiterefInput
  }

  export type SiteTBLCreateOrConnectWithoutBuildingInput = {
    where: SiteTBLWhereUniqueInput
    create: XOR<SiteTBLCreateWithoutBuildingInput, SiteTBLUncheckedCreateWithoutBuildingInput>
  }

  export type DepartmentTBLCreateWithoutBulidingrefInput = {
    departmentname: string
    Room?: RoomTBLCreateNestedManyWithoutRoomdeprefInput
    Employee?: EmployeeTBLCreateNestedManyWithoutDepartmentrefInput
  }

  export type DepartmentTBLUncheckedCreateWithoutBulidingrefInput = {
    departmentid?: number
    departmentname: string
    Room?: RoomTBLUncheckedCreateNestedManyWithoutRoomdeprefInput
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutDepartmentrefInput
  }

  export type DepartmentTBLCreateOrConnectWithoutBulidingrefInput = {
    where: DepartmentTBLWhereUniqueInput
    create: XOR<DepartmentTBLCreateWithoutBulidingrefInput, DepartmentTBLUncheckedCreateWithoutBulidingrefInput>
  }

  export type DepartmentTBLCreateManyBulidingrefInputEnvelope = {
    data: DepartmentTBLCreateManyBulidingrefInput | DepartmentTBLCreateManyBulidingrefInput[]
    skipDuplicates?: boolean
  }

  export type OfficeTBLCreateWithoutBulidingrefInput = {
    officeno: number
    Employee?: EmployeeTBLCreateNestedManyWithoutOffidInput
    Officeboy?: OfficeBoyTBLCreateNestedManyWithoutOffidInput
    Room?: RoomTBLCreateNestedManyWithoutOfficerefInput
  }

  export type OfficeTBLUncheckedCreateWithoutBulidingrefInput = {
    officeid?: number
    officeno: number
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutOffidInput
    Officeboy?: OfficeBoyTBLUncheckedCreateNestedManyWithoutOffidInput
    Room?: RoomTBLUncheckedCreateNestedManyWithoutOfficerefInput
  }

  export type OfficeTBLCreateOrConnectWithoutBulidingrefInput = {
    where: OfficeTBLWhereUniqueInput
    create: XOR<OfficeTBLCreateWithoutBulidingrefInput, OfficeTBLUncheckedCreateWithoutBulidingrefInput>
  }

  export type OfficeTBLCreateManyBulidingrefInputEnvelope = {
    data: OfficeTBLCreateManyBulidingrefInput | OfficeTBLCreateManyBulidingrefInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTBLCreateWithoutBulidingrefInput = {
    emp?: UsersTBLCreateNestedOneWithoutEmployeeInput
    romid: RoomTBLCreateNestedOneWithoutEmployeeInput
    offid: OfficeTBLCreateNestedOneWithoutEmployeeInput
    sitid: SiteTBLCreateNestedOneWithoutEmployeeInput
    departmentref: DepartmentTBLCreateNestedOneWithoutEmployeeInput
    Cart?: CartTBLCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLUncheckedCreateWithoutBulidingrefInput = {
    empid?: number
    roomid: number
    officeid: number
    siteid: number
    departmentid: number
    Cart?: CartTBLUncheckedCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLUncheckedCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLCreateOrConnectWithoutBulidingrefInput = {
    where: EmployeeTBLWhereUniqueInput
    create: XOR<EmployeeTBLCreateWithoutBulidingrefInput, EmployeeTBLUncheckedCreateWithoutBulidingrefInput>
  }

  export type EmployeeTBLCreateManyBulidingrefInputEnvelope = {
    data: EmployeeTBLCreateManyBulidingrefInput | EmployeeTBLCreateManyBulidingrefInput[]
    skipDuplicates?: boolean
  }

  export type SiteTBLUpsertWithoutBuildingInput = {
    update: XOR<SiteTBLUpdateWithoutBuildingInput, SiteTBLUncheckedUpdateWithoutBuildingInput>
    create: XOR<SiteTBLCreateWithoutBuildingInput, SiteTBLUncheckedCreateWithoutBuildingInput>
    where?: SiteTBLWhereInput
  }

  export type SiteTBLUpdateToOneWithWhereWithoutBuildingInput = {
    where?: SiteTBLWhereInput
    data: XOR<SiteTBLUpdateWithoutBuildingInput, SiteTBLUncheckedUpdateWithoutBuildingInput>
  }

  export type SiteTBLUpdateWithoutBuildingInput = {
    sitename?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUpdateManyWithoutSitidNestedInput
    Officeboy?: OfficeBoyTBLUpdateManyWithoutSiterefNestedInput
  }

  export type SiteTBLUncheckedUpdateWithoutBuildingInput = {
    siteid?: IntFieldUpdateOperationsInput | number
    sitename?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutSitidNestedInput
    Officeboy?: OfficeBoyTBLUncheckedUpdateManyWithoutSiterefNestedInput
  }

  export type DepartmentTBLUpsertWithWhereUniqueWithoutBulidingrefInput = {
    where: DepartmentTBLWhereUniqueInput
    update: XOR<DepartmentTBLUpdateWithoutBulidingrefInput, DepartmentTBLUncheckedUpdateWithoutBulidingrefInput>
    create: XOR<DepartmentTBLCreateWithoutBulidingrefInput, DepartmentTBLUncheckedCreateWithoutBulidingrefInput>
  }

  export type DepartmentTBLUpdateWithWhereUniqueWithoutBulidingrefInput = {
    where: DepartmentTBLWhereUniqueInput
    data: XOR<DepartmentTBLUpdateWithoutBulidingrefInput, DepartmentTBLUncheckedUpdateWithoutBulidingrefInput>
  }

  export type DepartmentTBLUpdateManyWithWhereWithoutBulidingrefInput = {
    where: DepartmentTBLScalarWhereInput
    data: XOR<DepartmentTBLUpdateManyMutationInput, DepartmentTBLUncheckedUpdateManyWithoutBulidingrefInput>
  }

  export type DepartmentTBLScalarWhereInput = {
    AND?: DepartmentTBLScalarWhereInput | DepartmentTBLScalarWhereInput[]
    OR?: DepartmentTBLScalarWhereInput[]
    NOT?: DepartmentTBLScalarWhereInput | DepartmentTBLScalarWhereInput[]
    departmentid?: IntFilter<"DepartmentTBL"> | number
    departmentname?: StringFilter<"DepartmentTBL"> | string
    buildingid?: IntFilter<"DepartmentTBL"> | number
  }

  export type OfficeTBLUpsertWithWhereUniqueWithoutBulidingrefInput = {
    where: OfficeTBLWhereUniqueInput
    update: XOR<OfficeTBLUpdateWithoutBulidingrefInput, OfficeTBLUncheckedUpdateWithoutBulidingrefInput>
    create: XOR<OfficeTBLCreateWithoutBulidingrefInput, OfficeTBLUncheckedCreateWithoutBulidingrefInput>
  }

  export type OfficeTBLUpdateWithWhereUniqueWithoutBulidingrefInput = {
    where: OfficeTBLWhereUniqueInput
    data: XOR<OfficeTBLUpdateWithoutBulidingrefInput, OfficeTBLUncheckedUpdateWithoutBulidingrefInput>
  }

  export type OfficeTBLUpdateManyWithWhereWithoutBulidingrefInput = {
    where: OfficeTBLScalarWhereInput
    data: XOR<OfficeTBLUpdateManyMutationInput, OfficeTBLUncheckedUpdateManyWithoutBulidingrefInput>
  }

  export type OfficeTBLScalarWhereInput = {
    AND?: OfficeTBLScalarWhereInput | OfficeTBLScalarWhereInput[]
    OR?: OfficeTBLScalarWhereInput[]
    NOT?: OfficeTBLScalarWhereInput | OfficeTBLScalarWhereInput[]
    officeid?: IntFilter<"OfficeTBL"> | number
    officeno?: IntFilter<"OfficeTBL"> | number
    buildingid?: IntFilter<"OfficeTBL"> | number
  }

  export type EmployeeTBLUpsertWithWhereUniqueWithoutBulidingrefInput = {
    where: EmployeeTBLWhereUniqueInput
    update: XOR<EmployeeTBLUpdateWithoutBulidingrefInput, EmployeeTBLUncheckedUpdateWithoutBulidingrefInput>
    create: XOR<EmployeeTBLCreateWithoutBulidingrefInput, EmployeeTBLUncheckedCreateWithoutBulidingrefInput>
  }

  export type EmployeeTBLUpdateWithWhereUniqueWithoutBulidingrefInput = {
    where: EmployeeTBLWhereUniqueInput
    data: XOR<EmployeeTBLUpdateWithoutBulidingrefInput, EmployeeTBLUncheckedUpdateWithoutBulidingrefInput>
  }

  export type EmployeeTBLUpdateManyWithWhereWithoutBulidingrefInput = {
    where: EmployeeTBLScalarWhereInput
    data: XOR<EmployeeTBLUpdateManyMutationInput, EmployeeTBLUncheckedUpdateManyWithoutBulidingrefInput>
  }

  export type EmployeeTBLCreateWithoutOffidInput = {
    emp?: UsersTBLCreateNestedOneWithoutEmployeeInput
    romid: RoomTBLCreateNestedOneWithoutEmployeeInput
    sitid: SiteTBLCreateNestedOneWithoutEmployeeInput
    bulidingref: BuildingTBLCreateNestedOneWithoutEmployeeInput
    departmentref: DepartmentTBLCreateNestedOneWithoutEmployeeInput
    Cart?: CartTBLCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLUncheckedCreateWithoutOffidInput = {
    empid?: number
    roomid: number
    siteid: number
    buildingid: number
    departmentid: number
    Cart?: CartTBLUncheckedCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLUncheckedCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLCreateOrConnectWithoutOffidInput = {
    where: EmployeeTBLWhereUniqueInput
    create: XOR<EmployeeTBLCreateWithoutOffidInput, EmployeeTBLUncheckedCreateWithoutOffidInput>
  }

  export type EmployeeTBLCreateManyOffidInputEnvelope = {
    data: EmployeeTBLCreateManyOffidInput | EmployeeTBLCreateManyOffidInput[]
    skipDuplicates?: boolean
  }

  export type OfficeBoyTBLCreateWithoutOffidInput = {
    officeboy?: UsersTBLCreateNestedOneWithoutOfficeboyInput
    siteref: SiteTBLCreateNestedOneWithoutOfficeboyInput
  }

  export type OfficeBoyTBLUncheckedCreateWithoutOffidInput = {
    officeboyid?: number
    siteid: number
  }

  export type OfficeBoyTBLCreateOrConnectWithoutOffidInput = {
    where: OfficeBoyTBLWhereUniqueInput
    create: XOR<OfficeBoyTBLCreateWithoutOffidInput, OfficeBoyTBLUncheckedCreateWithoutOffidInput>
  }

  export type OfficeBoyTBLCreateManyOffidInputEnvelope = {
    data: OfficeBoyTBLCreateManyOffidInput | OfficeBoyTBLCreateManyOffidInput[]
    skipDuplicates?: boolean
  }

  export type BuildingTBLCreateWithoutOfficeInput = {
    buildingname: string
    siteref: SiteTBLCreateNestedOneWithoutBuildingInput
    Department?: DepartmentTBLCreateNestedManyWithoutBulidingrefInput
    Employee?: EmployeeTBLCreateNestedManyWithoutBulidingrefInput
  }

  export type BuildingTBLUncheckedCreateWithoutOfficeInput = {
    buildingid?: number
    buildingname: string
    siteid: number
    Department?: DepartmentTBLUncheckedCreateNestedManyWithoutBulidingrefInput
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutBulidingrefInput
  }

  export type BuildingTBLCreateOrConnectWithoutOfficeInput = {
    where: BuildingTBLWhereUniqueInput
    create: XOR<BuildingTBLCreateWithoutOfficeInput, BuildingTBLUncheckedCreateWithoutOfficeInput>
  }

  export type RoomTBLCreateWithoutOfficerefInput = {
    roomno: number
    roomname: string
    roomdepref: DepartmentTBLCreateNestedOneWithoutRoomInput
    Employee?: EmployeeTBLCreateNestedManyWithoutRomidInput
  }

  export type RoomTBLUncheckedCreateWithoutOfficerefInput = {
    roomid?: number
    roomno: number
    roomname: string
    departmentid: number
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutRomidInput
  }

  export type RoomTBLCreateOrConnectWithoutOfficerefInput = {
    where: RoomTBLWhereUniqueInput
    create: XOR<RoomTBLCreateWithoutOfficerefInput, RoomTBLUncheckedCreateWithoutOfficerefInput>
  }

  export type RoomTBLCreateManyOfficerefInputEnvelope = {
    data: RoomTBLCreateManyOfficerefInput | RoomTBLCreateManyOfficerefInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTBLUpsertWithWhereUniqueWithoutOffidInput = {
    where: EmployeeTBLWhereUniqueInput
    update: XOR<EmployeeTBLUpdateWithoutOffidInput, EmployeeTBLUncheckedUpdateWithoutOffidInput>
    create: XOR<EmployeeTBLCreateWithoutOffidInput, EmployeeTBLUncheckedCreateWithoutOffidInput>
  }

  export type EmployeeTBLUpdateWithWhereUniqueWithoutOffidInput = {
    where: EmployeeTBLWhereUniqueInput
    data: XOR<EmployeeTBLUpdateWithoutOffidInput, EmployeeTBLUncheckedUpdateWithoutOffidInput>
  }

  export type EmployeeTBLUpdateManyWithWhereWithoutOffidInput = {
    where: EmployeeTBLScalarWhereInput
    data: XOR<EmployeeTBLUpdateManyMutationInput, EmployeeTBLUncheckedUpdateManyWithoutOffidInput>
  }

  export type OfficeBoyTBLUpsertWithWhereUniqueWithoutOffidInput = {
    where: OfficeBoyTBLWhereUniqueInput
    update: XOR<OfficeBoyTBLUpdateWithoutOffidInput, OfficeBoyTBLUncheckedUpdateWithoutOffidInput>
    create: XOR<OfficeBoyTBLCreateWithoutOffidInput, OfficeBoyTBLUncheckedCreateWithoutOffidInput>
  }

  export type OfficeBoyTBLUpdateWithWhereUniqueWithoutOffidInput = {
    where: OfficeBoyTBLWhereUniqueInput
    data: XOR<OfficeBoyTBLUpdateWithoutOffidInput, OfficeBoyTBLUncheckedUpdateWithoutOffidInput>
  }

  export type OfficeBoyTBLUpdateManyWithWhereWithoutOffidInput = {
    where: OfficeBoyTBLScalarWhereInput
    data: XOR<OfficeBoyTBLUpdateManyMutationInput, OfficeBoyTBLUncheckedUpdateManyWithoutOffidInput>
  }

  export type BuildingTBLUpsertWithoutOfficeInput = {
    update: XOR<BuildingTBLUpdateWithoutOfficeInput, BuildingTBLUncheckedUpdateWithoutOfficeInput>
    create: XOR<BuildingTBLCreateWithoutOfficeInput, BuildingTBLUncheckedCreateWithoutOfficeInput>
    where?: BuildingTBLWhereInput
  }

  export type BuildingTBLUpdateToOneWithWhereWithoutOfficeInput = {
    where?: BuildingTBLWhereInput
    data: XOR<BuildingTBLUpdateWithoutOfficeInput, BuildingTBLUncheckedUpdateWithoutOfficeInput>
  }

  export type BuildingTBLUpdateWithoutOfficeInput = {
    buildingname?: StringFieldUpdateOperationsInput | string
    siteref?: SiteTBLUpdateOneRequiredWithoutBuildingNestedInput
    Department?: DepartmentTBLUpdateManyWithoutBulidingrefNestedInput
    Employee?: EmployeeTBLUpdateManyWithoutBulidingrefNestedInput
  }

  export type BuildingTBLUncheckedUpdateWithoutOfficeInput = {
    buildingid?: IntFieldUpdateOperationsInput | number
    buildingname?: StringFieldUpdateOperationsInput | string
    siteid?: IntFieldUpdateOperationsInput | number
    Department?: DepartmentTBLUncheckedUpdateManyWithoutBulidingrefNestedInput
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutBulidingrefNestedInput
  }

  export type RoomTBLUpsertWithWhereUniqueWithoutOfficerefInput = {
    where: RoomTBLWhereUniqueInput
    update: XOR<RoomTBLUpdateWithoutOfficerefInput, RoomTBLUncheckedUpdateWithoutOfficerefInput>
    create: XOR<RoomTBLCreateWithoutOfficerefInput, RoomTBLUncheckedCreateWithoutOfficerefInput>
  }

  export type RoomTBLUpdateWithWhereUniqueWithoutOfficerefInput = {
    where: RoomTBLWhereUniqueInput
    data: XOR<RoomTBLUpdateWithoutOfficerefInput, RoomTBLUncheckedUpdateWithoutOfficerefInput>
  }

  export type RoomTBLUpdateManyWithWhereWithoutOfficerefInput = {
    where: RoomTBLScalarWhereInput
    data: XOR<RoomTBLUpdateManyMutationInput, RoomTBLUncheckedUpdateManyWithoutOfficerefInput>
  }

  export type RoomTBLScalarWhereInput = {
    AND?: RoomTBLScalarWhereInput | RoomTBLScalarWhereInput[]
    OR?: RoomTBLScalarWhereInput[]
    NOT?: RoomTBLScalarWhereInput | RoomTBLScalarWhereInput[]
    roomid?: IntFilter<"RoomTBL"> | number
    roomno?: IntFilter<"RoomTBL"> | number
    roomname?: StringFilter<"RoomTBL"> | string
    officeid?: IntFilter<"RoomTBL"> | number
    departmentid?: IntFilter<"RoomTBL"> | number
  }

  export type RoomTBLCreateWithoutRoomdeprefInput = {
    roomno: number
    roomname: string
    officeref: OfficeTBLCreateNestedOneWithoutRoomInput
    Employee?: EmployeeTBLCreateNestedManyWithoutRomidInput
  }

  export type RoomTBLUncheckedCreateWithoutRoomdeprefInput = {
    roomid?: number
    roomno: number
    roomname: string
    officeid: number
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutRomidInput
  }

  export type RoomTBLCreateOrConnectWithoutRoomdeprefInput = {
    where: RoomTBLWhereUniqueInput
    create: XOR<RoomTBLCreateWithoutRoomdeprefInput, RoomTBLUncheckedCreateWithoutRoomdeprefInput>
  }

  export type RoomTBLCreateManyRoomdeprefInputEnvelope = {
    data: RoomTBLCreateManyRoomdeprefInput | RoomTBLCreateManyRoomdeprefInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTBLCreateWithoutDepartmentrefInput = {
    emp?: UsersTBLCreateNestedOneWithoutEmployeeInput
    romid: RoomTBLCreateNestedOneWithoutEmployeeInput
    offid: OfficeTBLCreateNestedOneWithoutEmployeeInput
    sitid: SiteTBLCreateNestedOneWithoutEmployeeInput
    bulidingref: BuildingTBLCreateNestedOneWithoutEmployeeInput
    Cart?: CartTBLCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLUncheckedCreateWithoutDepartmentrefInput = {
    empid?: number
    roomid: number
    officeid: number
    siteid: number
    buildingid: number
    Cart?: CartTBLUncheckedCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLUncheckedCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLCreateOrConnectWithoutDepartmentrefInput = {
    where: EmployeeTBLWhereUniqueInput
    create: XOR<EmployeeTBLCreateWithoutDepartmentrefInput, EmployeeTBLUncheckedCreateWithoutDepartmentrefInput>
  }

  export type EmployeeTBLCreateManyDepartmentrefInputEnvelope = {
    data: EmployeeTBLCreateManyDepartmentrefInput | EmployeeTBLCreateManyDepartmentrefInput[]
    skipDuplicates?: boolean
  }

  export type BuildingTBLCreateWithoutDepartmentInput = {
    buildingname: string
    siteref: SiteTBLCreateNestedOneWithoutBuildingInput
    Office?: OfficeTBLCreateNestedManyWithoutBulidingrefInput
    Employee?: EmployeeTBLCreateNestedManyWithoutBulidingrefInput
  }

  export type BuildingTBLUncheckedCreateWithoutDepartmentInput = {
    buildingid?: number
    buildingname: string
    siteid: number
    Office?: OfficeTBLUncheckedCreateNestedManyWithoutBulidingrefInput
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutBulidingrefInput
  }

  export type BuildingTBLCreateOrConnectWithoutDepartmentInput = {
    where: BuildingTBLWhereUniqueInput
    create: XOR<BuildingTBLCreateWithoutDepartmentInput, BuildingTBLUncheckedCreateWithoutDepartmentInput>
  }

  export type RoomTBLUpsertWithWhereUniqueWithoutRoomdeprefInput = {
    where: RoomTBLWhereUniqueInput
    update: XOR<RoomTBLUpdateWithoutRoomdeprefInput, RoomTBLUncheckedUpdateWithoutRoomdeprefInput>
    create: XOR<RoomTBLCreateWithoutRoomdeprefInput, RoomTBLUncheckedCreateWithoutRoomdeprefInput>
  }

  export type RoomTBLUpdateWithWhereUniqueWithoutRoomdeprefInput = {
    where: RoomTBLWhereUniqueInput
    data: XOR<RoomTBLUpdateWithoutRoomdeprefInput, RoomTBLUncheckedUpdateWithoutRoomdeprefInput>
  }

  export type RoomTBLUpdateManyWithWhereWithoutRoomdeprefInput = {
    where: RoomTBLScalarWhereInput
    data: XOR<RoomTBLUpdateManyMutationInput, RoomTBLUncheckedUpdateManyWithoutRoomdeprefInput>
  }

  export type EmployeeTBLUpsertWithWhereUniqueWithoutDepartmentrefInput = {
    where: EmployeeTBLWhereUniqueInput
    update: XOR<EmployeeTBLUpdateWithoutDepartmentrefInput, EmployeeTBLUncheckedUpdateWithoutDepartmentrefInput>
    create: XOR<EmployeeTBLCreateWithoutDepartmentrefInput, EmployeeTBLUncheckedCreateWithoutDepartmentrefInput>
  }

  export type EmployeeTBLUpdateWithWhereUniqueWithoutDepartmentrefInput = {
    where: EmployeeTBLWhereUniqueInput
    data: XOR<EmployeeTBLUpdateWithoutDepartmentrefInput, EmployeeTBLUncheckedUpdateWithoutDepartmentrefInput>
  }

  export type EmployeeTBLUpdateManyWithWhereWithoutDepartmentrefInput = {
    where: EmployeeTBLScalarWhereInput
    data: XOR<EmployeeTBLUpdateManyMutationInput, EmployeeTBLUncheckedUpdateManyWithoutDepartmentrefInput>
  }

  export type BuildingTBLUpsertWithoutDepartmentInput = {
    update: XOR<BuildingTBLUpdateWithoutDepartmentInput, BuildingTBLUncheckedUpdateWithoutDepartmentInput>
    create: XOR<BuildingTBLCreateWithoutDepartmentInput, BuildingTBLUncheckedCreateWithoutDepartmentInput>
    where?: BuildingTBLWhereInput
  }

  export type BuildingTBLUpdateToOneWithWhereWithoutDepartmentInput = {
    where?: BuildingTBLWhereInput
    data: XOR<BuildingTBLUpdateWithoutDepartmentInput, BuildingTBLUncheckedUpdateWithoutDepartmentInput>
  }

  export type BuildingTBLUpdateWithoutDepartmentInput = {
    buildingname?: StringFieldUpdateOperationsInput | string
    siteref?: SiteTBLUpdateOneRequiredWithoutBuildingNestedInput
    Office?: OfficeTBLUpdateManyWithoutBulidingrefNestedInput
    Employee?: EmployeeTBLUpdateManyWithoutBulidingrefNestedInput
  }

  export type BuildingTBLUncheckedUpdateWithoutDepartmentInput = {
    buildingid?: IntFieldUpdateOperationsInput | number
    buildingname?: StringFieldUpdateOperationsInput | string
    siteid?: IntFieldUpdateOperationsInput | number
    Office?: OfficeTBLUncheckedUpdateManyWithoutBulidingrefNestedInput
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutBulidingrefNestedInput
  }

  export type OfficeTBLCreateWithoutRoomInput = {
    officeno: number
    Employee?: EmployeeTBLCreateNestedManyWithoutOffidInput
    Officeboy?: OfficeBoyTBLCreateNestedManyWithoutOffidInput
    bulidingref: BuildingTBLCreateNestedOneWithoutOfficeInput
  }

  export type OfficeTBLUncheckedCreateWithoutRoomInput = {
    officeid?: number
    officeno: number
    buildingid: number
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutOffidInput
    Officeboy?: OfficeBoyTBLUncheckedCreateNestedManyWithoutOffidInput
  }

  export type OfficeTBLCreateOrConnectWithoutRoomInput = {
    where: OfficeTBLWhereUniqueInput
    create: XOR<OfficeTBLCreateWithoutRoomInput, OfficeTBLUncheckedCreateWithoutRoomInput>
  }

  export type DepartmentTBLCreateWithoutRoomInput = {
    departmentname: string
    Employee?: EmployeeTBLCreateNestedManyWithoutDepartmentrefInput
    bulidingref: BuildingTBLCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentTBLUncheckedCreateWithoutRoomInput = {
    departmentid?: number
    departmentname: string
    buildingid: number
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutDepartmentrefInput
  }

  export type DepartmentTBLCreateOrConnectWithoutRoomInput = {
    where: DepartmentTBLWhereUniqueInput
    create: XOR<DepartmentTBLCreateWithoutRoomInput, DepartmentTBLUncheckedCreateWithoutRoomInput>
  }

  export type EmployeeTBLCreateWithoutRomidInput = {
    emp?: UsersTBLCreateNestedOneWithoutEmployeeInput
    offid: OfficeTBLCreateNestedOneWithoutEmployeeInput
    sitid: SiteTBLCreateNestedOneWithoutEmployeeInput
    bulidingref: BuildingTBLCreateNestedOneWithoutEmployeeInput
    departmentref: DepartmentTBLCreateNestedOneWithoutEmployeeInput
    Cart?: CartTBLCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLUncheckedCreateWithoutRomidInput = {
    empid?: number
    officeid: number
    siteid: number
    buildingid: number
    departmentid: number
    Cart?: CartTBLUncheckedCreateNestedManyWithoutEmployeeidInput
    OrdersTBL?: OrdersTBLUncheckedCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLCreateOrConnectWithoutRomidInput = {
    where: EmployeeTBLWhereUniqueInput
    create: XOR<EmployeeTBLCreateWithoutRomidInput, EmployeeTBLUncheckedCreateWithoutRomidInput>
  }

  export type EmployeeTBLCreateManyRomidInputEnvelope = {
    data: EmployeeTBLCreateManyRomidInput | EmployeeTBLCreateManyRomidInput[]
    skipDuplicates?: boolean
  }

  export type OfficeTBLUpsertWithoutRoomInput = {
    update: XOR<OfficeTBLUpdateWithoutRoomInput, OfficeTBLUncheckedUpdateWithoutRoomInput>
    create: XOR<OfficeTBLCreateWithoutRoomInput, OfficeTBLUncheckedCreateWithoutRoomInput>
    where?: OfficeTBLWhereInput
  }

  export type OfficeTBLUpdateToOneWithWhereWithoutRoomInput = {
    where?: OfficeTBLWhereInput
    data: XOR<OfficeTBLUpdateWithoutRoomInput, OfficeTBLUncheckedUpdateWithoutRoomInput>
  }

  export type OfficeTBLUpdateWithoutRoomInput = {
    officeno?: IntFieldUpdateOperationsInput | number
    Employee?: EmployeeTBLUpdateManyWithoutOffidNestedInput
    Officeboy?: OfficeBoyTBLUpdateManyWithoutOffidNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutOfficeNestedInput
  }

  export type OfficeTBLUncheckedUpdateWithoutRoomInput = {
    officeid?: IntFieldUpdateOperationsInput | number
    officeno?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutOffidNestedInput
    Officeboy?: OfficeBoyTBLUncheckedUpdateManyWithoutOffidNestedInput
  }

  export type DepartmentTBLUpsertWithoutRoomInput = {
    update: XOR<DepartmentTBLUpdateWithoutRoomInput, DepartmentTBLUncheckedUpdateWithoutRoomInput>
    create: XOR<DepartmentTBLCreateWithoutRoomInput, DepartmentTBLUncheckedCreateWithoutRoomInput>
    where?: DepartmentTBLWhereInput
  }

  export type DepartmentTBLUpdateToOneWithWhereWithoutRoomInput = {
    where?: DepartmentTBLWhereInput
    data: XOR<DepartmentTBLUpdateWithoutRoomInput, DepartmentTBLUncheckedUpdateWithoutRoomInput>
  }

  export type DepartmentTBLUpdateWithoutRoomInput = {
    departmentname?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUpdateManyWithoutDepartmentrefNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutDepartmentNestedInput
  }

  export type DepartmentTBLUncheckedUpdateWithoutRoomInput = {
    departmentid?: IntFieldUpdateOperationsInput | number
    departmentname?: StringFieldUpdateOperationsInput | string
    buildingid?: IntFieldUpdateOperationsInput | number
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutDepartmentrefNestedInput
  }

  export type EmployeeTBLUpsertWithWhereUniqueWithoutRomidInput = {
    where: EmployeeTBLWhereUniqueInput
    update: XOR<EmployeeTBLUpdateWithoutRomidInput, EmployeeTBLUncheckedUpdateWithoutRomidInput>
    create: XOR<EmployeeTBLCreateWithoutRomidInput, EmployeeTBLUncheckedCreateWithoutRomidInput>
  }

  export type EmployeeTBLUpdateWithWhereUniqueWithoutRomidInput = {
    where: EmployeeTBLWhereUniqueInput
    data: XOR<EmployeeTBLUpdateWithoutRomidInput, EmployeeTBLUncheckedUpdateWithoutRomidInput>
  }

  export type EmployeeTBLUpdateManyWithWhereWithoutRomidInput = {
    where: EmployeeTBLScalarWhereInput
    data: XOR<EmployeeTBLUpdateManyMutationInput, EmployeeTBLUncheckedUpdateManyWithoutRomidInput>
  }

  export type ItemsTBLCreateWithoutCatidInput = {
    itemname: string
    itemimagurl: string
    itemidescription: string
    creator: UsersTBLCreateNestedOneWithoutItemsInput
    CartItems?: CartItemsTBLCreateNestedManyWithoutItemidsInput
  }

  export type ItemsTBLUncheckedCreateWithoutCatidInput = {
    userid: number
    itemid?: number
    itemname: string
    itemimagurl: string
    itemidescription: string
    CartItems?: CartItemsTBLUncheckedCreateNestedManyWithoutItemidsInput
  }

  export type ItemsTBLCreateOrConnectWithoutCatidInput = {
    where: ItemsTBLWhereUniqueInput
    create: XOR<ItemsTBLCreateWithoutCatidInput, ItemsTBLUncheckedCreateWithoutCatidInput>
  }

  export type ItemsTBLCreateManyCatidInputEnvelope = {
    data: ItemsTBLCreateManyCatidInput | ItemsTBLCreateManyCatidInput[]
    skipDuplicates?: boolean
  }

  export type ItemsTBLUpsertWithWhereUniqueWithoutCatidInput = {
    where: ItemsTBLWhereUniqueInput
    update: XOR<ItemsTBLUpdateWithoutCatidInput, ItemsTBLUncheckedUpdateWithoutCatidInput>
    create: XOR<ItemsTBLCreateWithoutCatidInput, ItemsTBLUncheckedCreateWithoutCatidInput>
  }

  export type ItemsTBLUpdateWithWhereUniqueWithoutCatidInput = {
    where: ItemsTBLWhereUniqueInput
    data: XOR<ItemsTBLUpdateWithoutCatidInput, ItemsTBLUncheckedUpdateWithoutCatidInput>
  }

  export type ItemsTBLUpdateManyWithWhereWithoutCatidInput = {
    where: ItemsTBLScalarWhereInput
    data: XOR<ItemsTBLUpdateManyMutationInput, ItemsTBLUncheckedUpdateManyWithoutCatidInput>
  }

  export type UsersTBLCreateWithoutItemsInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    role: string
    Employee?: EmployeeTBLCreateNestedManyWithoutEmpInput
    Tokens?: TokensTBLCreateNestedManyWithoutReftokenInput
    Officeboy?: OfficeBoyTBLCreateNestedManyWithoutOfficeboyInput
  }

  export type UsersTBLUncheckedCreateWithoutItemsInput = {
    userid?: number
    firstname: string
    lastname: string
    email: string
    password: string
    role: string
    Employee?: EmployeeTBLUncheckedCreateNestedManyWithoutEmpInput
    Tokens?: TokensTBLUncheckedCreateNestedManyWithoutReftokenInput
    Officeboy?: OfficeBoyTBLUncheckedCreateNestedManyWithoutOfficeboyInput
  }

  export type UsersTBLCreateOrConnectWithoutItemsInput = {
    where: UsersTBLWhereUniqueInput
    create: XOR<UsersTBLCreateWithoutItemsInput, UsersTBLUncheckedCreateWithoutItemsInput>
  }

  export type CategoriesTblCreateWithoutItemInput = {
    categoryname: string
  }

  export type CategoriesTblUncheckedCreateWithoutItemInput = {
    categoryid?: number
    categoryname: string
  }

  export type CategoriesTblCreateOrConnectWithoutItemInput = {
    where: CategoriesTblWhereUniqueInput
    create: XOR<CategoriesTblCreateWithoutItemInput, CategoriesTblUncheckedCreateWithoutItemInput>
  }

  export type CartItemsTBLCreateWithoutItemidsInput = {
    quanity: number
    itemsize: string
    notes?: string | null
    carttid?: CartTBLCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemsTBLUncheckedCreateWithoutItemidsInput = {
    cartitemid?: number
    quanity: number
    cartid: number
    itemsize: string
    notes?: string | null
  }

  export type CartItemsTBLCreateOrConnectWithoutItemidsInput = {
    where: CartItemsTBLWhereUniqueInput
    create: XOR<CartItemsTBLCreateWithoutItemidsInput, CartItemsTBLUncheckedCreateWithoutItemidsInput>
  }

  export type CartItemsTBLCreateManyItemidsInputEnvelope = {
    data: CartItemsTBLCreateManyItemidsInput | CartItemsTBLCreateManyItemidsInput[]
    skipDuplicates?: boolean
  }

  export type UsersTBLUpsertWithoutItemsInput = {
    update: XOR<UsersTBLUpdateWithoutItemsInput, UsersTBLUncheckedUpdateWithoutItemsInput>
    create: XOR<UsersTBLCreateWithoutItemsInput, UsersTBLUncheckedCreateWithoutItemsInput>
    where?: UsersTBLWhereInput
  }

  export type UsersTBLUpdateToOneWithWhereWithoutItemsInput = {
    where?: UsersTBLWhereInput
    data: XOR<UsersTBLUpdateWithoutItemsInput, UsersTBLUncheckedUpdateWithoutItemsInput>
  }

  export type UsersTBLUpdateWithoutItemsInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUpdateManyWithoutEmpNestedInput
    Tokens?: TokensTBLUpdateManyWithoutReftokenNestedInput
    Officeboy?: OfficeBoyTBLUpdateManyWithoutOfficeboyNestedInput
  }

  export type UsersTBLUncheckedUpdateWithoutItemsInput = {
    userid?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutEmpNestedInput
    Tokens?: TokensTBLUncheckedUpdateManyWithoutReftokenNestedInput
    Officeboy?: OfficeBoyTBLUncheckedUpdateManyWithoutOfficeboyNestedInput
  }

  export type CategoriesTblUpsertWithoutItemInput = {
    update: XOR<CategoriesTblUpdateWithoutItemInput, CategoriesTblUncheckedUpdateWithoutItemInput>
    create: XOR<CategoriesTblCreateWithoutItemInput, CategoriesTblUncheckedCreateWithoutItemInput>
    where?: CategoriesTblWhereInput
  }

  export type CategoriesTblUpdateToOneWithWhereWithoutItemInput = {
    where?: CategoriesTblWhereInput
    data: XOR<CategoriesTblUpdateWithoutItemInput, CategoriesTblUncheckedUpdateWithoutItemInput>
  }

  export type CategoriesTblUpdateWithoutItemInput = {
    categoryname?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesTblUncheckedUpdateWithoutItemInput = {
    categoryid?: IntFieldUpdateOperationsInput | number
    categoryname?: StringFieldUpdateOperationsInput | string
  }

  export type CartItemsTBLUpsertWithWhereUniqueWithoutItemidsInput = {
    where: CartItemsTBLWhereUniqueInput
    update: XOR<CartItemsTBLUpdateWithoutItemidsInput, CartItemsTBLUncheckedUpdateWithoutItemidsInput>
    create: XOR<CartItemsTBLCreateWithoutItemidsInput, CartItemsTBLUncheckedCreateWithoutItemidsInput>
  }

  export type CartItemsTBLUpdateWithWhereUniqueWithoutItemidsInput = {
    where: CartItemsTBLWhereUniqueInput
    data: XOR<CartItemsTBLUpdateWithoutItemidsInput, CartItemsTBLUncheckedUpdateWithoutItemidsInput>
  }

  export type CartItemsTBLUpdateManyWithWhereWithoutItemidsInput = {
    where: CartItemsTBLScalarWhereInput
    data: XOR<CartItemsTBLUpdateManyMutationInput, CartItemsTBLUncheckedUpdateManyWithoutItemidsInput>
  }

  export type CartItemsTBLScalarWhereInput = {
    AND?: CartItemsTBLScalarWhereInput | CartItemsTBLScalarWhereInput[]
    OR?: CartItemsTBLScalarWhereInput[]
    NOT?: CartItemsTBLScalarWhereInput | CartItemsTBLScalarWhereInput[]
    cartitemid?: IntFilter<"CartItemsTBL"> | number
    quanity?: IntFilter<"CartItemsTBL"> | number
    cartid?: IntFilter<"CartItemsTBL"> | number
    itemsize?: StringFilter<"CartItemsTBL"> | string
    notes?: StringNullableFilter<"CartItemsTBL"> | string | null
    itemid?: IntFilter<"CartItemsTBL"> | number
  }

  export type EmployeeTBLCreateWithoutOrdersTBLInput = {
    emp?: UsersTBLCreateNestedOneWithoutEmployeeInput
    romid: RoomTBLCreateNestedOneWithoutEmployeeInput
    offid: OfficeTBLCreateNestedOneWithoutEmployeeInput
    sitid: SiteTBLCreateNestedOneWithoutEmployeeInput
    bulidingref: BuildingTBLCreateNestedOneWithoutEmployeeInput
    departmentref: DepartmentTBLCreateNestedOneWithoutEmployeeInput
    Cart?: CartTBLCreateNestedManyWithoutEmployeeidInput
  }

  export type EmployeeTBLUncheckedCreateWithoutOrdersTBLInput = {
    empid?: number
    roomid: number
    officeid: number
    siteid: number
    buildingid: number
    departmentid: number
    Cart?: CartTBLUncheckedCreateNestedManyWithoutEmployeeidInput
  }

  export type EmployeeTBLCreateOrConnectWithoutOrdersTBLInput = {
    where: EmployeeTBLWhereUniqueInput
    create: XOR<EmployeeTBLCreateWithoutOrdersTBLInput, EmployeeTBLUncheckedCreateWithoutOrdersTBLInput>
  }

  export type OrderItemsTBLCreateWithoutOrdersidInput = {
    itemname: string
    itemquantity: number
    itemsize: string
  }

  export type OrderItemsTBLUncheckedCreateWithoutOrdersidInput = {
    orderitemid?: number
    itemname: string
    itemquantity: number
    itemsize: string
  }

  export type OrderItemsTBLCreateOrConnectWithoutOrdersidInput = {
    where: OrderItemsTBLWhereUniqueInput
    create: XOR<OrderItemsTBLCreateWithoutOrdersidInput, OrderItemsTBLUncheckedCreateWithoutOrdersidInput>
  }

  export type OrderItemsTBLCreateManyOrdersidInputEnvelope = {
    data: OrderItemsTBLCreateManyOrdersidInput | OrderItemsTBLCreateManyOrdersidInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTBLUpsertWithoutOrdersTBLInput = {
    update: XOR<EmployeeTBLUpdateWithoutOrdersTBLInput, EmployeeTBLUncheckedUpdateWithoutOrdersTBLInput>
    create: XOR<EmployeeTBLCreateWithoutOrdersTBLInput, EmployeeTBLUncheckedCreateWithoutOrdersTBLInput>
    where?: EmployeeTBLWhereInput
  }

  export type EmployeeTBLUpdateToOneWithWhereWithoutOrdersTBLInput = {
    where?: EmployeeTBLWhereInput
    data: XOR<EmployeeTBLUpdateWithoutOrdersTBLInput, EmployeeTBLUncheckedUpdateWithoutOrdersTBLInput>
  }

  export type EmployeeTBLUpdateWithoutOrdersTBLInput = {
    emp?: UsersTBLUpdateOneRequiredWithoutEmployeeNestedInput
    romid?: RoomTBLUpdateOneRequiredWithoutEmployeeNestedInput
    offid?: OfficeTBLUpdateOneRequiredWithoutEmployeeNestedInput
    sitid?: SiteTBLUpdateOneRequiredWithoutEmployeeNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutEmployeeNestedInput
    departmentref?: DepartmentTBLUpdateOneRequiredWithoutEmployeeNestedInput
    Cart?: CartTBLUpdateManyWithoutEmployeeidNestedInput
  }

  export type EmployeeTBLUncheckedUpdateWithoutOrdersTBLInput = {
    empid?: IntFieldUpdateOperationsInput | number
    roomid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
    Cart?: CartTBLUncheckedUpdateManyWithoutEmployeeidNestedInput
  }

  export type OrderItemsTBLUpsertWithWhereUniqueWithoutOrdersidInput = {
    where: OrderItemsTBLWhereUniqueInput
    update: XOR<OrderItemsTBLUpdateWithoutOrdersidInput, OrderItemsTBLUncheckedUpdateWithoutOrdersidInput>
    create: XOR<OrderItemsTBLCreateWithoutOrdersidInput, OrderItemsTBLUncheckedCreateWithoutOrdersidInput>
  }

  export type OrderItemsTBLUpdateWithWhereUniqueWithoutOrdersidInput = {
    where: OrderItemsTBLWhereUniqueInput
    data: XOR<OrderItemsTBLUpdateWithoutOrdersidInput, OrderItemsTBLUncheckedUpdateWithoutOrdersidInput>
  }

  export type OrderItemsTBLUpdateManyWithWhereWithoutOrdersidInput = {
    where: OrderItemsTBLScalarWhereInput
    data: XOR<OrderItemsTBLUpdateManyMutationInput, OrderItemsTBLUncheckedUpdateManyWithoutOrdersidInput>
  }

  export type OrderItemsTBLScalarWhereInput = {
    AND?: OrderItemsTBLScalarWhereInput | OrderItemsTBLScalarWhereInput[]
    OR?: OrderItemsTBLScalarWhereInput[]
    NOT?: OrderItemsTBLScalarWhereInput | OrderItemsTBLScalarWhereInput[]
    orderitemid?: IntFilter<"OrderItemsTBL"> | number
    itemname?: StringFilter<"OrderItemsTBL"> | string
    itemquantity?: IntFilter<"OrderItemsTBL"> | number
    itemsize?: StringFilter<"OrderItemsTBL"> | string
    orderid?: IntFilter<"OrderItemsTBL"> | number
  }

  export type OrdersTBLCreateWithoutOrderItemsInput = {
    empref: EmployeeTBLCreateNestedOneWithoutOrdersTBLInput
  }

  export type OrdersTBLUncheckedCreateWithoutOrderItemsInput = {
    orderid?: number
    empid: number
  }

  export type OrdersTBLCreateOrConnectWithoutOrderItemsInput = {
    where: OrdersTBLWhereUniqueInput
    create: XOR<OrdersTBLCreateWithoutOrderItemsInput, OrdersTBLUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrdersTBLUpsertWithoutOrderItemsInput = {
    update: XOR<OrdersTBLUpdateWithoutOrderItemsInput, OrdersTBLUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrdersTBLCreateWithoutOrderItemsInput, OrdersTBLUncheckedCreateWithoutOrderItemsInput>
    where?: OrdersTBLWhereInput
  }

  export type OrdersTBLUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrdersTBLWhereInput
    data: XOR<OrdersTBLUpdateWithoutOrderItemsInput, OrdersTBLUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrdersTBLUpdateWithoutOrderItemsInput = {
    empref?: EmployeeTBLUpdateOneRequiredWithoutOrdersTBLNestedInput
  }

  export type OrdersTBLUncheckedUpdateWithoutOrderItemsInput = {
    orderid?: IntFieldUpdateOperationsInput | number
    empid?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeTBLCreateWithoutCartInput = {
    emp?: UsersTBLCreateNestedOneWithoutEmployeeInput
    romid: RoomTBLCreateNestedOneWithoutEmployeeInput
    offid: OfficeTBLCreateNestedOneWithoutEmployeeInput
    sitid: SiteTBLCreateNestedOneWithoutEmployeeInput
    bulidingref: BuildingTBLCreateNestedOneWithoutEmployeeInput
    departmentref: DepartmentTBLCreateNestedOneWithoutEmployeeInput
    OrdersTBL?: OrdersTBLCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLUncheckedCreateWithoutCartInput = {
    empid?: number
    roomid: number
    officeid: number
    siteid: number
    buildingid: number
    departmentid: number
    OrdersTBL?: OrdersTBLUncheckedCreateNestedManyWithoutEmprefInput
  }

  export type EmployeeTBLCreateOrConnectWithoutCartInput = {
    where: EmployeeTBLWhereUniqueInput
    create: XOR<EmployeeTBLCreateWithoutCartInput, EmployeeTBLUncheckedCreateWithoutCartInput>
  }

  export type CartItemsTBLCreateWithoutCarttidInput = {
    quanity: number
    itemsize: string
    notes?: string | null
    itemids: ItemsTBLCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemsTBLUncheckedCreateWithoutCarttidInput = {
    cartitemid?: number
    quanity: number
    itemsize: string
    notes?: string | null
    itemid: number
  }

  export type CartItemsTBLCreateOrConnectWithoutCarttidInput = {
    where: CartItemsTBLWhereUniqueInput
    create: XOR<CartItemsTBLCreateWithoutCarttidInput, CartItemsTBLUncheckedCreateWithoutCarttidInput>
  }

  export type CartItemsTBLCreateManyCarttidInputEnvelope = {
    data: CartItemsTBLCreateManyCarttidInput | CartItemsTBLCreateManyCarttidInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTBLUpsertWithoutCartInput = {
    update: XOR<EmployeeTBLUpdateWithoutCartInput, EmployeeTBLUncheckedUpdateWithoutCartInput>
    create: XOR<EmployeeTBLCreateWithoutCartInput, EmployeeTBLUncheckedCreateWithoutCartInput>
    where?: EmployeeTBLWhereInput
  }

  export type EmployeeTBLUpdateToOneWithWhereWithoutCartInput = {
    where?: EmployeeTBLWhereInput
    data: XOR<EmployeeTBLUpdateWithoutCartInput, EmployeeTBLUncheckedUpdateWithoutCartInput>
  }

  export type EmployeeTBLUpdateWithoutCartInput = {
    emp?: UsersTBLUpdateOneRequiredWithoutEmployeeNestedInput
    romid?: RoomTBLUpdateOneRequiredWithoutEmployeeNestedInput
    offid?: OfficeTBLUpdateOneRequiredWithoutEmployeeNestedInput
    sitid?: SiteTBLUpdateOneRequiredWithoutEmployeeNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutEmployeeNestedInput
    departmentref?: DepartmentTBLUpdateOneRequiredWithoutEmployeeNestedInput
    OrdersTBL?: OrdersTBLUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateWithoutCartInput = {
    empid?: IntFieldUpdateOperationsInput | number
    roomid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
    OrdersTBL?: OrdersTBLUncheckedUpdateManyWithoutEmprefNestedInput
  }

  export type CartItemsTBLUpsertWithWhereUniqueWithoutCarttidInput = {
    where: CartItemsTBLWhereUniqueInput
    update: XOR<CartItemsTBLUpdateWithoutCarttidInput, CartItemsTBLUncheckedUpdateWithoutCarttidInput>
    create: XOR<CartItemsTBLCreateWithoutCarttidInput, CartItemsTBLUncheckedCreateWithoutCarttidInput>
  }

  export type CartItemsTBLUpdateWithWhereUniqueWithoutCarttidInput = {
    where: CartItemsTBLWhereUniqueInput
    data: XOR<CartItemsTBLUpdateWithoutCarttidInput, CartItemsTBLUncheckedUpdateWithoutCarttidInput>
  }

  export type CartItemsTBLUpdateManyWithWhereWithoutCarttidInput = {
    where: CartItemsTBLScalarWhereInput
    data: XOR<CartItemsTBLUpdateManyMutationInput, CartItemsTBLUncheckedUpdateManyWithoutCarttidInput>
  }

  export type CartTBLCreateWithoutCartItemsInput = {
    employeeid: EmployeeTBLCreateNestedOneWithoutCartInput
  }

  export type CartTBLUncheckedCreateWithoutCartItemsInput = {
    cartid?: number
    empid: number
  }

  export type CartTBLCreateOrConnectWithoutCartItemsInput = {
    where: CartTBLWhereUniqueInput
    create: XOR<CartTBLCreateWithoutCartItemsInput, CartTBLUncheckedCreateWithoutCartItemsInput>
  }

  export type ItemsTBLCreateWithoutCartItemsInput = {
    itemname: string
    itemimagurl: string
    itemidescription: string
    creator: UsersTBLCreateNestedOneWithoutItemsInput
    catid: CategoriesTblCreateNestedOneWithoutItemInput
  }

  export type ItemsTBLUncheckedCreateWithoutCartItemsInput = {
    userid: number
    itemid?: number
    categoryid: number
    itemname: string
    itemimagurl: string
    itemidescription: string
  }

  export type ItemsTBLCreateOrConnectWithoutCartItemsInput = {
    where: ItemsTBLWhereUniqueInput
    create: XOR<ItemsTBLCreateWithoutCartItemsInput, ItemsTBLUncheckedCreateWithoutCartItemsInput>
  }

  export type CartTBLUpsertWithoutCartItemsInput = {
    update: XOR<CartTBLUpdateWithoutCartItemsInput, CartTBLUncheckedUpdateWithoutCartItemsInput>
    create: XOR<CartTBLCreateWithoutCartItemsInput, CartTBLUncheckedCreateWithoutCartItemsInput>
    where?: CartTBLWhereInput
  }

  export type CartTBLUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: CartTBLWhereInput
    data: XOR<CartTBLUpdateWithoutCartItemsInput, CartTBLUncheckedUpdateWithoutCartItemsInput>
  }

  export type CartTBLUpdateWithoutCartItemsInput = {
    employeeid?: EmployeeTBLUpdateOneRequiredWithoutCartNestedInput
  }

  export type CartTBLUncheckedUpdateWithoutCartItemsInput = {
    cartid?: IntFieldUpdateOperationsInput | number
    empid?: IntFieldUpdateOperationsInput | number
  }

  export type ItemsTBLUpsertWithoutCartItemsInput = {
    update: XOR<ItemsTBLUpdateWithoutCartItemsInput, ItemsTBLUncheckedUpdateWithoutCartItemsInput>
    create: XOR<ItemsTBLCreateWithoutCartItemsInput, ItemsTBLUncheckedCreateWithoutCartItemsInput>
    where?: ItemsTBLWhereInput
  }

  export type ItemsTBLUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: ItemsTBLWhereInput
    data: XOR<ItemsTBLUpdateWithoutCartItemsInput, ItemsTBLUncheckedUpdateWithoutCartItemsInput>
  }

  export type ItemsTBLUpdateWithoutCartItemsInput = {
    itemname?: StringFieldUpdateOperationsInput | string
    itemimagurl?: StringFieldUpdateOperationsInput | string
    itemidescription?: StringFieldUpdateOperationsInput | string
    creator?: UsersTBLUpdateOneRequiredWithoutItemsNestedInput
    catid?: CategoriesTblUpdateOneRequiredWithoutItemNestedInput
  }

  export type ItemsTBLUncheckedUpdateWithoutCartItemsInput = {
    userid?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    categoryid?: IntFieldUpdateOperationsInput | number
    itemname?: StringFieldUpdateOperationsInput | string
    itemimagurl?: StringFieldUpdateOperationsInput | string
    itemidescription?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeTBLCreateManyEmpInput = {
    roomid: number
    officeid: number
    siteid: number
    buildingid: number
    departmentid: number
  }

  export type ItemsTBLCreateManyCreatorInput = {
    itemid?: number
    categoryid: number
    itemname: string
    itemimagurl: string
    itemidescription: string
  }

  export type TokensTBLCreateManyReftokenInput = {
    tokenid?: number
    refreshtoken: string
  }

  export type OfficeBoyTBLCreateManyOfficeboyInput = {
    officeid: number
    siteid: number
  }

  export type EmployeeTBLUpdateWithoutEmpInput = {
    romid?: RoomTBLUpdateOneRequiredWithoutEmployeeNestedInput
    offid?: OfficeTBLUpdateOneRequiredWithoutEmployeeNestedInput
    sitid?: SiteTBLUpdateOneRequiredWithoutEmployeeNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutEmployeeNestedInput
    departmentref?: DepartmentTBLUpdateOneRequiredWithoutEmployeeNestedInput
    Cart?: CartTBLUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateWithoutEmpInput = {
    roomid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
    Cart?: CartTBLUncheckedUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUncheckedUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateManyWithoutEmpInput = {
    roomid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
  }

  export type ItemsTBLUpdateWithoutCreatorInput = {
    itemname?: StringFieldUpdateOperationsInput | string
    itemimagurl?: StringFieldUpdateOperationsInput | string
    itemidescription?: StringFieldUpdateOperationsInput | string
    catid?: CategoriesTblUpdateOneRequiredWithoutItemNestedInput
    CartItems?: CartItemsTBLUpdateManyWithoutItemidsNestedInput
  }

  export type ItemsTBLUncheckedUpdateWithoutCreatorInput = {
    itemid?: IntFieldUpdateOperationsInput | number
    categoryid?: IntFieldUpdateOperationsInput | number
    itemname?: StringFieldUpdateOperationsInput | string
    itemimagurl?: StringFieldUpdateOperationsInput | string
    itemidescription?: StringFieldUpdateOperationsInput | string
    CartItems?: CartItemsTBLUncheckedUpdateManyWithoutItemidsNestedInput
  }

  export type ItemsTBLUncheckedUpdateManyWithoutCreatorInput = {
    itemid?: IntFieldUpdateOperationsInput | number
    categoryid?: IntFieldUpdateOperationsInput | number
    itemname?: StringFieldUpdateOperationsInput | string
    itemimagurl?: StringFieldUpdateOperationsInput | string
    itemidescription?: StringFieldUpdateOperationsInput | string
  }

  export type TokensTBLUpdateWithoutReftokenInput = {
    refreshtoken?: StringFieldUpdateOperationsInput | string
  }

  export type TokensTBLUncheckedUpdateWithoutReftokenInput = {
    tokenid?: IntFieldUpdateOperationsInput | number
    refreshtoken?: StringFieldUpdateOperationsInput | string
  }

  export type TokensTBLUncheckedUpdateManyWithoutReftokenInput = {
    tokenid?: IntFieldUpdateOperationsInput | number
    refreshtoken?: StringFieldUpdateOperationsInput | string
  }

  export type OfficeBoyTBLUpdateWithoutOfficeboyInput = {
    offid?: OfficeTBLUpdateOneRequiredWithoutOfficeboyNestedInput
    siteref?: SiteTBLUpdateOneRequiredWithoutOfficeboyNestedInput
  }

  export type OfficeBoyTBLUncheckedUpdateWithoutOfficeboyInput = {
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
  }

  export type OfficeBoyTBLUncheckedUpdateManyWithoutOfficeboyInput = {
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
  }

  export type CartTBLCreateManyEmployeeidInput = {
    cartid?: number
  }

  export type OrdersTBLCreateManyEmprefInput = {
    orderid?: number
  }

  export type CartTBLUpdateWithoutEmployeeidInput = {
    CartItems?: CartItemsTBLUpdateManyWithoutCarttidNestedInput
  }

  export type CartTBLUncheckedUpdateWithoutEmployeeidInput = {
    cartid?: IntFieldUpdateOperationsInput | number
    CartItems?: CartItemsTBLUncheckedUpdateManyWithoutCarttidNestedInput
  }

  export type CartTBLUncheckedUpdateManyWithoutEmployeeidInput = {
    cartid?: IntFieldUpdateOperationsInput | number
  }

  export type OrdersTBLUpdateWithoutEmprefInput = {
    orderItems?: OrderItemsTBLUpdateManyWithoutOrdersidNestedInput
  }

  export type OrdersTBLUncheckedUpdateWithoutEmprefInput = {
    orderid?: IntFieldUpdateOperationsInput | number
    orderItems?: OrderItemsTBLUncheckedUpdateManyWithoutOrdersidNestedInput
  }

  export type OrdersTBLUncheckedUpdateManyWithoutEmprefInput = {
    orderid?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeTBLCreateManySitidInput = {
    empid?: number
    roomid: number
    officeid: number
    buildingid: number
    departmentid: number
  }

  export type BuildingTBLCreateManySiterefInput = {
    buildingid?: number
    buildingname: string
  }

  export type OfficeBoyTBLCreateManySiterefInput = {
    officeboyid?: number
    officeid: number
  }

  export type EmployeeTBLUpdateWithoutSitidInput = {
    emp?: UsersTBLUpdateOneRequiredWithoutEmployeeNestedInput
    romid?: RoomTBLUpdateOneRequiredWithoutEmployeeNestedInput
    offid?: OfficeTBLUpdateOneRequiredWithoutEmployeeNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutEmployeeNestedInput
    departmentref?: DepartmentTBLUpdateOneRequiredWithoutEmployeeNestedInput
    Cart?: CartTBLUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateWithoutSitidInput = {
    empid?: IntFieldUpdateOperationsInput | number
    roomid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
    Cart?: CartTBLUncheckedUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUncheckedUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateManyWithoutSitidInput = {
    empid?: IntFieldUpdateOperationsInput | number
    roomid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
  }

  export type BuildingTBLUpdateWithoutSiterefInput = {
    buildingname?: StringFieldUpdateOperationsInput | string
    Department?: DepartmentTBLUpdateManyWithoutBulidingrefNestedInput
    Office?: OfficeTBLUpdateManyWithoutBulidingrefNestedInput
    Employee?: EmployeeTBLUpdateManyWithoutBulidingrefNestedInput
  }

  export type BuildingTBLUncheckedUpdateWithoutSiterefInput = {
    buildingid?: IntFieldUpdateOperationsInput | number
    buildingname?: StringFieldUpdateOperationsInput | string
    Department?: DepartmentTBLUncheckedUpdateManyWithoutBulidingrefNestedInput
    Office?: OfficeTBLUncheckedUpdateManyWithoutBulidingrefNestedInput
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutBulidingrefNestedInput
  }

  export type BuildingTBLUncheckedUpdateManyWithoutSiterefInput = {
    buildingid?: IntFieldUpdateOperationsInput | number
    buildingname?: StringFieldUpdateOperationsInput | string
  }

  export type OfficeBoyTBLUpdateWithoutSiterefInput = {
    officeboy?: UsersTBLUpdateOneRequiredWithoutOfficeboyNestedInput
    offid?: OfficeTBLUpdateOneRequiredWithoutOfficeboyNestedInput
  }

  export type OfficeBoyTBLUncheckedUpdateWithoutSiterefInput = {
    officeboyid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
  }

  export type OfficeBoyTBLUncheckedUpdateManyWithoutSiterefInput = {
    officeboyid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
  }

  export type DepartmentTBLCreateManyBulidingrefInput = {
    departmentid?: number
    departmentname: string
  }

  export type OfficeTBLCreateManyBulidingrefInput = {
    officeid?: number
    officeno: number
  }

  export type EmployeeTBLCreateManyBulidingrefInput = {
    empid?: number
    roomid: number
    officeid: number
    siteid: number
    departmentid: number
  }

  export type DepartmentTBLUpdateWithoutBulidingrefInput = {
    departmentname?: StringFieldUpdateOperationsInput | string
    Room?: RoomTBLUpdateManyWithoutRoomdeprefNestedInput
    Employee?: EmployeeTBLUpdateManyWithoutDepartmentrefNestedInput
  }

  export type DepartmentTBLUncheckedUpdateWithoutBulidingrefInput = {
    departmentid?: IntFieldUpdateOperationsInput | number
    departmentname?: StringFieldUpdateOperationsInput | string
    Room?: RoomTBLUncheckedUpdateManyWithoutRoomdeprefNestedInput
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutDepartmentrefNestedInput
  }

  export type DepartmentTBLUncheckedUpdateManyWithoutBulidingrefInput = {
    departmentid?: IntFieldUpdateOperationsInput | number
    departmentname?: StringFieldUpdateOperationsInput | string
  }

  export type OfficeTBLUpdateWithoutBulidingrefInput = {
    officeno?: IntFieldUpdateOperationsInput | number
    Employee?: EmployeeTBLUpdateManyWithoutOffidNestedInput
    Officeboy?: OfficeBoyTBLUpdateManyWithoutOffidNestedInput
    Room?: RoomTBLUpdateManyWithoutOfficerefNestedInput
  }

  export type OfficeTBLUncheckedUpdateWithoutBulidingrefInput = {
    officeid?: IntFieldUpdateOperationsInput | number
    officeno?: IntFieldUpdateOperationsInput | number
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutOffidNestedInput
    Officeboy?: OfficeBoyTBLUncheckedUpdateManyWithoutOffidNestedInput
    Room?: RoomTBLUncheckedUpdateManyWithoutOfficerefNestedInput
  }

  export type OfficeTBLUncheckedUpdateManyWithoutBulidingrefInput = {
    officeid?: IntFieldUpdateOperationsInput | number
    officeno?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeTBLUpdateWithoutBulidingrefInput = {
    emp?: UsersTBLUpdateOneRequiredWithoutEmployeeNestedInput
    romid?: RoomTBLUpdateOneRequiredWithoutEmployeeNestedInput
    offid?: OfficeTBLUpdateOneRequiredWithoutEmployeeNestedInput
    sitid?: SiteTBLUpdateOneRequiredWithoutEmployeeNestedInput
    departmentref?: DepartmentTBLUpdateOneRequiredWithoutEmployeeNestedInput
    Cart?: CartTBLUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateWithoutBulidingrefInput = {
    empid?: IntFieldUpdateOperationsInput | number
    roomid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
    Cart?: CartTBLUncheckedUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUncheckedUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateManyWithoutBulidingrefInput = {
    empid?: IntFieldUpdateOperationsInput | number
    roomid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeTBLCreateManyOffidInput = {
    empid?: number
    roomid: number
    siteid: number
    buildingid: number
    departmentid: number
  }

  export type OfficeBoyTBLCreateManyOffidInput = {
    officeboyid?: number
    siteid: number
  }

  export type RoomTBLCreateManyOfficerefInput = {
    roomid?: number
    roomno: number
    roomname: string
    departmentid: number
  }

  export type EmployeeTBLUpdateWithoutOffidInput = {
    emp?: UsersTBLUpdateOneRequiredWithoutEmployeeNestedInput
    romid?: RoomTBLUpdateOneRequiredWithoutEmployeeNestedInput
    sitid?: SiteTBLUpdateOneRequiredWithoutEmployeeNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutEmployeeNestedInput
    departmentref?: DepartmentTBLUpdateOneRequiredWithoutEmployeeNestedInput
    Cart?: CartTBLUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateWithoutOffidInput = {
    empid?: IntFieldUpdateOperationsInput | number
    roomid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
    Cart?: CartTBLUncheckedUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUncheckedUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateManyWithoutOffidInput = {
    empid?: IntFieldUpdateOperationsInput | number
    roomid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
  }

  export type OfficeBoyTBLUpdateWithoutOffidInput = {
    officeboy?: UsersTBLUpdateOneRequiredWithoutOfficeboyNestedInput
    siteref?: SiteTBLUpdateOneRequiredWithoutOfficeboyNestedInput
  }

  export type OfficeBoyTBLUncheckedUpdateWithoutOffidInput = {
    officeboyid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
  }

  export type OfficeBoyTBLUncheckedUpdateManyWithoutOffidInput = {
    officeboyid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
  }

  export type RoomTBLUpdateWithoutOfficerefInput = {
    roomno?: IntFieldUpdateOperationsInput | number
    roomname?: StringFieldUpdateOperationsInput | string
    roomdepref?: DepartmentTBLUpdateOneRequiredWithoutRoomNestedInput
    Employee?: EmployeeTBLUpdateManyWithoutRomidNestedInput
  }

  export type RoomTBLUncheckedUpdateWithoutOfficerefInput = {
    roomid?: IntFieldUpdateOperationsInput | number
    roomno?: IntFieldUpdateOperationsInput | number
    roomname?: StringFieldUpdateOperationsInput | string
    departmentid?: IntFieldUpdateOperationsInput | number
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutRomidNestedInput
  }

  export type RoomTBLUncheckedUpdateManyWithoutOfficerefInput = {
    roomid?: IntFieldUpdateOperationsInput | number
    roomno?: IntFieldUpdateOperationsInput | number
    roomname?: StringFieldUpdateOperationsInput | string
    departmentid?: IntFieldUpdateOperationsInput | number
  }

  export type RoomTBLCreateManyRoomdeprefInput = {
    roomid?: number
    roomno: number
    roomname: string
    officeid: number
  }

  export type EmployeeTBLCreateManyDepartmentrefInput = {
    empid?: number
    roomid: number
    officeid: number
    siteid: number
    buildingid: number
  }

  export type RoomTBLUpdateWithoutRoomdeprefInput = {
    roomno?: IntFieldUpdateOperationsInput | number
    roomname?: StringFieldUpdateOperationsInput | string
    officeref?: OfficeTBLUpdateOneRequiredWithoutRoomNestedInput
    Employee?: EmployeeTBLUpdateManyWithoutRomidNestedInput
  }

  export type RoomTBLUncheckedUpdateWithoutRoomdeprefInput = {
    roomid?: IntFieldUpdateOperationsInput | number
    roomno?: IntFieldUpdateOperationsInput | number
    roomname?: StringFieldUpdateOperationsInput | string
    officeid?: IntFieldUpdateOperationsInput | number
    Employee?: EmployeeTBLUncheckedUpdateManyWithoutRomidNestedInput
  }

  export type RoomTBLUncheckedUpdateManyWithoutRoomdeprefInput = {
    roomid?: IntFieldUpdateOperationsInput | number
    roomno?: IntFieldUpdateOperationsInput | number
    roomname?: StringFieldUpdateOperationsInput | string
    officeid?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeTBLUpdateWithoutDepartmentrefInput = {
    emp?: UsersTBLUpdateOneRequiredWithoutEmployeeNestedInput
    romid?: RoomTBLUpdateOneRequiredWithoutEmployeeNestedInput
    offid?: OfficeTBLUpdateOneRequiredWithoutEmployeeNestedInput
    sitid?: SiteTBLUpdateOneRequiredWithoutEmployeeNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutEmployeeNestedInput
    Cart?: CartTBLUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateWithoutDepartmentrefInput = {
    empid?: IntFieldUpdateOperationsInput | number
    roomid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    Cart?: CartTBLUncheckedUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUncheckedUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateManyWithoutDepartmentrefInput = {
    empid?: IntFieldUpdateOperationsInput | number
    roomid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeTBLCreateManyRomidInput = {
    empid?: number
    officeid: number
    siteid: number
    buildingid: number
    departmentid: number
  }

  export type EmployeeTBLUpdateWithoutRomidInput = {
    emp?: UsersTBLUpdateOneRequiredWithoutEmployeeNestedInput
    offid?: OfficeTBLUpdateOneRequiredWithoutEmployeeNestedInput
    sitid?: SiteTBLUpdateOneRequiredWithoutEmployeeNestedInput
    bulidingref?: BuildingTBLUpdateOneRequiredWithoutEmployeeNestedInput
    departmentref?: DepartmentTBLUpdateOneRequiredWithoutEmployeeNestedInput
    Cart?: CartTBLUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateWithoutRomidInput = {
    empid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
    Cart?: CartTBLUncheckedUpdateManyWithoutEmployeeidNestedInput
    OrdersTBL?: OrdersTBLUncheckedUpdateManyWithoutEmprefNestedInput
  }

  export type EmployeeTBLUncheckedUpdateManyWithoutRomidInput = {
    empid?: IntFieldUpdateOperationsInput | number
    officeid?: IntFieldUpdateOperationsInput | number
    siteid?: IntFieldUpdateOperationsInput | number
    buildingid?: IntFieldUpdateOperationsInput | number
    departmentid?: IntFieldUpdateOperationsInput | number
  }

  export type ItemsTBLCreateManyCatidInput = {
    userid: number
    itemid?: number
    itemname: string
    itemimagurl: string
    itemidescription: string
  }

  export type ItemsTBLUpdateWithoutCatidInput = {
    itemname?: StringFieldUpdateOperationsInput | string
    itemimagurl?: StringFieldUpdateOperationsInput | string
    itemidescription?: StringFieldUpdateOperationsInput | string
    creator?: UsersTBLUpdateOneRequiredWithoutItemsNestedInput
    CartItems?: CartItemsTBLUpdateManyWithoutItemidsNestedInput
  }

  export type ItemsTBLUncheckedUpdateWithoutCatidInput = {
    userid?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    itemname?: StringFieldUpdateOperationsInput | string
    itemimagurl?: StringFieldUpdateOperationsInput | string
    itemidescription?: StringFieldUpdateOperationsInput | string
    CartItems?: CartItemsTBLUncheckedUpdateManyWithoutItemidsNestedInput
  }

  export type ItemsTBLUncheckedUpdateManyWithoutCatidInput = {
    userid?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    itemname?: StringFieldUpdateOperationsInput | string
    itemimagurl?: StringFieldUpdateOperationsInput | string
    itemidescription?: StringFieldUpdateOperationsInput | string
  }

  export type CartItemsTBLCreateManyItemidsInput = {
    cartitemid?: number
    quanity: number
    cartid: number
    itemsize: string
    notes?: string | null
  }

  export type CartItemsTBLUpdateWithoutItemidsInput = {
    quanity?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    carttid?: CartTBLUpdateOneWithoutCartItemsNestedInput
  }

  export type CartItemsTBLUncheckedUpdateWithoutItemidsInput = {
    cartitemid?: IntFieldUpdateOperationsInput | number
    quanity?: IntFieldUpdateOperationsInput | number
    cartid?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemsTBLUncheckedUpdateManyWithoutItemidsInput = {
    cartitemid?: IntFieldUpdateOperationsInput | number
    quanity?: IntFieldUpdateOperationsInput | number
    cartid?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemsTBLCreateManyOrdersidInput = {
    orderitemid?: number
    itemname: string
    itemquantity: number
    itemsize: string
  }

  export type OrderItemsTBLUpdateWithoutOrdersidInput = {
    itemname?: StringFieldUpdateOperationsInput | string
    itemquantity?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemsTBLUncheckedUpdateWithoutOrdersidInput = {
    orderitemid?: IntFieldUpdateOperationsInput | number
    itemname?: StringFieldUpdateOperationsInput | string
    itemquantity?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemsTBLUncheckedUpdateManyWithoutOrdersidInput = {
    orderitemid?: IntFieldUpdateOperationsInput | number
    itemname?: StringFieldUpdateOperationsInput | string
    itemquantity?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
  }

  export type CartItemsTBLCreateManyCarttidInput = {
    cartitemid?: number
    quanity: number
    itemsize: string
    notes?: string | null
    itemid: number
  }

  export type CartItemsTBLUpdateWithoutCarttidInput = {
    quanity?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    itemids?: ItemsTBLUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemsTBLUncheckedUpdateWithoutCarttidInput = {
    cartitemid?: IntFieldUpdateOperationsInput | number
    quanity?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    itemid?: IntFieldUpdateOperationsInput | number
  }

  export type CartItemsTBLUncheckedUpdateManyWithoutCarttidInput = {
    cartitemid?: IntFieldUpdateOperationsInput | number
    quanity?: IntFieldUpdateOperationsInput | number
    itemsize?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    itemid?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}